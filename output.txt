[{"name":"Transcribe and return audios as text","description":"","icon":null,"icon_bg_color":null,"gradient":null,"data":{"nodes":[{"id":"CustomComponent-88JDQ","type":"genericNode","position":{"x":-3037.3774153953773,"y":-1028.6033910478436},"data":{"node":{"template":{"_type":"Component","input_data":{"tool_mode":false,"trace_as_metadata":true,"list":true,"trace_as_input":true,"required":true,"placeholder":"","show":true,"name":"input_data","value":"","display_name":"Input Data","advanced":false,"input_types":["Data"],"dynamic":false,"info":"Audio message data containing URL and metadata","title_case":false,"type":"other","_input_type":"DataInput"},"api_key":{"load_from_db":true,"required":true,"placeholder":"","show":true,"name":"api_key","value":"audio_trans","display_name":"API Key","advanced":false,"input_types":["Message"],"dynamic":false,"info":"API key for authentication","title_case":false,"password":true,"type":"str","_input_type":"SecretStrInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Dict, Any, Optional, List\r\nfrom sqlalchemy import create_engine, text\r\nimport uuid\r\nimport time\r\nimport string\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    SecretStrInput,\r\n    StrInput,\r\n    DataInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\ndef base36encode(number: int) -> str:\r\n    \"\"\"Convert an integer to base36 string.\"\"\"\r\n    alphabet = string.digits + string.ascii_lowercase\r\n    base36 = ''\r\n    \r\n    while number:\r\n        number, i = divmod(number, 36)\r\n        base36 = alphabet[i] + base36\r\n    \r\n    return base36 or '0'\r\n\r\n\r\nclass AudioProcessorIteratorComponent(Component):\r\n    display_name = \"Audio Transcriber Iterator\"\r\n    description = \"Transcribe multiple audio files from URLs and store results in database\"\r\n    icon = \"mic\"\r\n    name = \"audio_transcriber_iterator\"\r\n\r\n    def __init__(self, **data):\r\n        super().__init__(**data)\r\n        self._engine = None\r\n        self._last_api_call = False  # Track last API call for delay logic\r\n\r\n    def __del__(self):\r\n        \"\"\"Cleanup method to dispose of the engine when component is destroyed.\"\"\"\r\n        self.cleanup()\r\n\r\n    def cleanup(self):\r\n        \"\"\"Cleanup database resources.\"\"\"\r\n        if self._engine:\r\n            self.log(\"Disposing database engine...\")\r\n            self._engine.dispose()\r\n            self._engine = None\r\n\r\n    inputs = [\r\n        IntInput(\r\n            name=\"transcription_delay\",\r\n            display_name=\"Transcription Delay\",\r\n            info=\"Delay in milliseconds between transcription API calls (for rate limiting)\",\r\n            advanced=True,\r\n            required=False,\r\n        ),\r\n        DataInput(\r\n            name=\"input_data\",\r\n            display_name=\"Input Data\",\r\n            info=\"Audio message data containing URL and metadata\",\r\n            required=True,\r\n            is_list=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"server_url\",\r\n            display_name=\"Server URL\",\r\n            info=\"Transcription server URL (e.g., http://localhost:4040)\",\r\n            required=True,\r\n        ),\r\n        StrInput(\r\n            name=\"connection_string\",\r\n            display_name=\"Connection String\",\r\n            info=\"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)\",\r\n            required=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"language\",\r\n            display_name=\"Language\",\r\n            info=\"Optional: Language code for transcription\",\r\n            required=False,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"api_key\",\r\n            display_name=\"API Key\",\r\n            info=\"API key for authentication\",\r\n            required=True,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"transcriptions\",\r\n            display_name=\"Transcriptions\",\r\n            method=\"transcribe_audio\",\r\n            type=\"list[Data]\"\r\n        ),\r\n    ]\r\n\r\n    def generate_cuid2(self) -> str:\r\n        \"\"\"Generate a CUID2-like ID.\"\"\"\r\n        # Get current time in milliseconds and convert to base36\r\n        timestamp = int(time.time() * 1000)\r\n        timestamp_b36 = base36encode(timestamp)\r\n\r\n        # Generate some random bytes\r\n        random_bytes = uuid.uuid4().bytes[:8]\r\n        random_b36 = base36encode(int.from_bytes(random_bytes, 'big'))\r\n\r\n        # Combine to match pattern length (25 chars)\r\n        cuid = f\"{timestamp_b36[:6]}{random_b36[:19]}\"\r\n        return cuid\r\n\r\n    def get_engine(self):\r\n        \"\"\"Get or create SQLAlchemy engine with proper connection pooling.\"\"\"\r\n        if not self._engine:\r\n            try:\r\n                self._engine = create_engine(\r\n                    self.connection_string,\r\n                    echo=False,\r\n                    pool_size=5,  # Set maximum pool size\r\n                    max_overflow=10,  # Allow up to 10 connections to overflow\r\n                    pool_timeout=30,  # Wait up to 30 seconds for available connection\r\n                    pool_recycle=3600,  # Recycle connections after 1 hour\r\n                    pool_pre_ping=True  # Verify connection is still valid before using\r\n                )\r\n                \r\n                # Test the connection\r\n                with self._engine.connect() as conn:\r\n                    conn.execute(text(\"SELECT 1\"))\r\n                    \r\n            except Exception as e:\r\n                self.log(f\"Failed to create database engine: {str(e)}\")\r\n                self.cleanup()  # Ensure cleanup on error\r\n                raise ValueError(f\"Database connection failed: {str(e)}\") from e\r\n        return self._engine\r\n\r\n    def extract_message_id(self, key: Dict[str, Any]) -> Optional[str]:\r\n        \"\"\"Extract message ID from key dictionary.\"\"\"\r\n        try:\r\n            if isinstance(key, str):\r\n                key = json.loads(key)\r\n            # Return just the base ID without any _TRANS suffix\r\n            msg_id = key.get('id', '')\r\n            return msg_id.split('_')[0] if '_' in msg_id else msg_id\r\n        except Exception as e:\r\n            self.log(f\"Error extracting message ID: {str(e)}\")\r\n            return None\r\n\r\n    def check_existing_transcription(self, message_id: str) -> Optional[Dict[str, Any]]:\r\n        \"\"\"Check if transcription already exists for this message.\"\"\"\r\n        try:\r\n            query = '''\r\n                SELECT message\r\n                FROM public.\"Message\"\r\n                WHERE id = :transcription_id\r\n            '''\r\n            \r\n            # Create the transcription ID to check\r\n            transcription_id = f\"{message_id}_TRANS\"\r\n            \r\n            self.log(f\"Checking for existing transcription with ID: {transcription_id}\")\r\n                \r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                result = conn.execute(\r\n                    text(query),\r\n                    {\"transcription_id\": transcription_id}\r\n                )\r\n                row = result.fetchone()\r\n                \r\n                if row:\r\n                    self.log(f\"Found existing transcription for message {message_id}\")\r\n                    return row[0] if isinstance(row[0], dict) else json.loads(row[0])\r\n                    \r\n                self.log(f\"No existing transcription found for message {message_id}\")\r\n                return None\r\n                \r\n        except Exception as e:\r\n            self.log(f\"Error checking existing transcription: {str(e)}\")\r\n            self.cleanup()  # Ensure cleanup on error\r\n            raise ValueError(f\"Failed to check existing transcription: {str(e)}\") from e\r\n\r\n    def insert_transcription(self, transcription: str, original_data: Dict[str, Any]) -> None:\r\n        \"\"\"Insert transcription into database.\"\"\"\r\n        try:\r\n            # Prepare the message data\r\n            message_data = {\"conversation\": transcription}\r\n            \r\n            # Get original key data and message ID\r\n            original_key = original_data.get(\"key\", {})\r\n            if isinstance(original_key, str):\r\n                original_key = json.loads(original_key)\r\n                \r\n            original_id = original_key.get(\"id\")\r\n            if not original_id:\r\n                raise ValueError(\"No message ID found in original key\")\r\n                \r\n            # Create transcription ID by appending suffix\r\n            transcription_id = f\"{original_id}_TRANS\"\r\n            \r\n            # Create the key object for the transcription matching the ID\r\n            transcription_key = {\r\n                \"id\": transcription_id,\r\n                \"fromMe\": original_key.get(\"fromMe\", False),\r\n                \"remoteJid\": original_key.get(\"remoteJid\", \"\")\r\n            }\r\n            \r\n            query = '''\r\n                INSERT INTO public.\"Message\" (\r\n                    id,\r\n                    \"messageTimestamp\",\r\n                    \"messageType\",\r\n                    message,\r\n                    \"pushName\",\r\n                    key,\r\n                    \"instanceId\",\r\n                    \"contextInfo\",\r\n                    source\r\n                ) VALUES (\r\n                    :id,\r\n                    :timestamp,\r\n                    'audioTranscription',\r\n                    :message,\r\n                    :push_name,\r\n                    :key,\r\n                    :instance_id,\r\n                    :context_info,\r\n                    :source\r\n                )\r\n            '''\r\n            \r\n            params = {\r\n                \"id\": transcription_id,\r\n                \"timestamp\": original_data.get(\"messageTimestamp\"),\r\n                \"message\": json.dumps(message_data),\r\n                \"push_name\": original_data.get(\"pushName\"),\r\n                \"key\": json.dumps(transcription_key),\r\n                \"instance_id\": self.instance_id,\r\n                \"context_info\": json.dumps(original_data.get(\"contextInfo\")),\r\n                \"source\": original_data.get(\"source\", \"android\")  # Use original source or fallback to android\r\n            }\r\n            \r\n            self.log(\"Inserting transcription into database\")\r\n            \r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                conn.execute(text(query), params)\r\n                conn.commit()\r\n                \r\n            self.log(\"Successfully inserted transcription\")\r\n            \r\n        except Exception as e:\r\n            self.log(f\"Error inserting transcription: {str(e)}\")\r\n            self.cleanup()  # Ensure cleanup on error\r\n            raise ValueError(f\"Failed to insert transcription: {str(e)}\") from e\r\n\r\n    def process_single_audio(self, input_data: Dict[str, Any]) -> Data:\r\n        \"\"\"Process a single audio message.\"\"\"\r\n        try:\r\n            # Extract message ID and check for existing transcription\r\n            message_id = self.extract_message_id(input_data.get(\"key\", {}))\r\n            if not message_id:\r\n                return Data(data={\"error\": \"Could not extract message ID from input data\"})\r\n                \r\n            # Check for existing transcription\r\n            existing = self.check_existing_transcription(message_id)\r\n            if existing:\r\n                self.log(\"Returning existing transcription\")\r\n                self._last_api_call = False  # No API call needed\r\n                return Data(data=existing)\r\n\r\n            # Get audio URL\r\n            audio_url = input_data.get(\"parsed_url\")\r\n            if not audio_url:\r\n                return Data(data={\"error\": \"No audio URL found in input data\"})\r\n\r\n            # Add delay if there was a previous API call\r\n            delay_needed = hasattr(self, '_last_api_call') and self._last_api_call and hasattr(self, 'transcription_delay') and self.transcription_delay\r\n            if delay_needed:\r\n                delay_seconds = self.transcription_delay / 1000  # Convert ms to seconds\r\n                self.log(f\"Waiting {delay_seconds} seconds before next transcription request...\")\r\n                time.sleep(delay_seconds)\r\n            \r\n            # Reset API call flag\r\n            self._last_api_call = True\r\n            \r\n            # Ensure server URL format\r\n            server_url = self.server_url.rstrip('/')\r\n            self.log(f\"Using server URL: {server_url}\")\r\n            \r\n            # Build API endpoint URL\r\n            url = f\"{server_url}/transcribe\"\r\n            self.log(f\"Full API endpoint URL: {url}\")\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n            }\r\n            self.log(\"Headers prepared (apikey hidden)\")\r\n\r\n            # Prepare payload\r\n            payload = {\r\n                \"url\": audio_url\r\n            }\r\n            \r\n            # Add optional language if provided\r\n            if hasattr(self, 'language') and self.language:\r\n                payload[\"language\"] = self.language\r\n            \r\n            # Log the request (excluding sensitive data)\r\n            request_info = {\r\n                \"url\": url,\r\n                \"headers\": {\r\n                    \"apikey\": \"***hidden***\"\r\n                },\r\n                \"payload\": payload\r\n            }\r\n            self.log(f\"Making request: {json.dumps(request_info, indent=2)}\")\r\n\r\n            # Make API request\r\n            response = requests.post(\r\n                url, \r\n                headers=headers,\r\n                data=payload\r\n            )\r\n            \r\n            self.log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Check for successful response\r\n            response.raise_for_status()\r\n            \r\n            # Parse response\r\n            data = response.json()\r\n            \r\n            # Extract transcription\r\n            transcription = data.get(\"transcription\", \"\")\r\n            if not transcription:\r\n                return Data(data={\"error\": \"No transcription found in response\"})\r\n            \r\n            self.log(\"Successfully extracted transcription\")\r\n            \r\n            # Insert into database\r\n            self.insert_transcription(transcription, input_data)\r\n            \r\n            # Return transcription as data\r\n            return Data(data={\"conversation\": transcription})\r\n            \r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"API request failed: {str(e)}\"\r\n            self.log(f\"Request error: {error_msg}\")\r\n            return Data(data={\"error\": error_msg})\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Unexpected error: {error_msg}\")\r\n            return Data(data={\"error\": error_msg})\r\n\r\n    def transcribe_audio(self) -> List[Data]:\r\n        \"\"\"\r\n        Transcribe multiple audio files and store in database.\r\n        \"\"\"\r\n        try:\r\n            # Debug logging for input data\r\n            self.log(f\"Input data object: {self.input_data}\")\r\n            self.log(f\"Input data type: {type(self.input_data)}\")\r\n            \r\n            # Initialize results list\r\n            results = []\r\n            \r\n            # Handle input data\r\n            if not self.input_data:\r\n                self.log(\"Error: No input data provided\")\r\n                return [Data(data={\"error\": \"No input data provided\"})]\r\n                \r\n            # Convert single item to list if necessary\r\n            input_list = self.input_data if isinstance(self.input_data, list) else [self.input_data]\r\n            \r\n            # Keep track of last API call\r\n            last_api_call = False\r\n            \r\n            # Process each item\r\n            for input_item in input_list:\r\n\r\n                self.log(f\"Processing input item: {input_item}\")\r\n                \r\n                # Extract data from input item\r\n                if not hasattr(input_item, 'data'):\r\n                    self.log(\"Error: input item has no 'data' attribute\")\r\n                    results.append(Data(data={\"error\": \"Invalid input data format\"}))\r\n                    continue\r\n                    \r\n                input_data = input_item.data\r\n                if not input_data:\r\n                    self.log(\"Error: Input data is empty\")\r\n                    results.append(Data(data={\"error\": \"Input data is empty\"}))\r\n                    continue\r\n                \r\n                # Process the audio and collect result\r\n                result = self.process_single_audio(input_data)\r\n                results.append(result)\r\n            \r\n            return results\r\n            \r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error in batch processing: {str(e)}\"\r\n            self.log(f\"Batch processing error: {error_msg}\")\r\n            self.cleanup()  # Ensure cleanup on error\r\n            return [Data(data={\"error\": error_msg})]","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"connection_string":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"connection_string","value":"postgresql://evolution_user:Duassenha2024@192.168.112.131:5432/evolution_db","display_name":"Connection String","advanced":false,"dynamic":false,"info":"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)","title_case":false,"type":"str","_input_type":"StrInput"},"instance_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":true,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"felipe_evo_instance","display_name":"Instance ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"MessageTextInput"},"language":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"language","value":"","display_name":"Language","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Optional: Language code for transcription","title_case":false,"type":"str","_input_type":"MessageTextInput"},"server_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"server_url","value":"http://192.168.112.131:4040","display_name":"Server URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Transcription server URL (e.g., http://localhost:4040)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"transcription_delay":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"transcription_delay","value":1500,"display_name":"Transcription Delay","advanced":false,"dynamic":false,"info":"Delay in milliseconds between transcription API calls (for rate limiting)","title_case":false,"type":"int","_input_type":"IntInput","load_from_db":false}},"description":"Transcribe multiple audio files from URLs and store results in database","icon":"mic","base_classes":["Data"],"display_name":"Audio Transcriber Iterator","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"transcriptions","display_name":"Transcriptions","method":"transcribe_audio","value":"__UNDEFINED__","cache":true}],"field_order":["transcription_delay","input_data","instance_id","server_url","connection_string","language","api_key"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev22"},"type":"CustomComponent","id":"CustomComponent-88JDQ"},"selected":false,"measured":{"width":320,"height":731},"dragging":false},{"id":"CustomComponent-8IQeG","type":"genericNode","position":{"x":-3506.8472731941656,"y":-1127.2687716050864},"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from typing import Any, Dict, List, Optional\r\nfrom sqlalchemy import create_engine, text\r\nimport json\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    StrInput,\r\n    MessageTextInput,\r\n    IntInput,\r\n    DropdownInput,\r\n    Output\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass AudioMessageQueryComponent(Component):\r\n    display_name = \"Evolution Audio Message Query\"\r\n    description = \"Query audio messages from Evolution database with different filter options\"\r\n    icon = \"mic\"\r\n    name = \"evolution_audio_message_query\"\r\n\r\n    def __init__(self, **data):\r\n        super().__init__(**data)\r\n        self._engine = None\r\n\r\n    def __del__(self):\r\n        \"\"\"Cleanup method to dispose of the engine when component is destroyed.\"\"\"\r\n        self.cleanup()\r\n\r\n    def cleanup(self):\r\n        \"\"\"Cleanup database resources.\"\"\"\r\n        if self._engine:\r\n            self.log(\"Disposing database engine...\")\r\n            self._engine.dispose()\r\n            self._engine = None\r\n\r\n    inputs = [\r\n        StrInput(\r\n            name=\"connection_string\",\r\n            display_name=\"Connection String\",\r\n            info=\"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)\",\r\n            required=True\r\n        ),\r\n        StrInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"message_id\",\r\n            display_name=\"Message ID\",\r\n            info=\"Find specific audio message by ID\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"remote_jid\",\r\n            display_name=\"Remote JID\",\r\n            info=\"Filter by remote JID (e.g., 555199999999@s.whatsapp.net)\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"push_name\",\r\n            display_name=\"Push Name\",\r\n            info=\"Filter by contact name\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"start_time\",\r\n            display_name=\"Start Time\",\r\n            info=\"Start time (YYYY-MM-DD HH:MM:SS)\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"end_time\",\r\n            display_name=\"End Time\", \r\n            info=\"End time (YYYY-MM-DD HH:MM:SS)\",\r\n            required=False\r\n        ),\r\n        DropdownInput(\r\n            name=\"sort_direction\",\r\n            display_name=\"Sort Direction\",\r\n            info=\"Sort direction by messageTimestamp\",\r\n            options=[\"ASC\", \"DESC\"],\r\n            value=\"DESC\",\r\n            required=False\r\n        ),\r\n        IntInput(\r\n            name=\"page_size\",\r\n            display_name=\"Page Size\",\r\n            info=\"Number of records per page\",\r\n            value=100,\r\n            required=True\r\n        ),\r\n        IntInput(\r\n            name=\"page\",\r\n            display_name=\"Page\",\r\n            info=\"Page number (starts at 1)\",\r\n            value=1,\r\n            required=True\r\n        )\r\n    ]\r\n\r\n    outputs = [\r\n        Output(name=\"messages\", display_name=\"Messages\", method=\"execute_query\"),\r\n        Output(name=\"parsed_urls\", display_name=\"Parsed URLs\", method=\"get_parsed_urls\")\r\n    ]\r\n\r\n    def parse_media_url(self, message: Any) -> str:\r\n        \"\"\"Extract and parse media URL from audio message.\"\"\"\r\n        try:\r\n            if isinstance(message, str):\r\n                message = json.loads(message)\r\n                \r\n            if \"mediaUrl\" in message:\r\n                url = message[\"mediaUrl\"]\r\n                if \"?\" in url:\r\n                    return url.split(\"?\")[0]\r\n                return url\r\n                \r\n            return None\r\n            \r\n        except Exception as e:\r\n            self.log(f\"Error parsing media URL: {str(e)}\")\r\n            return None\r\n\r\n    def get_engine(self):\r\n        \"\"\"Get or create SQLAlchemy engine.\"\"\"\r\n        if not self._engine:\r\n            try:\r\n                self._engine = create_engine(\r\n                    self.connection_string,\r\n                    echo=False,\r\n                    pool_size=5,  # Set maximum pool size\r\n                    max_overflow=10,  # Allow up to 10 connections to overflow\r\n                    pool_timeout=30,  # Wait up to 30 seconds for available connection\r\n                    pool_recycle=3600,  # Recycle connections after 1 hour\r\n                    pool_pre_ping=True  # Verify connection is still valid before using\r\n                )\r\n                \r\n                # Test the connection\r\n                with self._engine.connect() as conn:\r\n                    conn.execute(text(\"SELECT 1\"))\r\n                    \r\n            except Exception as e:\r\n                self.log(f\"Failed to create database engine: {str(e)}\")\r\n                self.cleanup()  # Ensure cleanup on error\r\n                raise ValueError(f\"Database connection failed: {str(e)}\") from e\r\n        return self._engine\r\n\r\n    def build_query(self) -> tuple[str, dict]:\r\n        \"\"\"Build the SQL query and parameters.\"\"\"\r\n        try:\r\n            query = '''\r\n                SELECT \r\n                    \"messageTimestamp\", \r\n                    \"messageType\", \r\n                    message, \r\n                    \"pushName\", \r\n                    key,\r\n                    \"contextInfo\"\r\n                FROM public.\"Message\"\r\n                WHERE \"messageType\" = 'audioMessage'\r\n                AND \"instanceId\" = :instance_id\r\n            '''\r\n            params = {\"instance_id\": self.instance_id}\r\n\r\n            # Add message ID filter if specified\r\n            if hasattr(self, 'message_id') and self.message_id:\r\n                query += \" AND key->>'id' = :message_id\"\r\n                params[\"message_id\"] = str(self.message_id).strip()\r\n\r\n            # Add remote JID filter if specified\r\n            if hasattr(self, 'remote_jid') and self.remote_jid:\r\n                query += \" AND key->>'remoteJid' = :remote_jid\"\r\n                params[\"remote_jid\"] = str(self.remote_jid).strip()\r\n\r\n            # Add push name filter if specified\r\n            if hasattr(self, 'push_name') and self.push_name:\r\n                query += ' AND \"pushName\" = :push_name'\r\n                params[\"push_name\"] = str(self.push_name).strip()\r\n\r\n            # Add timestamp range if specified\r\n            if hasattr(self, 'start_time') and self.start_time:\r\n                query += ' AND \"messageTimestamp\" >= (extract(epoch from timestamp :start_time)::bigint)'\r\n                params[\"start_time\"] = str(self.start_time).strip()\r\n            if hasattr(self, 'end_time') and self.end_time:\r\n                query += ' AND \"messageTimestamp\" <= (extract(epoch from timestamp :end_time)::bigint)'\r\n                params[\"end_time\"] = str(self.end_time).strip()\r\n\r\n            # Add ORDER BY\r\n            query += f' ORDER BY \"messageTimestamp\" {self.sort_direction}'\r\n\r\n            # Add pagination\r\n            page = max(1, self.page)\r\n            page_size = max(1, self.page_size)\r\n            offset = (page - 1) * page_size\r\n            query += \" LIMIT :limit OFFSET :offset\"\r\n            params.update({\"limit\": page_size, \"offset\": offset})\r\n\r\n            return query, params\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error building query: {str(e)}\")\r\n            raise ValueError(f\"Failed to build query: {str(e)}\") from e\r\n\r\n    def execute_query(self) -> List[Data]:\r\n        \"\"\"Execute the query and return results with all fields.\"\"\"\r\n        try:\r\n            query, params = self.build_query()\r\n            self.log(f\"Executing query: {query} with params: {params}\")\r\n\r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                # Execute main query\r\n                result = conn.execute(text(query), params)\r\n                rows = [dict(zip(row._fields, row)) for row in result]\r\n\r\n                # Get total count\r\n                count_query = '''\r\n                    SELECT COUNT(*) \r\n                    FROM public.\"Message\"\r\n                    WHERE \"messageType\" = 'audioMessage'\r\n                    AND \"instanceId\" = :instance_id\r\n                '''\r\n                count_params = {\"instance_id\": self.instance_id}\r\n                \r\n                # Add message ID filter to count query\r\n                if hasattr(self, 'message_id') and self.message_id:\r\n                    count_query += \" AND key->>'id' = :message_id\"\r\n                    count_params[\"message_id\"] = str(self.message_id).strip()\r\n\r\n                # Add remote JID filter to count query\r\n                if hasattr(self, 'remote_jid') and self.remote_jid:\r\n                    count_query += \" AND key->>'remoteJid' = :remote_jid\"\r\n                    count_params[\"remote_jid\"] = str(self.remote_jid).strip()\r\n\r\n                # Add push name filter to count query\r\n                if hasattr(self, 'push_name') and self.push_name:\r\n                    count_query += ' AND \"pushName\" = :push_name'\r\n                    count_params[\"push_name\"] = str(self.push_name).strip()\r\n\r\n                # Add timestamp range to count query\r\n                if hasattr(self, 'start_time') and self.start_time:\r\n                    count_query += ' AND \"messageTimestamp\" >= (extract(epoch from timestamp :start_time)::bigint)'\r\n                    count_params[\"start_time\"] = str(self.start_time).strip()\r\n                if hasattr(self, 'end_time') and self.end_time:\r\n                    count_query += ' AND \"messageTimestamp\" <= (extract(epoch from timestamp :end_time)::bigint)'\r\n                    count_params[\"end_time\"] = str(self.end_time).strip()\r\n\r\n                count_result = conn.execute(text(count_query), count_params)\r\n                total_count = count_result.scalar()\r\n\r\n            # Convert rows to Data objects with pagination info\r\n            return [\r\n                Data(\r\n                    data={\r\n                        \"messageTimestamp\": row[\"messageTimestamp\"],\r\n                        \"key\": row[\"key\"],\r\n                        \"pushName\": row[\"pushName\"],\r\n                        \"message\": row[\"message\"],\r\n                        \"contextInfo\": row[\"contextInfo\"],\r\n                        \"parsed_url\": self.parse_media_url(row[\"message\"]),\r\n                        \"__meta__\": {\r\n                            \"total_records\": total_count,\r\n                            \"page\": self.page,\r\n                            \"page_size\": self.page_size,\r\n                            \"total_pages\": -(-total_count // self.page_size)\r\n                        }\r\n                    }\r\n                )\r\n                for row in rows\r\n            ]\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error executing query: {str(e)}\")\r\n            self.cleanup()  # Ensure cleanup on error\r\n            raise ValueError(f\"Query execution failed: {str(e)}\") from e\r\n\r\n    def get_parsed_urls(self) -> List[Data]:\r\n        \"\"\"Return just the parsed URLs from the audio messages.\"\"\"\r\n        try:\r\n            query, params = self.build_query()\r\n            \r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                result = conn.execute(text(query), params)\r\n                rows = [dict(zip(row._fields, row)) for row in result]\r\n\r\n            # Return just the parsed URLs\r\n            return [\r\n                Data(\r\n                    data={\r\n                        \"url\": self.parse_media_url(row[\"message\"])\r\n                    }\r\n                )\r\n                for row in rows\r\n                if self.parse_media_url(row[\"message\"]) is not None\r\n            ]\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error getting parsed URLs: {str(e)}\")\r\n            self.cleanup()  # Ensure cleanup on error\r\n            raise ValueError(f\"Failed to get parsed URLs: {str(e)}\") from e","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"connection_string":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"connection_string","value":"postgresql://evolution_user:Duassenha2024@192.168.112.131:5432/evolution_db","display_name":"Connection String","advanced":false,"dynamic":false,"info":"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)","title_case":false,"type":"str","_input_type":"StrInput"},"end_time":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"end_time","value":"","display_name":"End Time","advanced":false,"input_types":["Message"],"dynamic":false,"info":"End time (YYYY-MM-DD HH:MM:SS)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"instance_id":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":true,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"felipe_evo_instance","display_name":"Instance ID","advanced":false,"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"StrInput"},"message_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"message_id","value":"","display_name":"Message ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Find specific audio message by ID","title_case":false,"type":"str","_input_type":"MessageTextInput"},"page":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":true,"placeholder":"","show":true,"name":"page","value":1,"display_name":"Page","advanced":false,"dynamic":false,"info":"Page number (starts at 1)","title_case":false,"type":"int","_input_type":"IntInput"},"page_size":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":true,"placeholder":"","show":true,"name":"page_size","value":100,"display_name":"Page Size","advanced":false,"dynamic":false,"info":"Number of records per page","title_case":false,"type":"int","_input_type":"IntInput"},"push_name":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"push_name","value":"","display_name":"Push Name","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Filter by contact name","title_case":false,"type":"str","_input_type":"MessageTextInput"},"remote_jid":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"remote_jid","value":"","display_name":"Remote JID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Filter by remote JID (e.g., 555199999999@s.whatsapp.net)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"sort_direction":{"tool_mode":false,"trace_as_metadata":true,"options":["ASC","DESC"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"sort_direction","value":"DESC","display_name":"Sort Direction","advanced":false,"dynamic":false,"info":"Sort direction by messageTimestamp","title_case":false,"type":"str","_input_type":"DropdownInput"},"start_time":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"start_time","value":"","display_name":"Start Time","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Start time (YYYY-MM-DD HH:MM:SS)","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Query audio messages from Evolution database with different filter options","icon":"mic","base_classes":["Data"],"display_name":"Evolution Audio Message Query","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"messages","display_name":"Messages","method":"execute_query","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"parsed_urls","display_name":"Parsed URLs","method":"get_parsed_urls","value":"__UNDEFINED__","cache":true}],"field_order":["connection_string","instance_id","message_id","remote_jid","push_name","start_time","end_time","sort_direction","page_size","page"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev22"},"type":"CustomComponent","id":"CustomComponent-8IQeG"},"selected":false,"measured":{"width":320,"height":1075},"dragging":false},{"id":"CurrentDate-BKLgt","type":"genericNode","position":{"x":-4004.651681146568,"y":-819.1368946144758},"data":{"node":{"template":{"_type":"Component","webhook":{"tool_mode":true,"trace_as_metadata":true,"list":false,"trace_as_input":true,"required":false,"placeholder":"","show":true,"name":"webhook","value":"","display_name":"Webhook Data","advanced":false,"input_types":["Data"],"dynamic":false,"info":"Data input used to trigger component execution. The data itself is not used.","title_case":false,"type":"other","_input_type":"DataInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from datetime import datetime, timedelta\r\nfrom zoneinfo import ZoneInfo\r\nfrom langflow.custom import Component\r\nfrom langflow.io import DropdownInput, Output, DataInput\r\nfrom langflow.schema.message import Message\r\n\r\nclass TimeIntervalComponent(Component):\r\n    display_name = \"Time Interval\"\r\n    description = \"Returns the start and end dates for different time intervals in the selected timezone.\"\r\n    icon = \"clock\"\r\n    name = \"TimeInterval\"\r\n    \r\n    inputs = [\r\n        DropdownInput(\r\n            name=\"timezone\",\r\n            display_name=\"Timezone\",\r\n            options=[\r\n                \"UTC\",\r\n                \"US/Eastern\", \r\n                \"US/Central\", \r\n                \"US/Mountain\",\r\n                \"US/Pacific\",\r\n                \"Europe/London\",\r\n                \"Europe/Paris\",\r\n                \"Europe/Berlin\",\r\n                \"Europe/Moscow\",\r\n                \"Asia/Tokyo\",\r\n                \"Asia/Shanghai\",\r\n                \"Asia/Singapore\",\r\n                \"Asia/Dubai\",\r\n                \"Australia/Sydney\",\r\n                \"Australia/Melbourne\",\r\n                \"Pacific/Auckland\",\r\n                \"America/Sao_Paulo\",\r\n                \"America/Mexico_City\",\r\n                \"America/Toronto\",\r\n                \"America/Vancouver\",\r\n                \"Africa/Cairo\",\r\n                \"Africa/Johannesburg\",\r\n                \"Atlantic/Reykjavik\",\r\n                \"Indian/Maldives\",\r\n                \"America/Bogota\",\r\n                \"America/Lima\",\r\n                \"America/Santiago\",\r\n                \"America/Buenos_Aires\",\r\n                \"America/Caracas\",\r\n                \"America/La_Paz\",\r\n                \"America/Montevideo\",\r\n                \"America/Asuncion\",\r\n                \"America/Cuiaba\",\r\n            ],\r\n            value=\"UTC\",\r\n            info=\"Select the timezone for the time interval calculation.\",\r\n            tool_mode=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"interval\",\r\n            display_name=\"Time Interval\",\r\n            options=[\r\n                \"1 hour\",\r\n                \"12 hours\",\r\n                \"1 day\",\r\n                \"7 days\",\r\n                \"15 days\",\r\n                \"1 month\"\r\n            ],\r\n            value=\"1 day\",\r\n            info=\"Select the time interval to calculate.\",\r\n            tool_mode=True,\r\n        ),\r\n        DataInput(\r\n            name=\"webhook\",\r\n            display_name=\"Webhook Data\",\r\n            info=\"Data input used to trigger component execution. The data itself is not used.\",\r\n            tool_mode=True,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            display_name=\"Start Time\", \r\n            name=\"start_time\", \r\n            method=\"get_start_time\"\r\n        ),\r\n        Output(\r\n            display_name=\"End Time\", \r\n            name=\"end_time\", \r\n            method=\"get_end_time\"\r\n        ),\r\n    ]\r\n\r\n    def calculate_times(self):\r\n        \"\"\"Helper method to calculate interval times.\"\"\"\r\n        # Get current time in specified timezone\r\n        tz = ZoneInfo(self.timezone)\r\n        end_time = datetime.now(tz)\r\n        \r\n        # Calculate start time based on selected interval\r\n        interval_map = {\r\n            \"1 hour\": timedelta(hours=1),\r\n            \"12 hours\": timedelta(hours=12),\r\n            \"1 day\": timedelta(days=1),\r\n            \"7 days\": timedelta(days=7),\r\n            \"15 days\": timedelta(days=15),\r\n            \"1 month\": timedelta(days=30)  # Approximating month as 30 days\r\n        }\r\n        \r\n        interval = interval_map[self.interval]\r\n        start_time = end_time - interval\r\n        \r\n        # Format with full timestamp\r\n        start_formatted = start_time.strftime(\"%Y-%m-%d %H:%M:%S\")\r\n        end_formatted = end_time.strftime(\"%Y-%m-%d %H:%M:%S\")\r\n        \r\n        return start_formatted, end_formatted\r\n\r\n    def get_start_time(self) -> Message:\r\n        \"\"\"Return the start time for the selected interval.\"\"\"\r\n        try:\r\n            start_time, _ = self.calculate_times()\r\n            return Message(text=start_time)\r\n        except Exception as e:\r\n            return Message(text=f\"Error calculating start time: {str(e)}\")\r\n\r\n    def get_end_time(self) -> Message:\r\n        \"\"\"Return the end time for the selected interval.\"\"\"\r\n        try:\r\n            _, end_time = self.calculate_times()\r\n            return Message(text=end_time)\r\n        except Exception as e:\r\n            return Message(text=f\"Error calculating end time: {str(e)}\")","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"interval":{"tool_mode":true,"trace_as_metadata":true,"options":["1 hour","12 hours","1 day","7 days","15 days","1 month"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"interval","value":"1 day","display_name":"Time Interval","advanced":false,"dynamic":false,"info":"Select the time interval to calculate.","title_case":false,"type":"str","_input_type":"DropdownInput"},"timezone":{"tool_mode":true,"trace_as_metadata":true,"options":["UTC","US/Eastern","US/Central","US/Mountain","US/Pacific","Europe/London","Europe/Paris","Europe/Berlin","Europe/Moscow","Asia/Tokyo","Asia/Shanghai","Asia/Singapore","Asia/Dubai","Australia/Sydney","Australia/Melbourne","Pacific/Auckland","America/Sao_Paulo","America/Mexico_City","America/Toronto","America/Vancouver","Africa/Cairo","Africa/Johannesburg","Atlantic/Reykjavik","Indian/Maldives","America/Bogota","America/Lima","America/Santiago","America/Buenos_Aires","America/Caracas","America/La_Paz","America/Montevideo","America/Asuncion","America/Cuiaba"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"timezone","value":"America/Sao_Paulo","display_name":"Timezone","advanced":false,"dynamic":false,"info":"Select the timezone for the time interval calculation.","title_case":false,"type":"str","_input_type":"DropdownInput","load_from_db":false}},"description":"Returns the start and end dates for different time intervals in the selected timezone.","icon":"clock","base_classes":["Message"],"display_name":"Time Interval","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"start_time","display_name":"Start Time","method":"get_start_time","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"end_time","display_name":"End Time","method":"get_end_time","value":"__UNDEFINED__","cache":true}],"field_order":["timezone","interval","webhook"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev22"},"type":"CurrentDate","id":"CurrentDate-BKLgt"},"selected":false,"measured":{"width":320,"height":435},"dragging":false},{"id":"Webhook-tjK8O","type":"genericNode","position":{"x":-4464.25631728436,"y":-716.4178130009489},"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\n\nfrom langflow.custom import Component\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema import Data\n\n\nclass WebhookComponent(Component):\n    display_name = \"Webhook\"\n    description = \"Defines a webhook input for the flow.\"\n    name = \"Webhook\"\n    icon = \"webhook\"\n\n    inputs = [\n        MultilineInput(\n            name=\"data\",\n            display_name=\"Payload\",\n            info=\"Receives a payload from external systems via HTTP POST.\",\n        )\n    ]\n    outputs = [\n        Output(display_name=\"Data\", name=\"output_data\", method=\"build_data\"),\n    ]\n\n    def build_data(self) -> Data:\n        message: str | Data = \"\"\n        if not self.data:\n            self.status = \"No data provided.\"\n            return Data(data={})\n        try:\n            body = json.loads(self.data or \"{}\")\n        except json.JSONDecodeError:\n            body = {\"payload\": self.data}\n            message = f\"Invalid JSON payload. Please check the format.\\n\\n{self.data}\"\n        data = Data(data=body)\n        if not message:\n            message = data\n        self.status = message\n        return data\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"data":{"tool_mode":false,"trace_as_input":true,"multiline":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"data","value":"","display_name":"Payload","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Receives a payload from external systems via HTTP POST.","title_case":false,"type":"str","_input_type":"MultilineInput"}},"description":"Defines a webhook input for the flow.","icon":"webhook","base_classes":["Data"],"display_name":"Webhook","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"output_data","display_name":"Data","method":"build_data","value":"__UNDEFINED__","cache":true}],"field_order":["data"],"beta":false,"legacy":false,"edited":false,"metadata":{},"tool_mode":false,"category":"data","key":"Webhook","score":0.0004187935651179184,"lf_version":"1.1.1.dev22"},"type":"Webhook","id":"Webhook-tjK8O"},"selected":false,"measured":{"width":320,"height":233},"dragging":false},{"id":"CustomComponent-QYtaC","type":"genericNode","position":{"x":-2115.9487371860782,"y":-625.6014384750142},"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from typing import List\r\nfrom sqlalchemy import create_engine, text\r\nimport json\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import MultilineInput, StrInput, Output\r\nfrom langflow.schema import Data\r\n\r\nclass PostgreSQLQueryComponent(Component):\r\n    display_name = \"PostgreSQL Query\"\r\n    description = \"Execute arbitrary SQL queries against a PostgreSQL database\"\r\n    icon = \"database\"\r\n    name = \"postgresql_query\"\r\n\r\n    def __init__(self, **data):\r\n        super().__init__(**data)\r\n        self._engine = None\r\n\r\n    inputs = [\r\n        MultilineInput(\r\n            name=\"query\",\r\n            display_name=\"SQL Query\",\r\n            info=\"The SQL query to execute\",\r\n            required=True,\r\n            placeholder=\"Enter your SQL query here\"\r\n        ),\r\n        StrInput(\r\n            name=\"connection_string\",\r\n            display_name=\"Connection String\",\r\n            info=\"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)\",\r\n            required=True,\r\n        )\r\n    ]\r\n\r\n    outputs = [\r\n        Output(name=\"results\", display_name=\"Query Results\", method=\"execute_query\")\r\n    ]\r\n\r\n    def get_engine(self):\r\n        \"\"\"Get or create SQLAlchemy engine.\"\"\"\r\n        if not self._engine:\r\n            try:\r\n                self._engine = create_engine(\r\n                    self.connection_string,\r\n                    echo=False\r\n                )\r\n                \r\n                # Test the connection\r\n                with self._engine.connect() as conn:\r\n                    conn.execute(text(\"SELECT 1\"))\r\n                    \r\n            except Exception as e:\r\n                self.log(f\"Failed to create database engine: {str(e)}\")\r\n                raise ValueError(f\"Database connection failed: {str(e)}\") from e\r\n        return self._engine\r\n\r\n    def execute_query(self) -> List[Data]:\r\n        \"\"\"Execute the SQL query and return results.\"\"\"\r\n        try:\r\n            self.log(f\"Executing query: {self.query}\")\r\n            \r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                # Execute query\r\n                result = conn.execute(text(self.query))\r\n                \r\n                # Convert results to list of dictionaries\r\n                rows = [dict(zip(row._fields, row)) for row in result]\r\n                \r\n                # Return results as list of Data objects\r\n                return [\r\n                    Data(\r\n                        data={\r\n                            **row,\r\n                            \"__meta__\": {\r\n                                \"row_number\": i + 1,\r\n                                \"total_rows\": len(rows)\r\n                            }\r\n                        }\r\n                    )\r\n                    for i, row in enumerate(rows)\r\n                ]\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error executing query: {str(e)}\")\r\n            # Return error as Data object\r\n            return [Data(\r\n                data={\r\n                    \"error\": str(e),\r\n                    \"__meta__\": {\r\n                        \"status\": \"error\",\r\n                        \"message\": f\"Query execution failed: {str(e)}\"\r\n                    }\r\n                }\r\n            )]","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"connection_string":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"connection_string","value":"postgresql://evolution_user:Duassenha2024@192.168.112.131:5432/evolution_db","display_name":"Connection String","advanced":false,"dynamic":false,"info":"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)","title_case":false,"type":"str","_input_type":"StrInput"},"query":{"tool_mode":false,"trace_as_input":true,"multiline":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"Enter your SQL query here","show":true,"name":"query","value":"SELECT * FROM pg_stat_activity;","display_name":"SQL Query","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The SQL query to execute","title_case":false,"type":"str","_input_type":"MultilineInput"}},"description":"Execute arbitrary SQL queries against a PostgreSQL database","icon":"database","base_classes":["Data"],"display_name":"PostgreSQL Query","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"results","display_name":"Query Results","method":"execute_query","value":"__UNDEFINED__","cache":true}],"field_order":["query","connection_string"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev22","official":false},"type":"CustomComponent","id":"CustomComponent-QYtaC"},"selected":false,"measured":{"width":320,"height":339},"dragging":false},{"id":"ParseData-Vfknv","type":"genericNode","position":{"x":-2565.0000000000005,"y":-685.8301595406849},"data":{"node":{"template":{"_type":"Component","data":{"tool_mode":false,"trace_as_metadata":true,"list":true,"trace_as_input":true,"required":false,"placeholder":"","show":true,"name":"data","value":"","display_name":"Data","advanced":false,"input_types":["Data"],"dynamic":false,"info":"The data to convert to text.","title_case":false,"type":"other","_input_type":"DataInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from typing import Optional, Tuple, List\r\nfrom langflow.custom import Component\r\nfrom langflow.helpers.data import data_to_text, data_to_text_list\r\nfrom langflow.io import DataInput, MultilineInput, Output, StrInput\r\nfrom langflow.schema import Data\r\nfrom langflow.schema.message import Message\r\n\r\nclass ParseDataComponent(Component):\r\n    display_name = \"Parse Data\"\r\n    description = \"Convert Data into plain text following a specified template.\"\r\n    icon = \"braces\"\r\n    name = \"ParseData\"\r\n\r\n    inputs = [\r\n        DataInput(\r\n            name=\"data\",\r\n            display_name=\"Data\",\r\n            info=\"The data to convert to text.\",\r\n            is_list=True,\r\n            required=False,\r\n        ),\r\n        MultilineInput(\r\n            name=\"template\",\r\n            display_name=\"Template\",\r\n            info=\"The template to use for formatting the data. \"\r\n            \"It can contain the keys {text}, {data} or any other key in the Data.\",\r\n            value=\"{text}\",\r\n            required=False,\r\n        ),\r\n        StrInput(\r\n            name=\"sep\",\r\n            display_name=\"Separator\",\r\n            advanced=True,\r\n            value=\"\\n\",\r\n            required=False,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            display_name=\"Text\",\r\n            name=\"text\",\r\n            info=\"Data as a single Message, with each input Data separated by Separator\",\r\n            method=\"parse_data\",\r\n        ),\r\n        Output(\r\n            display_name=\"Data List\",\r\n            name=\"data_list\",\r\n            info=\"Data as a list of new Data, each having `text` formatted by Template\",\r\n            method=\"parse_data_as_list\",\r\n        ),\r\n    ]\r\n\r\n    def _clean_args(self) -> Tuple[List[Data], str, str]:\r\n        \"\"\"Clean and validate input arguments with safe defaults.\"\"\"\r\n        try:\r\n            # Handle data input\r\n            data = getattr(self, 'data', None)\r\n            if data is None:\r\n                data = []\r\n            elif not isinstance(data, list):\r\n                data = [data]\r\n\r\n            # Handle template input\r\n            template = getattr(self, 'template', '{text}') or '{text}'\r\n\r\n            # Handle separator input\r\n            sep = getattr(self, 'sep', '\\n') or '\\n'\r\n\r\n            return data, template, sep\r\n        except Exception as e:\r\n            self.log(f\"Error in _clean_args: {str(e)}\")\r\n            return [], '{text}', '\\n'\r\n\r\n    def parse_data(self) -> Message:\r\n        \"\"\"Parse data into a single message.\"\"\"\r\n        try:\r\n            data, template, sep = self._clean_args()\r\n            if not data:\r\n                result_string = \"\"\r\n            else:\r\n                result_string = data_to_text(template, data, sep)\r\n            self.status = result_string\r\n            return Message(text=result_string)\r\n        except Exception as e:\r\n            self.log(f\"Error in parse_data: {str(e)}\")\r\n            return Message(text=\"\")\r\n\r\n    def parse_data_as_list(self) -> List[Data]:\r\n        \"\"\"Parse data into a list of Data objects.\"\"\"\r\n        try:\r\n            data, template, _ = self._clean_args()\r\n            if not data:\r\n                return []\r\n            \r\n            text_list, data_list = data_to_text_list(template, data)\r\n            for item, text in zip(data_list, text_list, strict=True):\r\n                item.set_text(text)\r\n            self.status = data_list\r\n            return data_list\r\n        except Exception as e:\r\n            self.log(f\"Error in parse_data_as_list: {str(e)}\")\r\n            return []","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"sep":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"sep","value":"\n","display_name":"Separator","advanced":true,"dynamic":false,"info":"","title_case":false,"type":"str","_input_type":"StrInput"},"template":{"tool_mode":false,"trace_as_input":true,"multiline":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"template","value":"SELECT pg_terminate_backend(pid) FROM pg_stat_activity  WHERE datname = 'evolution_db'   AND state = 'idle'   AND pid <> pg_backend_pid();","display_name":"Template","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The template to use for formatting the data. It can contain the keys {text}, {data} or any other key in the Data.","title_case":false,"type":"str","_input_type":"MultilineInput"}},"description":"Convert Data into plain text following a specified template.","icon":"braces","base_classes":["Data","Message"],"display_name":"Clean SQL","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"text","display_name":"Text","method":"parse_data","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"data_list","display_name":"Data List","method":"parse_data_as_list","value":"__UNDEFINED__","cache":true}],"field_order":["data","template","sep"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev22","official":false},"type":"ParseData","id":"ParseData-Vfknv"},"selected":false,"measured":{"width":320,"height":349},"dragging":false}],"edges":[{"source":"CurrentDate-BKLgt","sourceHandle":"{œdataTypeœ:œCurrentDateœ,œidœ:œCurrentDate-BKLgtœ,œnameœ:œstart_timeœ,œoutput_typesœ:[œMessageœ]}","target":"CustomComponent-8IQeG","targetHandle":"{œfieldNameœ:œstart_timeœ,œidœ:œCustomComponent-8IQeGœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"start_time","id":"CustomComponent-8IQeG","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"CurrentDate","id":"CurrentDate-BKLgt","name":"start_time","output_types":["Message"]}},"id":"reactflow__edge-CurrentDate-BKLgt{œdataTypeœ:œCurrentDateœ,œidœ:œCurrentDate-BKLgtœ,œnameœ:œstart_timeœ,œoutput_typesœ:[œMessageœ]}-CustomComponent-8IQeG{œfieldNameœ:œstart_timeœ,œidœ:œCustomComponent-8IQeGœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","animated":false,"className":"","selected":false},{"source":"CurrentDate-BKLgt","sourceHandle":"{œdataTypeœ:œCurrentDateœ,œidœ:œCurrentDate-BKLgtœ,œnameœ:œend_timeœ,œoutput_typesœ:[œMessageœ]}","target":"CustomComponent-8IQeG","targetHandle":"{œfieldNameœ:œend_timeœ,œidœ:œCustomComponent-8IQeGœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"end_time","id":"CustomComponent-8IQeG","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"CurrentDate","id":"CurrentDate-BKLgt","name":"end_time","output_types":["Message"]}},"id":"reactflow__edge-CurrentDate-BKLgt{œdataTypeœ:œCurrentDateœ,œidœ:œCurrentDate-BKLgtœ,œnameœ:œend_timeœ,œoutput_typesœ:[œMessageœ]}-CustomComponent-8IQeG{œfieldNameœ:œend_timeœ,œidœ:œCustomComponent-8IQeGœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","animated":false,"className":"","selected":false},{"source":"Webhook-tjK8O","sourceHandle":"{œdataTypeœ:œWebhookœ,œidœ:œWebhook-tjK8Oœ,œnameœ:œoutput_dataœ,œoutput_typesœ:[œDataœ]}","target":"CurrentDate-BKLgt","targetHandle":"{œfieldNameœ:œwebhookœ,œidœ:œCurrentDate-BKLgtœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","data":{"targetHandle":{"fieldName":"webhook","id":"CurrentDate-BKLgt","inputTypes":["Data"],"type":"other"},"sourceHandle":{"dataType":"Webhook","id":"Webhook-tjK8O","name":"output_data","output_types":["Data"]}},"id":"reactflow__edge-Webhook-tjK8O{œdataTypeœ:œWebhookœ,œidœ:œWebhook-tjK8Oœ,œnameœ:œoutput_dataœ,œoutput_typesœ:[œDataœ]}-CurrentDate-BKLgt{œfieldNameœ:œwebhookœ,œidœ:œCurrentDate-BKLgtœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","className":"","selected":false,"animated":false},{"source":"CustomComponent-8IQeG","sourceHandle":"{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-8IQeGœ,œnameœ:œmessagesœ,œoutput_typesœ:[œDataœ]}","target":"CustomComponent-88JDQ","targetHandle":"{œfieldNameœ:œinput_dataœ,œidœ:œCustomComponent-88JDQœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","data":{"targetHandle":{"fieldName":"input_data","id":"CustomComponent-88JDQ","inputTypes":["Data"],"type":"other"},"sourceHandle":{"dataType":"CustomComponent","id":"CustomComponent-8IQeG","name":"messages","output_types":["Data"]}},"id":"reactflow__edge-CustomComponent-8IQeG{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-8IQeGœ,œnameœ:œmessagesœ,œoutput_typesœ:[œDataœ]}-CustomComponent-88JDQ{œfieldNameœ:œinput_dataœ,œidœ:œCustomComponent-88JDQœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","animated":false,"className":"","selected":false},{"source":"CustomComponent-88JDQ","sourceHandle":"{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-88JDQœ,œnameœ:œtranscriptionsœ,œoutput_typesœ:[œDataœ]}","target":"ParseData-Vfknv","targetHandle":"{œfieldNameœ:œdataœ,œidœ:œParseData-Vfknvœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","data":{"targetHandle":{"fieldName":"data","id":"ParseData-Vfknv","inputTypes":["Data"],"type":"other"},"sourceHandle":{"dataType":"CustomComponent","id":"CustomComponent-88JDQ","name":"transcriptions","output_types":["Data"]}},"id":"reactflow__edge-CustomComponent-88JDQ{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-88JDQœ,œnameœ:œtranscriptionsœ,œoutput_typesœ:[œDataœ]}-ParseData-Vfknv{œfieldNameœ:œdataœ,œidœ:œParseData-Vfknvœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","animated":false,"className":"","selected":false},{"source":"ParseData-Vfknv","sourceHandle":"{œdataTypeœ:œParseDataœ,œidœ:œParseData-Vfknvœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}","target":"CustomComponent-QYtaC","targetHandle":"{œfieldNameœ:œqueryœ,œidœ:œCustomComponent-QYtaCœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"query","id":"CustomComponent-QYtaC","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"ParseData","id":"ParseData-Vfknv","name":"text","output_types":["Message"]}},"id":"reactflow__edge-ParseData-Vfknv{œdataTypeœ:œParseDataœ,œidœ:œParseData-Vfknvœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-CustomComponent-QYtaC{œfieldNameœ:œqueryœ,œidœ:œCustomComponent-QYtaCœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","className":"","animated":false,"selected":false}],"viewport":{"x":3202.649746819307,"y":873.3838684905285,"zoom":0.7372712030542257}},"is_component":false,"updated_at":"2025-01-06T22:54:51+00:00","webhook":true,"endpoint_name":null,"tags":null,"locked":null,"id":"0f7b1273-65d1-43d6-af9b-87d5eaec0a3b","user_id":"556fed76-1562-4baf-8a2e-ef9be2d194e4","folder_id":"22c5349e-60ef-45a2-a8ec-0debcd24f6dd"},{"name":"Evolution Chat Digest","description":"Generate daily digests of WhatsApp conversations for a given time period","icon":null,"icon_bg_color":null,"gradient":null,"data":{"edges":[],"nodes":[{"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from typing import List\r\nfrom sqlalchemy import create_engine, text\r\nfrom datetime import datetime\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    StrInput,\r\n    MessageTextInput,\r\n    Output,\r\n    BoolInput\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass ChatDigestComponent(Component):\r\n    display_name = \"Evolution Chat Digest\"\r\n    description = \"Generate daily digests of WhatsApp conversations for a given time period\"\r\n    icon = \"message-square\"\r\n    name = \"evolution_chat_digest\"\r\n\r\n    def __init__(self, **data):\r\n        super().__init__(**data)\r\n        self._engine = None\r\n\r\n    inputs = [\r\n        StrInput(\r\n            name=\"connection_string\",\r\n            display_name=\"Connection String\",\r\n            info=\"PostgreSQL connection string\",\r\n            required=True\r\n        ),\r\n        StrInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"start_time\",\r\n            display_name=\"Start Time\",\r\n            info=\"Start time (YYYY-MM-DD HH:MM:SS)\",\r\n            required=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"end_time\",\r\n            display_name=\"End Time\", \r\n            info=\"End time (YYYY-MM-DD HH:MM:SS)\",\r\n            required=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"remote_jid\",\r\n            display_name=\"Remote JID Filter\",\r\n            info=\"Filter by specific WhatsApp ID (optional)\",\r\n            required=False\r\n        ),\r\n        BoolInput(\r\n            name=\"include_groups\",\r\n            display_name=\"Include Group Chats\",\r\n            info=\"Include group conversations in the output\",\r\n            value=True\r\n        )\r\n    ]\r\n\r\n    outputs = [\r\n        Output(name=\"chat_digests\", display_name=\"Chat Digests\", method=\"generate_digests\"),\r\n    ]\r\n\r\n    def get_engine(self):\r\n        \"\"\"Get or create SQLAlchemy engine.\"\"\"\r\n        if not self._engine:\r\n            try:\r\n                self._engine = create_engine(self.connection_string, echo=False)\r\n            except Exception as e:\r\n                self.log(f\"Database connection error: {str(e)}\")\r\n                raise\r\n        return self._engine\r\n\r\n    def format_timestamp(self, timestamp: int) -> str:\r\n        \"\"\"Format Unix timestamp to readable date/time.\"\"\"\r\n        try:\r\n            dt = datetime.fromtimestamp(timestamp)\r\n            return dt.strftime(\"%m/%d, %H:%M\")\r\n        except Exception as e:\r\n            self.log(f\"Error formatting timestamp: {str(e)}\")\r\n            return \"\"\r\n\r\n    def generate_digests(self) -> List[Data]:\r\n        \"\"\"Generate chat digests for each conversation.\"\"\"\r\n        try:\r\n            self.log(\"Starting digest generation...\")\r\n            \r\n            # Build query with conditional filters\r\n            query = '''\r\n                SELECT \r\n                    \"messageTimestamp\",\r\n                    message,\r\n                    \"pushName\",\r\n                    key,\r\n                    (key->>'fromMe')::boolean as from_me\r\n                FROM public.\"Message\"\r\n                WHERE \"messageType\" = 'conversation'\r\n                AND \"instanceId\" = :instance_id\r\n                AND \"messageTimestamp\" >= (extract(epoch from timestamp :start_time)::bigint)\r\n                AND \"messageTimestamp\" <= (extract(epoch from timestamp :end_time)::bigint)\r\n            '''\r\n            \r\n            # Build parameters\r\n            params = {\r\n                \"instance_id\": self.instance_id,\r\n                \"start_time\": self.start_time,\r\n                \"end_time\": self.end_time\r\n            }\r\n\r\n            # Add remoteJid filter if provided\r\n            if hasattr(self, 'remote_jid') and self.remote_jid:\r\n                self.log(f\"Adding remote_jid filter: {self.remote_jid}\")\r\n                query += \" AND (key->>'remoteJid') = :remote_jid\"\r\n                params[\"remote_jid\"] = self.remote_jid.strip()\r\n\r\n            # Add group filter if not including groups\r\n            if not self.include_groups:\r\n                self.log(\"Excluding group chats\")\r\n                query += \" AND (key->>'remoteJid') LIKE '%@s.whatsapp.net'\"\r\n\r\n            # Add ordering\r\n            query += ' ORDER BY key->>\\'remoteJid\\', \"messageTimestamp\"'\r\n\r\n            self.log(f\"Query parameters: {params}\")\r\n            engine = self.get_engine()\r\n            conversations = {}\r\n            \r\n            with engine.connect() as conn:\r\n                self.log(\"Executing query...\")\r\n                result = conn.execute(text(query), params)\r\n                rows = [dict(zip(row._fields, row)) for row in result]\r\n                self.log(f\"Retrieved {len(rows)} messages\")\r\n\r\n                for row in rows:\r\n                    # Extract key info (already a dict from PostgreSQL)\r\n                    key = row[\"key\"]\r\n                    remote_jid = key.get(\"remoteJid\", \"\")\r\n                    if not remote_jid:\r\n                        self.log(\"No remoteJid found, skipping message\")\r\n                        continue\r\n\r\n                    # Initialize conversation if needed\r\n                    if remote_jid not in conversations:\r\n                        is_group = remote_jid.endswith(\"@g.us\")\r\n                        conversations[remote_jid] = {\r\n                            \"messages\": [],\r\n                            \"contact_name\": row[\"pushName\"] if not row[\"from_me\"] else None,\r\n                            \"is_group\": is_group,\r\n                            \"participants\": set()\r\n                        }\r\n\r\n                    # For group chats, track participants\r\n                    if conversations[remote_jid][\"is_group\"] and \"participant\" in key:\r\n                        conversations[remote_jid][\"participants\"].add(key[\"participant\"])\r\n\r\n                    # Update contact name if needed (only for individual chats)\r\n                    if not conversations[remote_jid][\"is_group\"] and not row[\"from_me\"]:\r\n                        conversations[remote_jid][\"contact_name\"] = row[\"pushName\"]\r\n                    \r\n                    try:\r\n                        # Format timestamp\r\n                        timestamp = self.format_timestamp(row[\"messageTimestamp\"])\r\n                        if not timestamp:\r\n                            self.log(f\"Invalid timestamp: {row['messageTimestamp']}\")\r\n                            continue\r\n\r\n                        # Get sender name\r\n                        if conversations[remote_jid][\"is_group\"]:\r\n                            name = row[\"pushName\"] or \"Unknown\"\r\n                        else:\r\n                            name = \"You\" if row[\"from_me\"] else (row[\"pushName\"] or \"Unknown\")\r\n\r\n                        # Extract message text (already a dict from PostgreSQL)\r\n                        message = row[\"message\"]\r\n                        message_text = message.get(\"conversation\", \"\") if message else \"\"\r\n                        \r\n                        if not message_text:\r\n                            self.log(\"Empty message text, skipping\")\r\n                            continue\r\n                        \r\n                        # Format and add message\r\n                        formatted_message = f\"[{timestamp}] {name}: {message_text}\"\r\n                        conversations[remote_jid][\"messages\"].append(formatted_message)\r\n                        \r\n                    except Exception as e:\r\n                        self.log(f\"Error processing message: {str(e)}\")\r\n                        continue\r\n\r\n            # Create digest for each conversation\r\n            self.log(\"Creating final digests...\")\r\n            digests = []\r\n            for remote_jid, conv in conversations.items():\r\n                chat_history = \"\\n\".join(conv[\"messages\"])\r\n                \r\n                # Prepare conversation info\r\n                chat_info = {\r\n                    \"remote_jid\": remote_jid,\r\n                    \"message_count\": len(conv[\"messages\"]),\r\n                    \"chat_history\": chat_history\r\n                }\r\n\r\n                # Add group-specific or individual chat info\r\n                if conv[\"is_group\"]:\r\n                    chat_info.update({\r\n                        \"type\": \"group\",\r\n                        \"group_name\": conv[\"contact_name\"] or \"Unknown Group\",\r\n                        \"participant_count\": len(conv[\"participants\"]),\r\n                        \"participants\": list(conv[\"participants\"])\r\n                    })\r\n                else:\r\n                    chat_info.update({\r\n                        \"type\": \"individual\",\r\n                        \"contact_name\": conv[\"contact_name\"] or \"Unknown Contact\"\r\n                    })\r\n\r\n                digests.append(Data(data=chat_info))\r\n\r\n            self.log(f\"Successfully created {len(digests)} digests\")\r\n            return digests\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error generating digests: {str(e)}\")\r\n            raise ValueError(f\"Failed to generate digests: {str(e)}\") from e","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"connection_string":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"connection_string","value":"postgresql://evolution_user:Duassenha2024@192.168.112.131:5432/evolution_db","display_name":"Connection String","advanced":false,"dynamic":false,"info":"PostgreSQL connection string","title_case":false,"type":"str","_input_type":"StrInput"},"end_time":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"end_time","value":"2024-12-27 23:59:59","display_name":"End Time","advanced":false,"input_types":["Message"],"dynamic":false,"info":"End time (YYYY-MM-DD HH:MM:SS)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"include_groups":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"include_groups","value":false,"display_name":"Include Group Chats","advanced":false,"dynamic":false,"info":"Include group conversations in the output","title_case":false,"type":"bool","_input_type":"BoolInput"},"instance_id":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"","display_name":"Instance ID","advanced":false,"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"StrInput"},"remote_jid":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"remote_jid","value":"","display_name":"Remote JID Filter","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Filter by specific WhatsApp ID (optional)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"start_time":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"start_time","value":"2024-12-25 00:00:00","display_name":"Start Time","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Start time (YYYY-MM-DD HH:MM:SS)","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Generate daily digests of WhatsApp conversations for a given time period","icon":"message-square","base_classes":["Data"],"display_name":"Evolution Chat Digest","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"chat_digests","display_name":"Chat Digests","method":"generate_digests","value":"__UNDEFINED__","cache":true}],"field_order":["connection_string","instance_id","start_time","end_time","remote_jid","include_groups"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14","official":false},"type":"CustomComponent","id":"CustomComponent-pX3Mf"},"id":"CustomComponent-pX3Mf","position":{"x":0,"y":0},"type":"genericNode"}],"viewport":{"x":1,"y":1,"zoom":1}},"is_component":true,"updated_at":"2025-01-06T17:56:23+00:00","webhook":false,"endpoint_name":null,"tags":null,"locked":false,"id":"c9fd8086-cc9c-461d-9251-7f945514e2bb","user_id":"556fed76-1562-4baf-8a2e-ef9be2d194e4","folder_id":"22c5349e-60ef-45a2-a8ec-0debcd24f6dd"},{"name":"Evolution Data Parser","description":"Parse Evolution API message data into structured format","icon":null,"icon_bg_color":null,"gradient":null,"data":{"edges":[],"nodes":[{"data":{"node":{"template":{"_type":"Component","data":{"tool_mode":false,"trace_as_metadata":true,"list":false,"trace_as_input":true,"required":true,"placeholder":"","show":true,"name":"data","value":"","display_name":"Message Data","advanced":false,"input_types":["Data"],"dynamic":false,"info":"Evolution API message data to parse","title_case":false,"type":"other","_input_type":"DataInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom datetime import datetime, timezone, timedelta\r\nfrom typing import List\r\nfrom urllib.parse import urlparse, parse_qs, urlunparse\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    DataInput,\r\n    MessageTextInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\nfrom langflow.schema.message import Message\r\n\r\n\r\nclass EvolutionDataParserComponent(Component):\r\n    display_name = \"Evolution Data Parser\"\r\n    description = \"Parse Evolution API message data into structured format\"\r\n    icon = \"filter\"\r\n    name = \"evolution_data_parser\"\r\n\r\n    inputs = [\r\n        DataInput(\r\n            name=\"data\",\r\n            display_name=\"Message Data\",\r\n            info=\"Evolution API message data to parse\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"media_server_url\",\r\n            display_name=\"Media Server URL\",\r\n            info=\"Base URL for media server (e.g., https://media.server.com)\",\r\n            required=False,\r\n            value=\"http://minio:9000\"\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"parsed_data\",\r\n            display_name=\"Parsed Data\",\r\n            description=\"All parsed data in tabular format\",\r\n            method=\"parse_data\",\r\n            type=\"list[Data]\"\r\n        ),\r\n        Output(\r\n            name=\"timestamp\",\r\n            display_name=\"Message Timestamp\",\r\n            description=\"Message timestamp in GMT-3\",\r\n            method=\"get_timestamp\",\r\n        ),\r\n        Output(\r\n            name=\"message_type\",\r\n            display_name=\"Message Type\",\r\n            description=\"Type of the message (conversation, audioMessage, etc)\",\r\n            method=\"get_message_type\",\r\n        ),\r\n        Output(\r\n            name=\"push_name\",\r\n            display_name=\"Push Name\",\r\n            description=\"Sender's push name\",\r\n            method=\"get_push_name\",\r\n        ),\r\n        Output(\r\n            name=\"remote_jid\",\r\n            display_name=\"Remote JID\",\r\n            description=\"WhatsApp ID of the remote contact\",\r\n            method=\"get_remote_jid\",\r\n        ),\r\n        Output(\r\n            name=\"message_id\",\r\n            display_name=\"Message ID\",\r\n            description=\"Unique identifier of the message\",\r\n            method=\"get_message_id\",\r\n        ),\r\n        Output(\r\n            name=\"from_me\",\r\n            display_name=\"From Me\",\r\n            description=\"Whether the message was sent by the user\",\r\n            method=\"get_from_me\",\r\n        ),\r\n        Output(\r\n            name=\"message_content\",\r\n            display_name=\"Message Content\",\r\n            description=\"Content of the message (text or media URL)\",\r\n            method=\"get_message_content\",\r\n        ),\r\n    ]\r\n\r\n    def clean_media_url(self, url: str) -> str:\r\n        \"\"\"Clean media URL by removing query parameters\"\"\"\r\n        if not url:\r\n            return \"\"\r\n            \r\n        parsed = urlparse(url)\r\n        clean_url = urlunparse((\r\n            parsed.scheme,\r\n            parsed.netloc,\r\n            parsed.path,\r\n            '',  # params\r\n            '',  # query\r\n            ''   # fragment\r\n        ))\r\n        \r\n        # Replace minio URL if media server URL is provided\r\n        if self.media_server_url:\r\n            clean_url = clean_url.replace(\"http://minio:9000\", self.media_server_url.rstrip('/'))\r\n            \r\n        return clean_url\r\n\r\n    def parse_message_content(self, message: dict, message_type: str) -> str:\r\n        \"\"\"Extract message content based on message type\"\"\"\r\n        self.log(f\"Parsing message content for type: {message_type}\")\r\n        self.log(f\"Message data: {json.dumps(message, indent=2)}\")\r\n        \r\n        if not message:\r\n            self.log(\"No message content found\")\r\n            return \"\"\r\n            \r\n        if message_type == \"conversation\":\r\n            content = message.get(\"conversation\", \"\")\r\n            self.log(f\"Extracted conversation content: {content}\")\r\n            return content\r\n        elif message_type == \"audioMessage\":\r\n            # For audio messages, mediaUrl is directly in the message object\r\n            media_url = message.get(\"mediaUrl\", \"\")\r\n            self.log(f\"Found raw media URL: {media_url}\")\r\n            cleaned_url = self.clean_media_url(media_url)\r\n            self.log(f\"Cleaned media URL: {cleaned_url}\")\r\n            return cleaned_url\r\n        \r\n        self.log(f\"Unhandled message type: {message_type}\")\r\n        return \"\"\r\n\r\n    def convert_timestamp(self, timestamp: int) -> str:\r\n        \"\"\"Convert Unix timestamp to GMT-3 datetime string\"\"\"\r\n        if not timestamp:\r\n            return \"\"\r\n            \r\n        # Convert to datetime in UTC\r\n        dt_utc = datetime.fromtimestamp(timestamp, timezone.utc)\r\n        \r\n        # Convert to GMT-3\r\n        gmt3 = timezone(timedelta(hours=-3))\r\n        dt_gmt3 = dt_utc.astimezone(gmt3)\r\n        \r\n        # Format datetime\r\n        return dt_gmt3.strftime(\"%Y-%m-%d %H:%M:%S GMT-3\")\r\n\r\n    def parse_data(self) -> List[Data]:\r\n        \"\"\"Parse Evolution API message data into structured format\"\"\"\r\n        try:\r\n            # Get input data\r\n            if not hasattr(self.data, 'data'):\r\n                raise ValueError(\"Input data missing 'data' field\")\r\n            \r\n            root_data = self.data.data\r\n            self.log(f\"Got root data structure\")\r\n            \r\n            # The actual message data is in the nested 'data' field\r\n            if 'data' not in root_data:\r\n                raise ValueError(\"Missing nested 'data' field in input\")\r\n                \r\n            input_data = root_data['data']\r\n            self.log(f\"Extracted message data: {json.dumps(input_data, indent=2)}\")\r\n\r\n            # Extract key fields\r\n            message_timestamp = input_data.get(\"messageTimestamp\", 0)\r\n            self.log(f\"Extracted timestamp: {message_timestamp}\")\r\n            \r\n            message_type = input_data.get(\"messageType\", \"\")\r\n            self.log(f\"Extracted message type: {message_type}\")\r\n            \r\n            push_name = input_data.get(\"pushName\", \"\")\r\n            self.log(f\"Extracted push name: {push_name}\")\r\n            \r\n            key_data = input_data.get(\"key\", {})\r\n            remote_jid = key_data.get(\"remoteJid\", \"\")\r\n            message_id = key_data.get(\"id\", \"\")\r\n            # Convert fromMe to string representation for consistency\r\n            from_me = str(key_data.get(\"fromMe\", False)).lower()\r\n            self.log(f\"Extracted remote JID: {remote_jid}\")\r\n            self.log(f\"Extracted message ID: {message_id}\")\r\n            self.log(f\"Extracted fromMe: {from_me}\")\r\n            \r\n            self.log(\"Extracting message content...\")\r\n            message = self.parse_message_content(\r\n                input_data.get(\"message\", {}),\r\n                message_type\r\n            )\r\n            self.log(f\"Extracted message content: {message}\")\r\n\r\n            # Create parsed data object and store it\r\n            self._parsed_data = {\r\n                \"timestamp\": self.convert_timestamp(message_timestamp),\r\n                \"messageType\": message_type,\r\n                \"pushName\": push_name,\r\n                \"remoteJid\": remote_jid,\r\n                \"messageId\": message_id,\r\n                \"fromMe\": from_me,\r\n                \"message\": message\r\n            }\r\n\r\n            return [Data(data=self._parsed_data)]\r\n\r\n        except Exception as e:\r\n            error_msg = f\"Error parsing data: {str(e)}\"\r\n            self.log(error_msg)\r\n            \r\n            # Initialize empty data on error\r\n            self._parsed_data = {\r\n                \"timestamp\": \"\",\r\n                \"messageType\": \"\",\r\n                \"pushName\": \"\",\r\n                \"remoteJid\": \"\",\r\n                \"messageId\": \"\",\r\n                \"fromMe\": \"false\",\r\n                \"message\": \"\"\r\n            }\r\n            return [Data(data=self._parsed_data)]\r\n            \r\n    def get_timestamp(self) -> Message:\r\n        \"\"\"Get the message timestamp.\"\"\"\r\n        return Message(text=self._parsed_data.get(\"timestamp\", \"\"))\r\n        \r\n    def get_message_type(self) -> Message:\r\n        \"\"\"Get the message type.\"\"\"\r\n        return Message(text=self._parsed_data.get(\"messageType\", \"\"))\r\n        \r\n    def get_push_name(self) -> Message:\r\n        \"\"\"Get the sender's push name.\"\"\"\r\n        return Message(text=self._parsed_data.get(\"pushName\", \"\"))\r\n        \r\n    def get_remote_jid(self) -> Message:\r\n        \"\"\"Get the remote JID.\"\"\"\r\n        return Message(text=self._parsed_data.get(\"remoteJid\", \"\"))\r\n\r\n    def get_message_id(self) -> Message:\r\n        \"\"\"Get the message ID.\"\"\"\r\n        return Message(text=self._parsed_data.get(\"messageId\", \"\"))\r\n\r\n    def get_from_me(self) -> Message:\r\n        \"\"\"Get whether the message was sent by the user.\"\"\"\r\n        return Message(text=self._parsed_data.get(\"fromMe\", \"false\"))\r\n        \r\n    def get_message_content(self) -> Message:\r\n        \"\"\"Get the message content.\"\"\"\r\n        return Message(text=self._parsed_data.get(\"message\", \"\"))","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"media_server_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"media_server_url","value":"http://192.168.112.131:9000","display_name":"Media Server URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Base URL for media server (e.g., https://media.server.com)","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Parse Evolution API message data into structured format","icon":"filter","base_classes":["Data","Message"],"display_name":"Evolution Data Parser","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"parsed_data","display_name":"Parsed Data","method":"parse_data","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"timestamp","display_name":"Message Timestamp","method":"get_timestamp","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"message_type","display_name":"Message Type","method":"get_message_type","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"push_name","display_name":"Push Name","method":"get_push_name","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"remote_jid","display_name":"Remote JID","method":"get_remote_jid","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"message_id","display_name":"Message ID","method":"get_message_id","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"from_me","display_name":"From Me","method":"get_from_me","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"message_content","display_name":"Message Content","method":"get_message_content","value":"__UNDEFINED__","cache":true}],"field_order":["data","media_server_url"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14","official":false},"type":"CustomComponent","id":"CustomComponent-INURq"},"id":"CustomComponent-INURq","position":{"x":0,"y":0},"type":"genericNode"}],"viewport":{"x":1,"y":1,"zoom":1}},"is_component":true,"updated_at":"2025-01-06T17:56:23+00:00","webhook":false,"endpoint_name":null,"tags":null,"locked":false,"id":"cc50d6d6-586e-4900-bade-e91aabc17490","user_id":"556fed76-1562-4baf-8a2e-ef9be2d194e4","folder_id":"22c5349e-60ef-45a2-a8ec-0debcd24f6dd"},{"name":"Evolution Router","description":"Routes data to different outputs based on message type.","icon":null,"icon_bg_color":null,"gradient":null,"data":{"edges":[],"nodes":[{"data":{"node":{"template":{"_type":"Component","data":{"tool_mode":false,"trace_as_metadata":true,"list":false,"trace_as_input":true,"required":false,"placeholder":"","show":true,"name":"data","value":"","display_name":"Data Input","advanced":false,"input_types":["Data"],"dynamic":false,"info":"The input data to be routed based on message type.","title_case":false,"type":"other","_input_type":"DataInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from langflow.custom import Component\r\nfrom langflow.io import (\r\n    DataInput,\r\n    MessageTextInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass EvolutionRouterComponent(Component):\r\n    display_name = \"Evolution Router\"\r\n    description = \"Routes data to different outputs based on message type.\"\r\n    icon = \"git-branch\"\r\n    name = \"EvolutionRouter\"\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        super().__init__(*args, **kwargs)\r\n        self.__data_processed = False\r\n\r\n    inputs = [\r\n        DataInput(\r\n            name=\"data\",\r\n            display_name=\"Data Input\",\r\n            info=\"The input data to be routed based on message type.\",\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(display_name=\"Audio Message\", name=\"audioMessage\", method=\"handle_audio\"),\r\n        Output(display_name=\"Conversation\", name=\"conversation\", method=\"handle_conversation\"),\r\n    ]\r\n\r\n    def _pre_run_setup(self):\r\n        self.__data_processed = False\r\n        self.log(f\"Starting Evolution Router\")\r\n        self.log(f\"Input data type: {type(self.data)}\")\r\n        self.log(f\"Input data content: {self.data}\")\r\n\r\n    def get_message_type(self) -> str:\r\n        \"\"\"Extract message type from the Data object.\"\"\"\r\n        try:\r\n            message_data = self.data[0]\r\n            message_type = message_data.data.get('messageType', '')\r\n            self.log(f\"Message type detected: {message_type}\")\r\n            return message_type.lower()\r\n        except (IndexError, AttributeError) as e:\r\n            self.log(f\"Error getting message type: {e}\")\r\n            return \"\"\r\n\r\n    def handle_audio(self) -> Data:\r\n        \"\"\"Handle audio message type.\"\"\"\r\n        message_type = self.get_message_type()\r\n        \r\n        if message_type == \"audiomessage\":\r\n            self.log(\"Routing to audio output\")\r\n            self.status = self.data[0]\r\n            self.stop(\"conversation\")\r\n            return self.data[0]\r\n            \r\n        self.stop(\"audioMessage\")\r\n        return Data()\r\n\r\n    def handle_conversation(self) -> Data:\r\n        \"\"\"Handle conversation (text) message type.\"\"\"\r\n        message_type = self.get_message_type()\r\n        \r\n        if message_type == \"conversation\":\r\n            self.log(\"Routing to conversation output\")\r\n            self.status = self.data[0]\r\n            self.stop(\"audioMessage\")\r\n            return self.data[0]\r\n            \r\n        self.stop(\"conversation\")\r\n        return Data()","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false}},"description":"Routes data to different outputs based on message type.","icon":"git-branch","base_classes":["Data"],"display_name":"Evolution Router","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"audioMessage","display_name":"Audio Message","method":"handle_audio","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"conversation","display_name":"Conversation","method":"handle_conversation","value":"__UNDEFINED__","cache":true}],"field_order":["data"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14","official":false},"type":"CustomComponent","id":"CustomComponent-3b8rA"},"id":"CustomComponent-3b8rA","position":{"x":0,"y":0},"type":"genericNode"}],"viewport":{"x":1,"y":1,"zoom":1}},"is_component":true,"updated_at":"2025-01-06T17:56:23+00:00","webhook":false,"endpoint_name":null,"tags":null,"locked":false,"id":"fffc359e-a631-413a-b6e3-9cc07b60d1ba","user_id":"556fed76-1562-4baf-8a2e-ef9be2d194e4","folder_id":"22c5349e-60ef-45a2-a8ec-0debcd24f6dd"},{"name":"Evolution Send Text Message","description":"Send a text message using Evolution API","icon":null,"icon_bg_color":null,"gradient":null,"data":{"edges":[],"nodes":[{"data":{"node":{"template":{"_type":"Component","api_key":{"load_from_db":false,"required":true,"placeholder":"","show":true,"name":"api_key","value":null,"display_name":"API Key","advanced":true,"input_types":["Message"],"dynamic":false,"info":"Evolution API key for authentication","title_case":false,"password":true,"type":"str","_input_type":"SecretStrInput"},"base_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"base_url","value":"","display_name":"API Base URL","advanced":true,"input_types":["Message"],"dynamic":false,"info":"Evolution API base URL (e.g., http://example.com:8080)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Dict, Any\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    SecretStrInput,\r\n    IntInput,\r\n    BoolInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass SendTextMessageComponent(Component):\r\n    display_name = \"Evolution Send Text Message\"\r\n    description = \"Send a text message using Evolution API\"\r\n    icon = \"message-square\"\r\n    name = \"send_text_message\"\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"base_url\",\r\n            display_name=\"API Base URL\",\r\n            info=\"Evolution API base URL (e.g., http://example.com:8080)\",\r\n            required=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"api_key\",\r\n            display_name=\"API Key\",\r\n            info=\"Evolution API key for authentication\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"number\",\r\n            display_name=\"Recipient Number\",\r\n            info=\"WhatsApp ID of the recipient (e.g., 5511999999999@s.whatsapp.net)\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"text\",\r\n            display_name=\"Message Text\",\r\n            info=\"The text message to send\",\r\n            required=True,\r\n        ),\r\n        # Advanced options\r\n        MessageTextInput(\r\n            name=\"quoted_message_id\",\r\n            display_name=\"Quoted Message ID\",\r\n            info=\"ID of the message to quote (optional)\",\r\n            advanced=True,\r\n            required=False,\r\n        ),\r\n        IntInput(\r\n            name=\"delay\",\r\n            display_name=\"Delay\",\r\n            info=\"Optional delay in milliseconds\",\r\n            advanced=True,\r\n        ),\r\n        BoolInput(\r\n            name=\"mentions_everyone\",\r\n            display_name=\"Mention Everyone\",\r\n            info=\"Whether to mention all participants\",\r\n            advanced=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"mentioned\",\r\n            display_name=\"Mentioned Numbers\",\r\n            info=\"List of WhatsApp IDs to mention (comma-separated)\",\r\n            advanced=True,\r\n            is_list=True,\r\n        ),\r\n        BoolInput(\r\n            name=\"link_preview\",\r\n            display_name=\"Link Preview\",\r\n            info=\"Whether to show link previews in the message\",\r\n            advanced=True,\r\n        ),\r\n        BoolInput(\r\n            name=\"show_typing\",\r\n            display_name=\"Show Typing\",\r\n            info=\"Show typing indicator before sending message\",\r\n            advanced=True,\r\n        ),\r\n        IntInput(\r\n            name=\"typing_delay\",\r\n            display_name=\"Typing Delay\",\r\n            info=\"How long to show typing indicator (in milliseconds)\",\r\n            advanced=True,\r\n            value=3000,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"message\",\r\n            display_name=\"Message\",\r\n            method=\"send_message\",\r\n        ),\r\n    ]\r\n\r\n    def build_payload(self) -> Dict[str, Any]:\r\n        \"\"\"Build the request payload.\"\"\"\r\n        payload = {\r\n            \"number\": self.number,\r\n            \"text\": self.text\r\n        }\r\n        \r\n        # Add optional fields if provided\r\n        if hasattr(self, 'delay') and self.delay:\r\n            payload[\"delay\"] = self.delay\r\n            \r\n        if hasattr(self, 'mentions_everyone'):\r\n            payload[\"mentionsEveryOne\"] = self.mentions_everyone\r\n            \r\n        if hasattr(self, 'mentioned') and self.mentioned:\r\n            payload[\"mentioned\"] = self.mentioned\r\n\r\n        if hasattr(self, 'link_preview'):\r\n            payload[\"linkPreview\"] = self.link_preview\r\n\r\n        # Add quoted message if ID is provided\r\n        if hasattr(self, 'quoted_message_id') and self.quoted_message_id:\r\n            payload[\"quoted\"] = {\r\n                \"key\": {\r\n                    \"id\": self.quoted_message_id\r\n                }\r\n            }\r\n        \r\n        # Log payload (excluding sensitive data)\r\n        safe_payload = {**payload}\r\n        safe_payload[\"number\"] = \"***hidden***\"\r\n        self.log(f\"Built payload: {json.dumps(safe_payload, indent=2)}\")\r\n        \r\n        return payload\r\n\r\n    def send_presence(self) -> None:\r\n        \"\"\"Send typing presence indicator.\"\"\"\r\n        try:\r\n            base_url = self.base_url.rstrip('/')\r\n            url = f\"{base_url}/chat/sendPresence/{self.instance_id}\"\r\n            \r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n                \"Content-Type\": \"application/json\"\r\n            }\r\n            \r\n            payload = {\r\n                \"number\": self.number,\r\n                \"delay\": self.typing_delay,\r\n                \"presence\": \"composing\"\r\n            }\r\n            \r\n            self.log(\"Sending typing presence indicator...\")\r\n            response = requests.post(url, headers=headers, json=payload)\r\n            response.raise_for_status()\r\n            self.log(\"Typing indicator sent successfully\")\r\n            \r\n        except Exception as e:\r\n            self.log(f\"Error sending typing presence: {str(e)}\")\r\n\r\n    def send_message(self) -> Data:\r\n        \"\"\"\r\n        Send a text message via Evolution API.\r\n        \"\"\"\r\n        try:\r\n            # Ensure base URL format\r\n            base_url = self.base_url.rstrip('/')\r\n            self.log(f\"Using base URL: {base_url}\")\r\n            \r\n            # Send typing presence if enabled\r\n            if hasattr(self, 'show_typing') and self.show_typing:\r\n                self.send_presence()\r\n            \r\n            # Build API endpoint URL\r\n            url = f\"{base_url}/message/sendText/{self.instance_id}\"\r\n            self.log(f\"Full API endpoint URL: {url}\")\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n                \"Content-Type\": \"application/json\"\r\n            }\r\n            self.log(\"Headers prepared (apikey hidden)\")\r\n\r\n            # Build payload\r\n            payload = self.build_payload()\r\n            \r\n            # Log the complete request (excluding sensitive data)\r\n            request_info = {\r\n                \"url\": url,\r\n                \"headers\": {\r\n                    \"Content-Type\": \"application/json\",\r\n                    \"apikey\": \"***hidden***\"\r\n                },\r\n                \"payload\": {\r\n                    \"number\": \"***hidden***\",\r\n                    \"text\": payload[\"text\"]\r\n                }\r\n            }\r\n            self.log(f\"Making request: {json.dumps(request_info, indent=2)}\")\r\n\r\n            # Make API request\r\n            response = requests.post(\r\n                url, \r\n                headers=headers, \r\n                data=json.dumps(payload)\r\n            )\r\n            \r\n            self.log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Check for successful response\r\n            response.raise_for_status()\r\n            \r\n            # Parse response\r\n            data = response.json()\r\n            \r\n            # Process response into consistent format\r\n            processed_response = {\r\n                \"key\": data.get(\"key\", {}),\r\n                \"pushName\": data.get(\"pushName\", \"\"),\r\n                \"status\": data.get(\"status\"),\r\n                \"message\": data.get(\"message\", {}),\r\n                \"contextInfo\": data.get(\"contextInfo\"),\r\n                \"messageType\": data.get(\"messageType\"),\r\n                \"messageTimestamp\": data.get(\"messageTimestamp\"),\r\n                \"instanceId\": data.get(\"instanceId\"),\r\n                \"source\": data.get(\"source\")\r\n            }\r\n            \r\n            self.log(\"Message sent successfully\")\r\n            self.log(f\"Message status: {processed_response.get('status')}\")\r\n            \r\n            return Data(data=processed_response)\r\n\r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"API request failed: {str(e)}\"\r\n            self.log(f\"Request error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Unexpected error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"delay":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"delay","value":"","display_name":"Delay","advanced":true,"dynamic":false,"info":"Optional delay in milliseconds","title_case":false,"type":"int","_input_type":"IntInput"},"instance_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"felipe8888","display_name":"Instance ID","advanced":true,"input_types":["Message"],"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"MessageTextInput"},"link_preview":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"link_preview","value":false,"display_name":"Link Preview","advanced":true,"dynamic":false,"info":"Whether to show link previews in the message","title_case":false,"type":"bool","_input_type":"BoolInput"},"mentioned":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":true,"required":false,"placeholder":"","show":true,"name":"mentioned","value":"","display_name":"Mentioned Numbers","advanced":true,"input_types":["Message"],"dynamic":false,"info":"List of WhatsApp IDs to mention (comma-separated)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"mentions_everyone":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"mentions_everyone","value":false,"display_name":"Mention Everyone","advanced":true,"dynamic":false,"info":"Whether to mention all participants","title_case":false,"type":"bool","_input_type":"BoolInput"},"number":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"number","value":"","display_name":"Recipient Number","advanced":false,"input_types":["Message"],"dynamic":false,"info":"WhatsApp ID of the recipient (e.g., 5511999999999@s.whatsapp.net)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"quoted_message_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"quoted_message_id","value":"","display_name":"Quoted Message ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"ID of the message to quote (optional)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"show_typing":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"show_typing","value":false,"display_name":"Show Typing","advanced":true,"dynamic":false,"info":"Show typing indicator before sending message","title_case":false,"type":"bool","_input_type":"BoolInput"},"text":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"text","value":"","display_name":"Message Text","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The text message to send","title_case":false,"type":"str","_input_type":"MessageTextInput"},"typing_delay":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"typing_delay","value":3000,"display_name":"Typing Delay","advanced":true,"dynamic":false,"info":"How long to show typing indicator (in milliseconds)","title_case":false,"type":"int","_input_type":"IntInput"}},"description":"Send a text message using Evolution API","icon":"message-square","base_classes":["Data"],"display_name":"Evolution Send Text Message","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"message","display_name":"Message","method":"send_message","value":"__UNDEFINED__","cache":true}],"field_order":["base_url","api_key","instance_id","number","text","quoted_message_id","delay","mentions_everyone","mentioned","link_preview","show_typing","typing_delay"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14","official":false},"type":"CustomComponent","id":"CustomComponent-bVtd7"},"id":"CustomComponent-bVtd7","position":{"x":0,"y":0},"type":"genericNode"}],"viewport":{"x":1,"y":1,"zoom":1}},"is_component":true,"updated_at":"2025-01-06T17:56:23+00:00","webhook":false,"endpoint_name":null,"tags":null,"locked":false,"id":"1f606573-2d4c-48c8-bc6c-4d95cc38e817","user_id":"556fed76-1562-4baf-8a2e-ef9be2d194e4","folder_id":"22c5349e-60ef-45a2-a8ec-0debcd24f6dd"},{"name":"Evolution Text Message Query","description":"Query text messages from Evolution database with different filter options","icon":null,"icon_bg_color":null,"gradient":null,"data":{"edges":[],"nodes":[{"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from typing import Any, Dict, List, Optional\r\nfrom sqlalchemy import create_engine, text\r\nimport json\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    StrInput,\r\n    MessageTextInput,\r\n    IntInput,\r\n    DropdownInput,\r\n    Output, \r\n    BoolInput\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass TextMessageQueryComponent(Component):\r\n    display_name = \"Evolution Text Message Query\"\r\n    description = \"Query text messages from Evolution database with different filter options\"\r\n    icon = \"message-square\"\r\n    name = \"evolution_text_message_query\"\r\n\r\n    def __init__(self, **data):\r\n        super().__init__(**data)\r\n        self._engine = None\r\n\r\n    inputs = [\r\n        StrInput(\r\n            name=\"connection_string\",\r\n            display_name=\"Connection String\",\r\n            info=\"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)\",\r\n            required=True\r\n        ),\r\n        StrInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"message_id\",\r\n            display_name=\"Message ID\",\r\n            info=\"Find specific text message by ID\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"remote_jid\",\r\n            display_name=\"Remote JID\",\r\n            info=\"Filter by remote JID (e.g., 5511999999999@s.whatsapp.net or 123456789@g.us for groups)\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"push_name\",\r\n            display_name=\"Push Name\",\r\n            info=\"Filter by contact name\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"text_search\",\r\n            display_name=\"Text Search\",\r\n            info=\"Search for specific text in messages\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"participant\",\r\n            display_name=\"Participant\",\r\n            info=\"Filter by participant in group chats (JID)\",\r\n            required=False,\r\n            advanced=True\r\n        ),\r\n        BoolInput(\r\n            name=\"from_me\",\r\n            display_name=\"From Me\",\r\n            info=\"Filter messages sent by me\",\r\n            advanced=True\r\n        ),\r\n        BoolInput(\r\n            name=\"is_group\",\r\n            display_name=\"Group Messages\",\r\n            info=\"Filter group messages only\",\r\n            advanced=True\r\n        ),\r\n        BoolInput(\r\n            name=\"has_quoted\",\r\n            display_name=\"Has Quote\",\r\n            info=\"Filter messages that quote other messages\",\r\n            advanced=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"start_time\",\r\n            display_name=\"Start Time\",\r\n            info=\"Start time (YYYY-MM-DD HH:MM:SS)\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"end_time\",\r\n            display_name=\"End Time\", \r\n            info=\"End time (YYYY-MM-DD HH:MM:SS)\",\r\n            required=False\r\n        ),\r\n        DropdownInput(\r\n            name=\"sort_direction\",\r\n            display_name=\"Sort Direction\",\r\n            info=\"Sort direction by messageTimestamp\",\r\n            options=[\"ASC\", \"DESC\"],\r\n            value=\"DESC\",\r\n            required=False\r\n        ),\r\n        IntInput(\r\n            name=\"page_size\",\r\n            display_name=\"Page Size\",\r\n            info=\"Number of records per page\",\r\n            value=100,\r\n            required=True\r\n        ),\r\n        IntInput(\r\n            name=\"page\",\r\n            display_name=\"Page\",\r\n            info=\"Page number (starts at 1)\",\r\n            value=1,\r\n            required=True\r\n        )\r\n    ]\r\n\r\n    outputs = [\r\n        Output(name=\"messages\", display_name=\"Messages\", method=\"execute_query\"),\r\n        Output(name=\"parsed_text\", display_name=\"Parsed Text\", method=\"get_parsed_text\"),\r\n    ]\r\n\r\n    def parse_message(self, message: dict, contextInfo: dict = None) -> dict:\r\n        \"\"\"Parse message content to extract text and quoted message.\"\"\"\r\n        try:\r\n            if not message:\r\n                return {}\r\n                \r\n            if isinstance(message, str):\r\n                message = json.loads(message)\r\n\r\n            # Get main message text\r\n            text = message.get(\"conversation\", \"\")\r\n\r\n            # Check for quoted message in contextInfo\r\n            quoted_text = None\r\n            if contextInfo and \"quotedMessage\" in contextInfo:\r\n                quoted = contextInfo[\"quotedMessage\"]\r\n                if isinstance(quoted, str):\r\n                    quoted = json.loads(quoted)\r\n                quoted_text = quoted.get(\"conversation\", \"\")\r\n\r\n            return {\r\n                \"text\": text,\r\n                \"quoted_text\": quoted_text\r\n            }\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error parsing message content: {str(e)}\")\r\n            return {}\r\n\r\n    def get_engine(self):\r\n        \"\"\"Get or create SQLAlchemy engine.\"\"\"\r\n        if not self._engine:\r\n            try:\r\n                self._engine = create_engine(\r\n                    self.connection_string,\r\n                    echo=False\r\n                )\r\n                \r\n                # Test the connection\r\n                with self._engine.connect() as conn:\r\n                    conn.execute(text(\"SELECT 1\"))\r\n                    \r\n            except Exception as e:\r\n                self.log(f\"Failed to create database engine: {str(e)}\")\r\n                raise ValueError(f\"Database connection failed: {str(e)}\") from e\r\n        return self._engine\r\n\r\n    def build_query(self) -> tuple[str, dict]:\r\n        \"\"\"Build the SQL query and parameters.\"\"\"\r\n        try:\r\n            query = '''\r\n                SELECT \r\n                    \"messageTimestamp\", \r\n                    \"messageType\", \r\n                    message, \r\n                    \"pushName\", \r\n                    key,\r\n                    \"contextInfo\"\r\n                FROM public.\"Message\"\r\n                WHERE \"messageType\" = 'conversation'\r\n                AND \"instanceId\" = :instance_id\r\n            '''\r\n            params = {\"instance_id\": self.instance_id}\r\n\r\n            # Add message ID filter if specified\r\n            if hasattr(self, 'message_id') and self.message_id:\r\n                query += \" AND (key->>'id')::text = :message_id\"\r\n                params[\"message_id\"] = str(self.message_id).strip()\r\n\r\n            # Add remote JID filter if specified\r\n            if hasattr(self, 'remote_jid') and self.remote_jid:\r\n                query += \" AND key->>'remoteJid' = :remote_jid\"\r\n                params[\"remote_jid\"] = str(self.remote_jid).strip()\r\n            # Only apply group filter if no specific remote_jid is provided\r\n            elif hasattr(self, 'is_group'):\r\n                if self.is_group:\r\n                    query += \" AND key->>'remoteJid' LIKE '%@g.us'\"\r\n                else:\r\n                    query += \" AND key->>'remoteJid' LIKE '%@s.whatsapp.net'\"\r\n\r\n            # Add push name filter if specified\r\n            if hasattr(self, 'push_name') and self.push_name:\r\n                query += ' AND \"pushName\" = :push_name'\r\n                params[\"push_name\"] = str(self.push_name).strip()\r\n\r\n            # Add text search if specified\r\n            if hasattr(self, 'text_search') and self.text_search:\r\n                query += \" AND message->>'conversation' ILIKE :text_search\"\r\n                params[\"text_search\"] = f\"%{str(self.text_search).strip()}%\"\r\n\r\n            # Add participant filter if specified\r\n            if hasattr(self, 'participant') and self.participant:\r\n                query += \" AND key->>'participant' = :participant\"\r\n                params[\"participant\"] = str(self.participant).strip()\r\n\r\n            # Add fromMe filter if specified\r\n            if hasattr(self, 'from_me'):\r\n                query += \" AND (key->>'fromMe')::boolean = :from_me\"\r\n                params[\"from_me\"] = self.from_me\r\n\r\n            # Add quoted messages filter if specified\r\n            if hasattr(self, 'has_quoted') and self.has_quoted:\r\n                query += ' AND \"contextInfo\"->\\'quotedMessage\\' IS NOT NULL'\r\n\r\n            # Add timestamp range if specified\r\n            if hasattr(self, 'start_time') and self.start_time:\r\n                query += ' AND \"messageTimestamp\" >= (extract(epoch from timestamp :start_time)::bigint)'\r\n                params[\"start_time\"] = str(self.start_time).strip()\r\n            if hasattr(self, 'end_time') and self.end_time:\r\n                query += ' AND \"messageTimestamp\" <= (extract(epoch from timestamp :end_time)::bigint)'\r\n                params[\"end_time\"] = str(self.end_time).strip()\r\n\r\n            # Add ORDER BY\r\n            query += f' ORDER BY \"messageTimestamp\" {self.sort_direction}'\r\n\r\n            # Add pagination\r\n            page = max(1, self.page)\r\n            page_size = max(1, self.page_size)\r\n            offset = (page - 1) * page_size\r\n            query += \" LIMIT :limit OFFSET :offset\"\r\n            params.update({\"limit\": page_size, \"offset\": offset})\r\n\r\n            return query, params\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error building query: {str(e)}\")\r\n            raise ValueError(f\"Failed to build query: {str(e)}\") from e\r\n\r\n    def execute_query(self) -> List[Data]:\r\n        \"\"\"Execute the query and return results.\"\"\"\r\n        try:\r\n            query, params = self.build_query()\r\n            self.log(f\"Executing query: {query} with params: {params}\")\r\n\r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                # Execute main query\r\n                result = conn.execute(text(query), params)\r\n                rows = [dict(zip(row._fields, row)) for row in result]\r\n\r\n                # Get total count\r\n                count_query = '''\r\n                    SELECT COUNT(*) \r\n                    FROM public.\"Message\" \r\n                    WHERE \"messageType\" = 'conversation'\r\n                    AND \"instanceId\" = :instance_id\r\n                '''\r\n                count_params = {\"instance_id\": self.instance_id}\r\n                \r\n                # Add message ID filter to count query\r\n                if hasattr(self, 'message_id') and self.message_id:\r\n                    count_query += \" AND (key->>'id')::text = :message_id\"\r\n                    count_params[\"message_id\"] = str(self.message_id).strip()\r\n\r\n                # Add remote JID filter to count query\r\n                if hasattr(self, 'remote_jid') and self.remote_jid:\r\n                    count_query += \" AND key->>'remoteJid' = :remote_jid\"\r\n                    count_params[\"remote_jid\"] = str(self.remote_jid).strip()\r\n                elif hasattr(self, 'is_group'):\r\n                    if self.is_group:\r\n                        count_query += \" AND key->>'remoteJid' LIKE '%@g.us'\"\r\n                    else:\r\n                        count_query += \" AND key->>'remoteJid' LIKE '%@s.whatsapp.net'\"\r\n\r\n                # Add push name filter to count query\r\n                if hasattr(self, 'push_name') and self.push_name:\r\n                    count_query += ' AND \"pushName\" = :push_name'\r\n                    count_params[\"push_name\"] = str(self.push_name).strip()\r\n\r\n                # Add text search to count query\r\n                if hasattr(self, 'text_search') and self.text_search:\r\n                    count_query += \" AND message->>'conversation' ILIKE :text_search\"\r\n                    count_params[\"text_search\"] = f\"%{str(self.text_search).strip()}%\"\r\n\r\n                # Add participant filter to count query\r\n                if hasattr(self, 'participant') and self.participant:\r\n                    count_query += \" AND key->>'participant' = :participant\"\r\n                    count_params[\"participant\"] = str(self.participant).strip()\r\n\r\n                # Add fromMe filter to count query\r\n                if hasattr(self, 'from_me'):\r\n                    count_query += \" AND (key->>'fromMe')::boolean = :from_me\"\r\n                    count_params[\"from_me\"] = self.from_me\r\n\r\n                # Add quoted messages filter to count query\r\n                if hasattr(self, 'has_quoted') and self.has_quoted:\r\n                    count_query += ' AND \"contextInfo\"->\\'quotedMessage\\' IS NOT NULL'\r\n\r\n                # Add timestamp range to count query\r\n                if hasattr(self, 'start_time') and self.start_time:\r\n                    count_query += ' AND \"messageTimestamp\" >= (extract(epoch from timestamp :start_time)::bigint)'\r\n                    count_params[\"start_time\"] = str(self.start_time).strip()\r\n                if hasattr(self, 'end_time') and self.end_time:\r\n                    count_query += ' AND \"messageTimestamp\" <= (extract(epoch from timestamp :end_time)::bigint)'\r\n                    count_params[\"end_time\"] = str(self.end_time).strip()\r\n\r\n                count_result = conn.execute(text(count_query), count_params)\r\n                total_count = count_result.scalar()\r\n\r\n            # Process messages and extract text\r\n            results = []\r\n            for row in rows:\r\n                parsed = self.parse_message(row[\"message\"], row[\"contextInfo\"])\r\n                \r\n                results.append(Data(\r\n                    data={\r\n                        \"messageTimestamp\": row[\"messageTimestamp\"],\r\n                        \"key\": row[\"key\"],\r\n                        \"pushName\": row[\"pushName\"],\r\n                        \"message\": row[\"message\"],\r\n                        \"contextInfo\": row[\"contextInfo\"],\r\n                        \"text\": parsed.get(\"text\", \"\"),\r\n                        \"quoted_text\": parsed.get(\"quoted_text\"),\r\n                        \"__meta__\": {\r\n                            \"total_records\": total_count,\r\n                            \"page\": self.page,\r\n                            \"page_size\": self.page_size,\r\n                            \"total_pages\": -(-total_count // self.page_size)\r\n                        }\r\n                    }\r\n                ))\r\n\r\n            return results\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error executing query: {str(e)}\")\r\n            raise ValueError(f\"Query execution failed: {str(e)}\") from e\r\n\r\n    def get_parsed_text(self) -> List[Data]:\r\n        \"\"\"Return just the parsed text content from messages.\"\"\"\r\n        try:\r\n            query, params = self.build_query()\r\n            \r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                result = conn.execute(text(query), params)\r\n                rows = [dict(zip(row._fields, row)) for row in result]\r\n\r\n            # Return just the parsed text\r\n            return [\r\n                Data(\r\n                    data={\r\n                        \"text\": self.parse_message(row[\"message\"], row[\"contextInfo\"]).get(\"text\", \"\"),\r\n                        \"quoted_text\": self.parse_message(row[\"message\"], row[\"contextInfo\"]).get(\"quoted_text\")\r\n                    }\r\n                )\r\n                for row in rows\r\n            ]\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error getting parsed text: {str(e)}\")\r\n            raise ValueError(f\"Failed to get parsed text: {str(e)}\") from e","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"connection_string":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"connection_string","value":"postgresql://evolution_user:Duassenha2024@192.168.112.131:5432/evolution_db","display_name":"Connection String","advanced":false,"dynamic":false,"info":"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)","title_case":false,"type":"str","_input_type":"StrInput"},"end_time":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"end_time","value":"","display_name":"End Time","advanced":false,"input_types":["Message"],"dynamic":false,"info":"End time (YYYY-MM-DD HH:MM:SS)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"from_me":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"from_me","value":false,"display_name":"From Me","advanced":true,"dynamic":false,"info":"Filter messages sent by me","title_case":false,"type":"bool","_input_type":"BoolInput"},"has_quoted":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"has_quoted","value":false,"display_name":"Has Quote","advanced":true,"dynamic":false,"info":"Filter messages that quote other messages","title_case":false,"type":"bool","_input_type":"BoolInput"},"instance_id":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"","display_name":"Instance ID","advanced":false,"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"StrInput"},"is_group":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"is_group","value":false,"display_name":"Group Messages","advanced":true,"dynamic":false,"info":"Filter group messages only","title_case":false,"type":"bool","_input_type":"BoolInput"},"message_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"message_id","value":"","display_name":"Message ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Find specific text message by ID","title_case":false,"type":"str","_input_type":"MessageTextInput"},"page":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":true,"placeholder":"","show":true,"name":"page","value":1,"display_name":"Page","advanced":false,"dynamic":false,"info":"Page number (starts at 1)","title_case":false,"type":"int","_input_type":"IntInput"},"page_size":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":true,"placeholder":"","show":true,"name":"page_size","value":100,"display_name":"Page Size","advanced":false,"dynamic":false,"info":"Number of records per page","title_case":false,"type":"int","_input_type":"IntInput","load_from_db":false},"participant":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"participant","value":"","display_name":"Participant","advanced":true,"input_types":["Message"],"dynamic":false,"info":"Filter by participant in group chats (JID)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"push_name":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"push_name","value":"","display_name":"Push Name","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Filter by contact name","title_case":false,"type":"str","_input_type":"MessageTextInput"},"remote_jid":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"remote_jid","value":"5511986780008@s.whatsapp.net","display_name":"Remote JID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Filter by remote JID (e.g., 5511999999999@s.whatsapp.net or 123456789@g.us for groups)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"sort_direction":{"tool_mode":false,"trace_as_metadata":true,"options":["ASC","DESC"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"sort_direction","value":"DESC","display_name":"Sort Direction","advanced":false,"dynamic":false,"info":"Sort direction by messageTimestamp","title_case":false,"type":"str","_input_type":"DropdownInput"},"start_time":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"start_time","value":"","display_name":"Start Time","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Start time (YYYY-MM-DD HH:MM:SS)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"text_search":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"text_search","value":"","display_name":"Text Search","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Search for specific text in messages","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Query text messages from Evolution database with different filter options","icon":"message-square","base_classes":["Data"],"display_name":"Evolution Text Message Query","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"messages","display_name":"Messages","method":"execute_query","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"parsed_text","display_name":"Parsed Text","method":"get_parsed_text","value":"__UNDEFINED__","cache":true}],"field_order":["connection_string","instance_id","message_id","remote_jid","push_name","text_search","participant","from_me","is_group","has_quoted","start_time","end_time","sort_direction","page_size","page"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14","official":false},"type":"CustomComponent","id":"CustomComponent-xcmBH"},"id":"CustomComponent-xcmBH","position":{"x":0,"y":0},"type":"genericNode"}],"viewport":{"x":1,"y":1,"zoom":1}},"is_component":true,"updated_at":"2025-01-06T17:56:24+00:00","webhook":false,"endpoint_name":null,"tags":null,"locked":false,"id":"8528b61b-5467-484a-b9e2-34a41ea0d9e3","user_id":"556fed76-1562-4baf-8a2e-ef9be2d194e4","folder_id":"22c5349e-60ef-45a2-a8ec-0debcd24f6dd"},{"name":"Evolution Webhook Parser","description":"Parse Evolution API webhook message data into structured format","icon":null,"icon_bg_color":null,"gradient":null,"data":{"edges":[],"nodes":[{"data":{"node":{"template":{"_type":"Component","data":{"tool_mode":false,"trace_as_metadata":true,"list":false,"trace_as_input":true,"required":true,"placeholder":"","show":true,"name":"data","value":"","display_name":"Message Data","advanced":false,"input_types":["Data"],"dynamic":false,"info":"Evolution API message data to parse","title_case":false,"type":"other","_input_type":"DataInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nfrom typing import List\r\nfrom urllib.parse import urlparse, urlunparse\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    DataInput,\r\n    MessageTextInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\nfrom langflow.schema.message import Message\r\n\r\n\r\nclass EvolutionDataParserComponent(Component):\r\n    display_name = \"Evolution Webhook Parser\"\r\n    description = \"Parse Evolution API webhook message data into structured format\"\r\n    icon = \"webhook\"\r\n    name = \"evolution_data_parser\"\r\n\r\n    inputs = [\r\n        DataInput(\r\n            name=\"data\",\r\n            display_name=\"Message Data\",\r\n            info=\"Evolution API message data to parse\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"media_server_url\",\r\n            display_name=\"Media Server URL\",\r\n            info=\"Base URL for media server (e.g., https://media.server.com)\",\r\n            required=False,\r\n            value=\"http://minio:9000\"\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"timestamp\",\r\n            display_name=\"Message Timestamp\",\r\n            description=\"Message timestamp in GMT-3\",\r\n            method=\"get_timestamp\",\r\n        ),\r\n        Output(\r\n            name=\"message_type\",\r\n            display_name=\"Message Type\",\r\n            description=\"Type of the message (conversation, audioMessage, etc)\",\r\n            method=\"get_message_type\",\r\n        ),\r\n        Output(\r\n            name=\"push_name\",\r\n            display_name=\"Push Name\",\r\n            description=\"Sender's push name\",\r\n            method=\"get_push_name\",\r\n        ),\r\n        Output(\r\n            name=\"remote_jid\",\r\n            display_name=\"Remote JID\",\r\n            description=\"WhatsApp ID of the remote contact\",\r\n            method=\"get_remote_jid\",\r\n        ),\r\n        Output(\r\n            name=\"message_id\",\r\n            display_name=\"Message ID\",\r\n            description=\"Unique identifier of the message\",\r\n            method=\"get_message_id\",\r\n        ),\r\n        Output(\r\n            name=\"from_me\",\r\n            display_name=\"From Me\",\r\n            description=\"Whether the message was sent by the user\",\r\n            method=\"get_from_me\",\r\n        ),\r\n        Output(\r\n            name=\"message_content\",\r\n            display_name=\"Message Content\",\r\n            description=\"Content of the message (text or media URL)\",\r\n            method=\"get_message_content\",\r\n        ),\r\n    ]\r\n\r\n    def clean_media_url(self, url: str) -> str:\r\n        \"\"\"Clean media URL by removing query parameters\"\"\"\r\n        if not url:\r\n            return \"\"\r\n            \r\n        parsed = urlparse(url)\r\n        clean_url = urlunparse((\r\n            parsed.scheme,\r\n            parsed.netloc,\r\n            parsed.path,\r\n            '',  # params\r\n            '',  # query\r\n            ''   # fragment\r\n        ))\r\n        \r\n        # Replace minio URL if media server URL is provided\r\n        if self.media_server_url:\r\n            clean_url = clean_url.replace(\"http://minio:9000\", self.media_server_url.rstrip('/'))\r\n            \r\n        return clean_url\r\n\r\n    def parse_message_content(self, message: str, message_type: str) -> str:\r\n        \"\"\"Process message content based on message type\"\"\"\r\n        self.log(f\"Processing message content for type: {message_type}\")\r\n        \r\n        if not message:\r\n            self.log(\"No message content found\")\r\n            return \"\"\r\n            \r\n        if message_type == \"audioMessage\":\r\n            self.log(f\"Found media URL: {message}\")\r\n            cleaned_url = self.clean_media_url(message)\r\n            self.log(f\"Cleaned media URL: {cleaned_url}\")\r\n            return cleaned_url\r\n            \r\n        # For other message types, return content as is\r\n        return message\r\n\r\n    def parse_data(self) -> None:\r\n        \"\"\"Parse Evolution API message data into structured format\"\"\"\r\n        try:\r\n            # Get input data\r\n            if not hasattr(self.data, 'data'):\r\n                raise ValueError(\"Input data missing 'data' field\")\r\n            \r\n            input_data = self.data.data\r\n            self.log(f\"Processing input data: {json.dumps(input_data, indent=2)}\")\r\n\r\n            # Process message content if needed\r\n            message = self.parse_message_content(\r\n                input_data.get(\"message\", \"\"),\r\n                input_data.get(\"messageType\", \"\")\r\n            )\r\n\r\n            # Store parsed data\r\n            self._parsed_data = {\r\n                \"timestamp\": input_data.get(\"timestamp\", \"\"),\r\n                \"messageType\": input_data.get(\"messageType\", \"\"),\r\n                \"pushName\": input_data.get(\"pushName\", \"\"),\r\n                \"remoteJid\": input_data.get(\"remoteJid\", \"\"),\r\n                \"messageId\": input_data.get(\"messageId\", \"\"),\r\n                \"fromMe\": input_data.get(\"fromMe\", \"false\"),\r\n                \"message\": message\r\n            }\r\n\r\n        except Exception as e:\r\n            error_msg = f\"Error parsing data: {str(e)}\"\r\n            self.log(error_msg)\r\n            \r\n            # Initialize empty data on error\r\n            self._parsed_data = {\r\n                \"timestamp\": \"\",\r\n                \"messageType\": \"\",\r\n                \"pushName\": \"\",\r\n                \"remoteJid\": \"\",\r\n                \"messageId\": \"\",\r\n                \"fromMe\": \"false\",\r\n                \"message\": \"\"\r\n            }\r\n            \r\n    def get_timestamp(self) -> Message:\r\n        \"\"\"Get the message timestamp.\"\"\"\r\n        self.parse_data()\r\n        return Message(text=self._parsed_data.get(\"timestamp\", \"\"))\r\n        \r\n    def get_message_type(self) -> Message:\r\n        \"\"\"Get the message type.\"\"\"\r\n        self.parse_data()\r\n        return Message(text=self._parsed_data.get(\"messageType\", \"\"))\r\n        \r\n    def get_push_name(self) -> Message:\r\n        \"\"\"Get the sender's push name.\"\"\"\r\n        self.parse_data()\r\n        return Message(text=self._parsed_data.get(\"pushName\", \"\"))\r\n        \r\n    def get_remote_jid(self) -> Message:\r\n        \"\"\"Get the remote JID.\"\"\"\r\n        self.parse_data()\r\n        return Message(text=self._parsed_data.get(\"remoteJid\", \"\"))\r\n\r\n    def get_message_id(self) -> Message:\r\n        \"\"\"Get the message ID.\"\"\"\r\n        self.parse_data()\r\n        return Message(text=self._parsed_data.get(\"messageId\", \"\"))\r\n\r\n    def get_from_me(self) -> Message:\r\n        \"\"\"Get whether the message was sent by the user.\"\"\"\r\n        self.parse_data()\r\n        return Message(text=self._parsed_data.get(\"fromMe\", \"false\"))\r\n        \r\n    def get_message_content(self) -> Message:\r\n        \"\"\"Get the message content.\"\"\"\r\n        self.parse_data()\r\n        return Message(text=self._parsed_data.get(\"message\", \"\"))","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"media_server_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"media_server_url","value":"http://192.168.112.131:9000","display_name":"Media Server URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Base URL for media server (e.g., https://media.server.com)","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Parse Evolution API webhook message data into structured format","icon":"webhook","base_classes":["Message"],"display_name":"Evolution Webhook Parser","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"timestamp","display_name":"Message Timestamp","method":"get_timestamp","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"message_type","display_name":"Message Type","method":"get_message_type","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"push_name","display_name":"Push Name","method":"get_push_name","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"remote_jid","display_name":"Remote JID","method":"get_remote_jid","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"message_id","display_name":"Message ID","method":"get_message_id","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"from_me","display_name":"From Me","method":"get_from_me","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"message_content","display_name":"Message Content","method":"get_message_content","value":"__UNDEFINED__","cache":true}],"field_order":["data","media_server_url"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14","official":false},"type":"CustomComponent","id":"CustomComponent-e25A6"},"id":"CustomComponent-e25A6","position":{"x":0,"y":0},"type":"genericNode"}],"viewport":{"x":1,"y":1,"zoom":1}},"is_component":true,"updated_at":"2025-01-06T17:56:24+00:00","webhook":false,"endpoint_name":null,"tags":null,"locked":false,"id":"85ce4892-1603-49d4-9776-23f6c63ad49f","user_id":"556fed76-1562-4baf-8a2e-ef9be2d194e4","folder_id":"22c5349e-60ef-45a2-a8ec-0debcd24f6dd"},{"name":"If-Else","description":"Routes an input message based on multiple text comparisons combined with AND/OR.","icon":null,"icon_bg_color":null,"gradient":null,"data":{"edges":[],"nodes":[{"data":{"node":{"template":{"_type":"Component","case_sensitive":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"case_sensitive","value":false,"display_name":"Case Sensitive","advanced":false,"dynamic":false,"info":"If true, the comparison will be case sensitive.","title_case":false,"type":"bool","_input_type":"BoolInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import re\r\nfrom typing import List\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageInput, MessageTextInput, Output\r\nfrom langflow.schema.message import Message\r\n\r\n\r\nclass ConditionalRouterComponent(Component):\r\n    display_name = \"If-Else\"\r\n    description = \"Routes an input message based on multiple text comparisons combined with AND/OR.\"\r\n    icon = \"split\"\r\n    name = \"ConditionalRouter\"\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        super().__init__(*args, **kwargs)\r\n        self.__iteration_updated = False\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"input_text\",\r\n            display_name=\"Text Input\",\r\n            info=\"The primary text input for the operation.\",\r\n        ),\r\n        MessageTextInput(\r\n            name=\"match_text\",\r\n            display_name=\"Match Text\",\r\n            info=\"Text to compare against. Add multiple entries for multiple conditions.\",\r\n            is_list=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"operator\",\r\n            display_name=\"Comparison Operator\",\r\n            options=[\"equals\", \"not equals\", \"contains\", \"starts with\", \"ends with\", \"matches regex\"],\r\n            info=\"The operator to use for all text comparisons.\",\r\n            value=\"equals\",\r\n            real_time_refresh=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"logical_operator\",\r\n            display_name=\"Logical Operator\",\r\n            options=[\"or\", \"and\"],\r\n            info=\"How to combine multiple conditions (OR: any match true, AND: all matches true).\",\r\n            value=\"or\",\r\n        ),\r\n        BoolInput(\r\n            name=\"case_sensitive\",\r\n            display_name=\"Case Sensitive\",\r\n            info=\"If true, the comparison will be case sensitive.\",\r\n            value=False,\r\n        ),\r\n        MessageInput(\r\n            name=\"message\",\r\n            display_name=\"Message\",\r\n            info=\"The message to pass through either route.\",\r\n            advanced=True,\r\n        ),\r\n        IntInput(\r\n            name=\"max_iterations\",\r\n            display_name=\"Max Iterations\",\r\n            info=\"The maximum number of iterations for the conditional router.\",\r\n            value=10,\r\n            advanced=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"default_route\",\r\n            display_name=\"Default Route\",\r\n            options=[\"true_result\", \"false_result\"],\r\n            info=\"The default route to take when max iterations are reached.\",\r\n            value=\"false_result\",\r\n            advanced=True,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(display_name=\"True\", name=\"true_result\", method=\"true_response\"),\r\n        Output(display_name=\"False\", name=\"false_result\", method=\"false_response\"),\r\n    ]\r\n\r\n    def _pre_run_setup(self):\r\n        self.__iteration_updated = False\r\n\r\n    def evaluate_single_condition(\r\n        self, input_text: str, match_text: str, operator: str, *, case_sensitive: bool\r\n    ) -> bool:\r\n        if not match_text:\r\n            return False\r\n            \r\n        if not case_sensitive and operator != \"matches regex\":\r\n            input_text = input_text.lower()\r\n            match_text = match_text.lower()\r\n\r\n        if operator == \"equals\":\r\n            return input_text == match_text\r\n        if operator == \"not equals\":\r\n            return input_text != match_text\r\n        if operator == \"contains\":\r\n            return match_text in input_text\r\n        if operator == \"starts with\":\r\n            return input_text.startswith(match_text)\r\n        if operator == \"ends with\":\r\n            return input_text.endswith(match_text)\r\n        if operator == \"matches regex\":\r\n            try:\r\n                return bool(re.match(match_text, input_text))\r\n            except re.error:\r\n                return False\r\n        return False\r\n\r\n    def evaluate_conditions(\r\n        self,\r\n        input_text: str,\r\n        match_texts: List[str],\r\n        operator: str,\r\n        logical_operator: str,\r\n        case_sensitive: bool,\r\n    ) -> bool:\r\n        if not match_texts:\r\n            return False\r\n            \r\n        results = [\r\n            self.evaluate_single_condition(input_text, match_text, operator, case_sensitive=case_sensitive)\r\n            for match_text in match_texts\r\n        ]\r\n        \r\n        return any(results) if logical_operator == \"or\" else all(results)\r\n\r\n    def iterate_and_stop_once(self, route_to_stop: str):\r\n        if not self.__iteration_updated:\r\n            self.update_ctx({f\"{self._id}_iteration\": self.ctx.get(f\"{self._id}_iteration\", 0) + 1})\r\n            self.__iteration_updated = True\r\n            if self.ctx.get(f\"{self._id}_iteration\", 0) >= self.max_iterations and route_to_stop == self.default_route:\r\n                route_to_stop = \"true_result\" if route_to_stop == \"false_result\" else \"false_result\"\r\n            self.stop(route_to_stop)\r\n\r\n    def true_response(self) -> Message:\r\n        result = self.evaluate_conditions(\r\n            self.input_text,\r\n            self.match_text,\r\n            self.operator,\r\n            self.logical_operator,\r\n            self.case_sensitive,\r\n        )\r\n        if result:\r\n            self.status = self.message\r\n            self.iterate_and_stop_once(\"false_result\")\r\n            return self.message\r\n        self.iterate_and_stop_once(\"true_result\")\r\n        return Message(content=\"\")\r\n\r\n    def false_response(self) -> Message:\r\n        result = self.evaluate_conditions(\r\n            self.input_text,\r\n            self.match_text,\r\n            self.operator,\r\n            self.logical_operator,\r\n            self.case_sensitive,\r\n        )\r\n        if not result:\r\n            self.status = self.message\r\n            self.iterate_and_stop_once(\"true_result\")\r\n            return self.message\r\n        self.iterate_and_stop_once(\"false_result\")\r\n        return Message(content=\"\")\r\n\r\n    def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None) -> dict:\r\n        if field_name == \"operator\":\r\n            if field_value == \"matches regex\":\r\n                if \"case_sensitive\" in build_config:\r\n                    del build_config[\"case_sensitive\"]\r\n            elif \"case_sensitive\" not in build_config:\r\n                case_sensitive_input = next(\r\n                    (input_field for input_field in self.inputs if input_field.name == \"case_sensitive\"), None\r\n                )\r\n                if case_sensitive_input:\r\n                    build_config[\"case_sensitive\"] = case_sensitive_input.to_dict()\r\n        return build_config","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"default_route":{"tool_mode":false,"trace_as_metadata":true,"options":["true_result","false_result"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"default_route","value":"false_result","display_name":"Default Route","advanced":true,"dynamic":false,"info":"The default route to take when max iterations are reached.","title_case":false,"type":"str","_input_type":"DropdownInput"},"input_text":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"input_text","value":"","display_name":"Text Input","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The primary text input for the operation.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"logical_operator":{"tool_mode":false,"trace_as_metadata":true,"options":["or","and"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"logical_operator","value":"or","display_name":"Logical Operator","advanced":false,"dynamic":false,"info":"How to combine multiple conditions (OR: any match true, AND: all matches true).","title_case":false,"type":"str","_input_type":"DropdownInput"},"match_text":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":true,"required":false,"placeholder":"","show":true,"name":"match_text","value":["🔇","🙉"],"display_name":"Match Text","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Text to compare against. Add multiple entries for multiple conditions.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"max_iterations":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"max_iterations","value":10,"display_name":"Max Iterations","advanced":true,"dynamic":false,"info":"The maximum number of iterations for the conditional router.","title_case":false,"type":"int","_input_type":"IntInput"},"message":{"trace_as_input":true,"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"message","value":"","display_name":"Message","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The message to pass through either route.","title_case":false,"type":"str","_input_type":"MessageInput"},"operator":{"tool_mode":false,"trace_as_metadata":true,"options":["equals","not equals","contains","starts with","ends with","matches regex"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"operator","value":"equals","display_name":"Comparison Operator","advanced":false,"dynamic":false,"info":"The operator to use for all text comparisons.","real_time_refresh":true,"title_case":false,"type":"str","_input_type":"DropdownInput"}},"description":"Routes an input message based on multiple text comparisons combined with AND/OR.","icon":"split","base_classes":["Message"],"display_name":"If-Else","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"true_result","display_name":"True","method":"true_response","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"false_result","display_name":"False","method":"false_response","value":"__UNDEFINED__","cache":true}],"field_order":["input_text","match_text","operator","logical_operator","case_sensitive","message","max_iterations","default_route"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14","official":false},"type":"CustomComponent","id":"CustomComponent-HKDjL"},"id":"CustomComponent-HKDjL","position":{"x":0,"y":0},"type":"genericNode"}],"viewport":{"x":1,"y":1,"zoom":1}},"is_component":true,"updated_at":"2025-01-06T17:56:24+00:00","webhook":false,"endpoint_name":null,"tags":null,"locked":false,"id":"c6de6202-f8d7-4d84-92c0-ad479cffb6da","user_id":"556fed76-1562-4baf-8a2e-ef9be2d194e4","folder_id":"22c5349e-60ef-45a2-a8ec-0debcd24f6dd"},{"name":"LF API TESTER","description":"Empowering Language Engineering.","icon":null,"icon_bg_color":null,"gradient":null,"data":{"nodes":[{"id":"CustomComponent-WimZ9","type":"genericNode","position":{"x":592.7899505766063,"y":193.32495881383858},"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Dict, Any\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\nclass WebhookPostComponent(Component):\r\n    display_name = \"Webhook POST\"\r\n    description = \"Sends a POST request to a specified URL with JSON data\"\r\n    icon = \"webhook\"\r\n    name = \"webhook_post\"\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"url\",\r\n            display_name=\"URL\",\r\n            info=\"The URL to send the POST request to\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"json_data\",\r\n            display_name=\"JSON Data\",\r\n            info=\"Valid JSON data to be sent in the request body (e.g., {\\\"key\\\": \\\"value\\\"})\",\r\n            required=True,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"response\",\r\n            display_name=\"Response\",\r\n            method=\"send_webhook\",\r\n        ),\r\n    ]\r\n\r\n    def send_webhook(self) -> Data:\r\n        \"\"\"\r\n        Send a POST request to the specified URL with JSON data.\r\n        \"\"\"\r\n        try:\r\n            # Log the URL (excluding any sensitive parts)\r\n            safe_url = self.url.split(\"?\")[0]  # Remove query parameters if any\r\n            self.log(f\"Preparing to send POST request to: {safe_url}\")\r\n            \r\n            # Parse JSON data\r\n            try:\r\n                payload = json.loads(self.json_data)\r\n                self.log(\"JSON data successfully parsed\")\r\n            except json.JSONDecodeError as e:\r\n                self.log(f\"Error parsing JSON data: {str(e)}\")\r\n                return Data(data={\r\n                    \"error\": \"Invalid JSON data\",\r\n                    \"details\": str(e),\r\n                    \"status\": \"ERROR\"\r\n                })\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"Content-Type\": \"application/json\"\r\n            }\r\n            \r\n            # Log the request details (excluding sensitive data)\r\n            self.log(\"Sending POST request with JSON payload\")\r\n            \r\n            # Send the POST request\r\n            response = requests.post(\r\n                self.url,\r\n                json=payload,\r\n                headers=headers\r\n            )\r\n            \r\n            self.log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Try to parse response as JSON\r\n            try:\r\n                response_data = response.json()\r\n                response_type = \"json\"\r\n            except json.JSONDecodeError:\r\n                response_data = response.text\r\n                response_type = \"text\"\r\n            \r\n            # Check if request was successful\r\n            response.raise_for_status()\r\n            \r\n            # Process response into consistent format\r\n            processed_response = {\r\n                \"status\": \"SUCCESS\",\r\n                \"status_code\": response.status_code,\r\n                \"response_type\": response_type,\r\n                \"response_data\": response_data,\r\n                \"headers\": dict(response.headers)\r\n            }\r\n            \r\n            self.log(\"Request completed successfully\")\r\n            \r\n            return Data(data=processed_response)\r\n\r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"Request failed: {str(e)}\"\r\n            self.log(f\"Error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\",\r\n                \"status_code\": getattr(e.response, 'status_code', None) if hasattr(e, 'response') else None\r\n            })\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"json_data":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"json_data","value":"{\"date\":\"2024-12-27 18:03:35\"}","display_name":"JSON Data","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Valid JSON data to be sent in the request body (e.g., {\"key\": \"value\"})","title_case":false,"type":"str","_input_type":"MessageTextInput"},"url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"url","value":"http://192.168.112.119/api/v1/webhook/auto_transcription","display_name":"URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The URL to send the POST request to","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Sends a POST request to a specified URL with JSON data","icon":"webhook","base_classes":["Data"],"display_name":"Webhook POST","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"response","display_name":"Response","method":"send_webhook","value":"__UNDEFINED__","cache":true}],"field_order":["url","json_data"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14"},"type":"CustomComponent","id":"CustomComponent-WimZ9"},"selected":false,"measured":{"width":320,"height":338},"dragging":false},{"id":"CustomComponent-UwXKT","type":"genericNode","position":{"x":984.9652037238118,"y":142.40541157129692},"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Dict, Any, Optional\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\nclass LangflowSyncComponent(Component):\r\n    display_name = \"Langflow Sync API\"\r\n    description = \"Makes a synchronous call to a Langflow API endpoint\"\r\n    icon = \"api\"\r\n    name = \"langflow_sync_api\"\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"url\",\r\n            display_name=\"API URL\",\r\n            info=\"Complete Langflow API URL (e.g., http://localhost:3000/api/v1/run/auto_transcription?stream=false)\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"input_value\",\r\n            display_name=\"Input Value\",\r\n            info=\"The input message to process\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"tweaks\",\r\n            display_name=\"Tweaks\",\r\n            info=\"Optional JSON object for component tweaks (e.g., {\\\"ComponentName-ID\\\": {}})\",\r\n            required=False,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"response\",\r\n            display_name=\"Response\",\r\n            method=\"call_langflow_api\",\r\n        ),\r\n    ]\r\n\r\n    def call_langflow_api(self) -> Data:\r\n        \"\"\"\r\n        Make a synchronous call to the Langflow API.\r\n        \"\"\"\r\n        try:\r\n            # Log the URL (excluding any sensitive parts)\r\n            safe_url = self.url.split(\"?\")[0]  # Remove query parameters if any\r\n            self.log(f\"Preparing to call Langflow API at: {safe_url}\")\r\n            \r\n            # Prepare the payload\r\n            payload = {\r\n                \"input_value\": self.input_value,\r\n                \"input_type\": \"chat\",\r\n                \"output_type\": \"chat\"\r\n            }\r\n\r\n            # Add tweaks if provided\r\n            if hasattr(self, 'tweaks') and self.tweaks:\r\n                try:\r\n                    tweaks_dict = json.loads(self.tweaks)\r\n                    if tweaks_dict:  # Only add if not empty\r\n                        payload[\"tweaks\"] = tweaks_dict\r\n                    self.log(\"Tweaks successfully parsed and added to payload\")\r\n                except json.JSONDecodeError as e:\r\n                    self.log(f\"Warning: Invalid tweaks JSON format: {str(e)}\")\r\n                    return Data(data={\r\n                        \"error\": \"Invalid tweaks JSON format\",\r\n                        \"details\": str(e),\r\n                        \"status\": \"ERROR\"\r\n                    })\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"Content-Type\": \"application/json\"\r\n            }\r\n            \r\n            # Log the request (excluding sensitive data)\r\n            safe_payload = {**payload}\r\n            if \"tweaks\" in safe_payload:\r\n                safe_payload[\"tweaks\"] = \"...\" # Hide tweaks details in logs\r\n            self.log(f\"Sending request with payload: {json.dumps(safe_payload)}\")\r\n            \r\n            # Send the POST request\r\n            response = requests.post(\r\n                self.url,\r\n                json=payload,\r\n                headers=headers\r\n            )\r\n            \r\n            self.log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Try to parse response as JSON\r\n            try:\r\n                response_data = response.json()\r\n                response_type = \"json\"\r\n            except json.JSONDecodeError:\r\n                response_data = response.text\r\n                response_type = \"text\"\r\n            \r\n            # Check if request was successful\r\n            response.raise_for_status()\r\n            \r\n            # Process response into consistent format\r\n            processed_response = {\r\n                \"status\": \"SUCCESS\",\r\n                \"status_code\": response.status_code,\r\n                \"response_type\": response_type,\r\n                \"response_data\": response_data,\r\n                \"headers\": dict(response.headers)\r\n            }\r\n            \r\n            self.log(\"API call completed successfully\")\r\n            \r\n            return Data(data=processed_response)\r\n\r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"API request failed: {str(e)}\"\r\n            self.log(f\"Error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\",\r\n                \"status_code\": getattr(e.response, 'status_code', None) if hasattr(e, 'response') else None\r\n            })\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"input_value":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"input_value","value":"2024-12-27 18:03:35","display_name":"Input Value","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The input message to process","title_case":false,"type":"str","_input_type":"MessageTextInput"},"tweaks":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"tweaks","value":"","display_name":"Tweaks","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Optional JSON object for component tweaks (e.g., {\"ComponentName-ID\": {}})","title_case":false,"type":"str","_input_type":"MessageTextInput"},"url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"url","value":"http://192.168.112.119/api/v1/run/auto_transcription?stream=false","display_name":"API URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Complete Langflow API URL (e.g., http://localhost:3000/api/v1/run/auto_transcription?stream=false)","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Makes a synchronous call to a Langflow API endpoint","icon":"api","base_classes":["Data"],"display_name":"Langflow Sync API","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"response","display_name":"Response","method":"call_langflow_api","value":"__UNDEFINED__","cache":true}],"field_order":["url","input_value","tweaks"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14"},"type":"CustomComponent","id":"CustomComponent-UwXKT"},"selected":true,"measured":{"width":320,"height":424},"dragging":false}],"edges":[],"viewport":{"x":-321.82771944090484,"y":-33.283032038212355,"zoom":0.8985368398648295}},"is_component":false,"updated_at":"2025-01-06T17:56:24+00:00","webhook":false,"endpoint_name":null,"tags":null,"locked":false,"id":"4558dc96-8255-48c9-9a64-ba7213e15fea","user_id":"556fed76-1562-4baf-8a2e-ef9be2d194e4","folder_id":"22c5349e-60ef-45a2-a8ec-0debcd24f6dd"},{"name":"PostgreSQL Query","description":"Execute arbitrary SQL queries against a PostgreSQL database","icon":null,"icon_bg_color":null,"gradient":null,"data":{"edges":[],"nodes":[{"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from typing import List\r\nfrom sqlalchemy import create_engine, text\r\nimport json\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import MultilineInput, StrInput, Output\r\nfrom langflow.schema import Data\r\n\r\nclass PostgreSQLQueryComponent(Component):\r\n    display_name = \"PostgreSQL Query\"\r\n    description = \"Execute arbitrary SQL queries against a PostgreSQL database\"\r\n    icon = \"database\"\r\n    name = \"postgresql_query\"\r\n\r\n    def __init__(self, **data):\r\n        super().__init__(**data)\r\n        self._engine = None\r\n\r\n    inputs = [\r\n        MultilineInput(\r\n            name=\"query\",\r\n            display_name=\"SQL Query\",\r\n            info=\"The SQL query to execute\",\r\n            required=True,\r\n            placeholder=\"Enter your SQL query here\"\r\n        ),\r\n        StrInput(\r\n            name=\"connection_string\",\r\n            display_name=\"Connection String\",\r\n            info=\"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)\",\r\n            required=True,\r\n        )\r\n    ]\r\n\r\n    outputs = [\r\n        Output(name=\"results\", display_name=\"Query Results\", method=\"execute_query\")\r\n    ]\r\n\r\n    def get_engine(self):\r\n        \"\"\"Get or create SQLAlchemy engine.\"\"\"\r\n        if not self._engine:\r\n            try:\r\n                self._engine = create_engine(\r\n                    self.connection_string,\r\n                    echo=False\r\n                )\r\n                \r\n                # Test the connection\r\n                with self._engine.connect() as conn:\r\n                    conn.execute(text(\"SELECT 1\"))\r\n                    \r\n            except Exception as e:\r\n                self.log(f\"Failed to create database engine: {str(e)}\")\r\n                raise ValueError(f\"Database connection failed: {str(e)}\") from e\r\n        return self._engine\r\n\r\n    def execute_query(self) -> List[Data]:\r\n        \"\"\"Execute the SQL query and return results.\"\"\"\r\n        try:\r\n            self.log(f\"Executing query: {self.query}\")\r\n            \r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                # Execute query\r\n                result = conn.execute(text(self.query))\r\n                \r\n                # Convert results to list of dictionaries\r\n                rows = [dict(zip(row._fields, row)) for row in result]\r\n                \r\n                # Return results as list of Data objects\r\n                return [\r\n                    Data(\r\n                        data={\r\n                            **row,\r\n                            \"__meta__\": {\r\n                                \"row_number\": i + 1,\r\n                                \"total_rows\": len(rows)\r\n                            }\r\n                        }\r\n                    )\r\n                    for i, row in enumerate(rows)\r\n                ]\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error executing query: {str(e)}\")\r\n            # Return error as Data object\r\n            return [Data(\r\n                data={\r\n                    \"error\": str(e),\r\n                    \"__meta__\": {\r\n                        \"status\": \"error\",\r\n                        \"message\": f\"Query execution failed: {str(e)}\"\r\n                    }\r\n                }\r\n            )]","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"connection_string":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"connection_string","value":"postgresql://evolution_user:Duassenha2024@192.168.112.131:5432/evolution_db","display_name":"Connection String","advanced":false,"dynamic":false,"info":"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)","title_case":false,"type":"str","_input_type":"StrInput"},"query":{"tool_mode":false,"trace_as_input":true,"multiline":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"Enter your SQL query here","show":true,"name":"query","value":"SELECT * FROM pg_stat_activity;","display_name":"SQL Query","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The SQL query to execute","title_case":false,"type":"str","_input_type":"MultilineInput"}},"description":"Execute arbitrary SQL queries against a PostgreSQL database","icon":"database","base_classes":["Data"],"display_name":"PostgreSQL Query","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"results","display_name":"Query Results","method":"execute_query","value":"__UNDEFINED__","cache":true}],"field_order":["query","connection_string"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14","official":false},"type":"CustomComponent","id":"CustomComponent-SU8P0"},"id":"CustomComponent-SU8P0","position":{"x":0,"y":0},"type":"genericNode"}],"viewport":{"x":1,"y":1,"zoom":1}},"is_component":true,"updated_at":"2025-01-06T17:56:24+00:00","webhook":false,"endpoint_name":null,"tags":null,"locked":false,"id":"7a1e147f-f6ec-437c-91f7-3f1bbefbe42e","user_id":"556fed76-1562-4baf-8a2e-ef9be2d194e4","folder_id":"22c5349e-60ef-45a2-a8ec-0debcd24f6dd"},{"name":"PostgreSQL Select","description":"Query data from PostgreSQL with dynamic table/field selection and pagination","icon":null,"icon_bg_color":null,"gradient":null,"data":{"edges":[],"nodes":[{"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from typing import Any, Dict, List, Optional\r\nfrom sqlalchemy import create_engine, text\r\nimport json\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    StrInput,\r\n    DropdownInput,\r\n    IntInput,\r\n    MultilineInput,\r\n    Output\r\n)\r\nfrom langflow.schema import Data\r\n\r\nclass PostgreSQLSelectComponent(Component):\r\n    display_name = \"PostgreSQL Select\"\r\n    description = \"Query data from PostgreSQL with dynamic table/field selection and pagination\"\r\n    icon = \"database\"\r\n    name = \"postgresql_select\"\r\n\r\n    def __init__(self, **data):\r\n        super().__init__(**data)\r\n        self._engine = None\r\n\r\n    inputs = [\r\n        StrInput(\r\n            name=\"connection_string\",\r\n            display_name=\"Connection String\",\r\n            info=\"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname) - do not include schema in URL\",\r\n            required=True\r\n        ),\r\n        DropdownInput(\r\n            name=\"schema\",\r\n            display_name=\"Schema\",\r\n            info=\"Database schema\",\r\n            required=True,\r\n            refresh_button=True,\r\n            options=[]\r\n        ),\r\n        DropdownInput(\r\n            name=\"table\",\r\n            display_name=\"Table\",\r\n            info=\"Database table\",\r\n            required=True,\r\n            refresh_button=True,\r\n            real_time_refresh=True,\r\n            options=[]\r\n        ),\r\n        MultilineInput(\r\n            name=\"fields\",\r\n            display_name=\"Fields\",\r\n            info=\"Fields to select, one per line\",\r\n            required=True,\r\n            placeholder=\"Enter fields one per line\"\r\n        ),\r\n        DropdownInput(\r\n            name=\"filter_field\",\r\n            display_name=\"Filter Field\",\r\n            info=\"Field to filter by\",\r\n            required=False,\r\n            options=[]\r\n        ),\r\n        DropdownInput(\r\n            name=\"filter_operator\",\r\n            display_name=\"Filter Operator\",\r\n            info=\"Filter operator\",\r\n            options=[\"=\", \">\", \"<\", \">=\", \"<=\", \"LIKE\", \"NOT LIKE\", \"IN\", \"NOT IN\"],\r\n            value=\"=\",\r\n            required=False\r\n        ),\r\n        MultilineInput(\r\n            name=\"filter_value\",\r\n            display_name=\"Filter Value\",\r\n            info=\"Filter value (use comma-separated values for IN/NOT IN)\",\r\n            required=False\r\n        ),\r\n        StrInput(\r\n            name=\"timestamp_field\",\r\n            display_name=\"Timestamp Field\",\r\n            info=\"Field name for timestamp filtering\",\r\n            required=False\r\n        ),\r\n        StrInput(\r\n            name=\"start_time\",\r\n            display_name=\"Start Time\",\r\n            info=\"Start time (YYYY-MM-DD HH:MM:SS)\",\r\n            required=False\r\n        ),\r\n        StrInput(\r\n            name=\"end_time\",\r\n            display_name=\"End Time\", \r\n            info=\"End time (YYYY-MM-DD HH:MM:SS)\",\r\n            required=False\r\n        ),\r\n        DropdownInput(\r\n            name=\"sort_field\",\r\n            display_name=\"Sort Field\",\r\n            info=\"Field to sort by\",\r\n            required=False,\r\n            options=[]\r\n        ),\r\n        DropdownInput(\r\n            name=\"sort_direction\",\r\n            display_name=\"Sort Direction\",\r\n            info=\"Sort direction\",\r\n            options=[\"ASC\", \"DESC\"],\r\n            value=\"ASC\",\r\n            required=False\r\n        ),\r\n        IntInput(\r\n            name=\"page_size\",\r\n            display_name=\"Page Size\",\r\n            info=\"Number of records per page\",\r\n            value=100,\r\n            required=True\r\n        ),\r\n        IntInput(\r\n            name=\"page\",\r\n            display_name=\"Page\",\r\n            info=\"Page number (starts at 1)\",\r\n            value=1,\r\n            required=True\r\n        )\r\n    ]\r\n\r\n    outputs = [\r\n        Output(name=\"results\", display_name=\"Results\", method=\"execute_query\"),\r\n    ]\r\n\r\n    def get_engine(self):\r\n        \"\"\"Get or create SQLAlchemy engine.\"\"\"\r\n        if not self._engine:\r\n            try:\r\n                self._engine = create_engine(\r\n                    self.connection_string,\r\n                    echo=False\r\n                )\r\n                \r\n                # Test the connection\r\n                with self._engine.connect() as conn:\r\n                    conn.execute(text(\"SELECT 1\"))\r\n                    \r\n            except Exception as e:\r\n                self.log(f\"Failed to create database engine: {str(e)}\")\r\n                raise ValueError(f\"Database connection failed: {str(e)}\") from e\r\n        return self._engine\r\n\r\n    def update_build_config(self, build_config: dict, field_value: Any, field_name: str | None = None) -> dict:\r\n        \"\"\"Update field options based on database structure.\"\"\"\r\n        try:\r\n            if field_name == \"schema\":\r\n                # On schema refresh or selection, get schema list and update tables\r\n                engine = self.get_engine()\r\n                with engine.connect() as conn:\r\n                    # Get schemas\r\n                    result = conn.execute(text(\"\"\"\r\n                        SELECT schema_name \r\n                        FROM information_schema.schemata \r\n                        WHERE schema_name NOT IN ('information_schema', 'pg_catalog', 'pg_toast')\r\n                        ORDER BY schema_name\r\n                    \"\"\"))\r\n                    schemas = [row[0] for row in result]\r\n                    build_config[\"schema\"][\"options\"] = schemas\r\n\r\n                    # If a schema is selected, update tables\r\n                    if field_value:\r\n                        result = conn.execute(\r\n                            text(\"SELECT table_name FROM information_schema.tables WHERE table_schema = :schema ORDER BY table_name\"),\r\n                            {\"schema\": field_value}\r\n                        )\r\n                        tables = [row[0] for row in result]\r\n                        build_config[\"table\"][\"options\"] = tables\r\n\r\n            elif field_name == \"table\" and field_value:\r\n                # On table selection, update field lists for dropdowns\r\n                schema_value = build_config[\"schema\"].get(\"value\")\r\n                if schema_value:\r\n                    engine = self.get_engine()\r\n                    with engine.connect() as conn:\r\n                        result = conn.execute(\r\n                            text(\"\"\"\r\n                                SELECT column_name \r\n                                FROM information_schema.columns \r\n                                WHERE table_schema = :schema AND table_name = :table \r\n                                ORDER BY ordinal_position\r\n                            \"\"\"),\r\n                            {\"schema\": schema_value, \"table\": field_value}\r\n                        )\r\n                        columns = [row[0] for row in result]\r\n                        build_config[\"filter_field\"][\"options\"] = columns\r\n                        build_config[\"sort_field\"][\"options\"] = columns\r\n\r\n            return build_config\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error updating build config: {str(e)}\")\r\n            raise ValueError(f\"Failed to update field options: {str(e)}\") from e\r\n\r\n    def build_query(self) -> tuple[str, dict]:\r\n        \"\"\"Build the SQL query and parameters.\"\"\"\r\n        try:\r\n            # Validate inputs\r\n            if not all([self.schema, self.table, self.fields]):\r\n                raise ValueError(\"Schema, table and fields are required\")\r\n            \r\n            # Build base query with multiple fields\r\n            fields = [f.strip() for f in self.fields.split('\\n') if f.strip()]\r\n            if not fields:\r\n                raise ValueError(\"At least one field must be entered\")\r\n                \r\n            field_list = \", \".join(f'\"{f}\"' for f in fields)\r\n            query = f'SELECT {field_list} FROM \"{self.schema}\".\"{self.table}\"'\r\n            params = {}\r\n\r\n            # Initialize WHERE conditions list\r\n            where_conditions = []\r\n            \r\n            # Add main filter if specified\r\n            if self.filter_field and self.filter_operator and self.filter_value:\r\n                if self.filter_operator in (\"IN\", \"NOT IN\"):\r\n                    values = [v.strip() for v in self.filter_value.split(\",\")]\r\n                    placeholders = \",\".join([f\":val{i}\" for i in range(len(values))])\r\n                    where_conditions.append(f'\"{self.filter_field}\" {self.filter_operator} ({placeholders})')\r\n                    params.update({f\"val{i}\": val for i, val in enumerate(values)})\r\n                else:\r\n                    where_conditions.append(f'\"{self.filter_field}\" {self.filter_operator} :filter_value')\r\n                    params[\"filter_value\"] = self.filter_value\r\n\r\n            # Add timestamp range if specified\r\n            if self.timestamp_field and (self.start_time or self.end_time):\r\n                if self.start_time:\r\n                    where_conditions.append(f'\"{self.timestamp_field}\" >= (extract(epoch from timestamp :start_time)::bigint)')\r\n                    params[\"start_time\"] = self.start_time\r\n                if self.end_time:\r\n                    where_conditions.append(f'\"{self.timestamp_field}\" <= (extract(epoch from timestamp :end_time)::bigint)')\r\n                    params[\"end_time\"] = self.end_time\r\n\r\n            # Combine WHERE conditions if any exist\r\n            if where_conditions:\r\n                query += \" WHERE \" + \" AND \".join(where_conditions)\r\n\r\n            # Add ORDER BY if sort is specified\r\n            if self.sort_field and self.sort_direction:\r\n                query += f' ORDER BY \"{self.sort_field}\" {self.sort_direction}'\r\n\r\n            # Add pagination\r\n            page = max(1, self.page)\r\n            page_size = max(1, self.page_size)\r\n            offset = (page - 1) * page_size\r\n            query += \" LIMIT :limit OFFSET :offset\"\r\n            params.update({\"limit\": page_size, \"offset\": offset})\r\n\r\n            return query, params\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error building query: {str(e)}\")\r\n            raise ValueError(f\"Failed to build query: {str(e)}\") from e\r\n\r\n    def execute_query(self) -> List[Data]:\r\n        \"\"\"Execute the query and return results.\"\"\"\r\n        try:\r\n            query, params = self.build_query()\r\n            self.log(f\"Executing query: {query} with params: {params}\")\r\n\r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                # Execute main query\r\n                result = conn.execute(text(query), params)\r\n                rows = [dict(zip(row._fields, row)) for row in result]\r\n\r\n                # Get total count for pagination info\r\n                count_query = f'SELECT COUNT(*) FROM \"{self.schema}\".\"{self.table}\"'\r\n                count_params = {}\r\n                where_conditions = []\r\n                \r\n                # Add main filter to count query\r\n                if self.filter_field and self.filter_operator and self.filter_value:\r\n                    if self.filter_operator in (\"IN\", \"NOT IN\"):\r\n                        values = [v.strip() for v in self.filter_value.split(\",\")]\r\n                        placeholders = \",\".join([f\":val{i}\" for i in range(len(values))])\r\n                        where_conditions.append(f'\"{self.filter_field}\" {self.filter_operator} ({placeholders})')\r\n                        count_params.update({f\"val{i}\": val for i, val in enumerate(values)})\r\n                    else:\r\n                        where_conditions.append(f'\"{self.filter_field}\" {self.filter_operator} :filter_value')\r\n                        count_params[\"filter_value\"] = self.filter_value\r\n\r\n                # Add timestamp range to count query\r\n                if self.timestamp_field and (self.start_time or self.end_time):\r\n                    if self.start_time:\r\n                        where_conditions.append(f'\"{self.timestamp_field}\" >= (extract(epoch from timestamp :start_time)::bigint)')\r\n                        count_params[\"start_time\"] = self.start_time\r\n                    if self.end_time:\r\n                        where_conditions.append(f'\"{self.timestamp_field}\" <= (extract(epoch from timestamp :end_time)::bigint)')\r\n                        count_params[\"end_time\"] = self.end_time\r\n\r\n                # Add WHERE clause to count query if conditions exist\r\n                if where_conditions:\r\n                    count_query += \" WHERE \" + \" AND \".join(where_conditions)\r\n\r\n                count_result = conn.execute(text(count_query), count_params)\r\n                count_row = count_result.first()\r\n                total_count = count_row[0] if count_row else 0\r\n\r\n            # Convert rows to Data objects with pagination info\r\n            return [\r\n                Data(\r\n                    data={\r\n                        **row,\r\n                        \"__meta__\": {\r\n                            \"total_records\": total_count,\r\n                            \"page\": self.page,\r\n                            \"page_size\": self.page_size,\r\n                            \"total_pages\": -(-total_count // self.page_size)  # Ceiling division\r\n                        }\r\n                    }\r\n                )\r\n                for row in rows\r\n            ]\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error executing query: {str(e)}\")\r\n            raise ValueError(f\"Query execution failed: {str(e)}\") from e","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"connection_string":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"connection_string","value":"postgresql://evolution_user:Duassenha2024@192.168.112.131:5432/evolution_db","display_name":"Connection String","advanced":false,"dynamic":false,"info":"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname) - do not include schema in URL","title_case":false,"type":"str","_input_type":"StrInput"},"end_time":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"end_time","value":"2024-12-26 23:59:59","display_name":"End Time","advanced":false,"dynamic":false,"info":"End time (YYYY-MM-DD HH:MM:SS)","title_case":false,"type":"str","_input_type":"StrInput"},"fields":{"tool_mode":false,"trace_as_input":true,"multiline":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"Enter fields one per line","show":true,"name":"fields","value":"messageTimestamp\nmessageType\nmessage\npushName\nkey","display_name":"Fields","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Fields to select, one per line","title_case":false,"type":"str","_input_type":"MultilineInput"},"filter_field":{"tool_mode":false,"trace_as_metadata":true,"options":["id","key","pushName","participant","messageType","message","contextInfo","source","messageTimestamp","chatwootMessageId","chatwootInboxId","chatwootConversationId","chatwootContactInboxSourceId","chatwootIsRead","instanceId","webhookUrl","sessionId","status"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"filter_field","value":"pushName","display_name":"Filter Field","advanced":false,"dynamic":false,"info":"Field to filter by","title_case":false,"type":"str","_input_type":"DropdownInput","load_from_db":false},"filter_operator":{"tool_mode":false,"trace_as_metadata":true,"options":["=",">","<",">=","<=","LIKE","NOT LIKE","IN","NOT IN"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"filter_operator","value":"=","display_name":"Filter Operator","advanced":false,"dynamic":false,"info":"Filter operator","title_case":false,"type":"str","_input_type":"DropdownInput"},"filter_value":{"tool_mode":false,"trace_as_input":true,"multiline":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"filter_value","value":"Stéfani","display_name":"Filter Value","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Filter value (use comma-separated values for IN/NOT IN)","title_case":false,"type":"str","_input_type":"MultilineInput"},"page":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":true,"placeholder":"","show":true,"name":"page","value":1,"display_name":"Page","advanced":false,"dynamic":false,"info":"Page number (starts at 1)","title_case":false,"type":"int","_input_type":"IntInput"},"page_size":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":true,"placeholder":"","show":true,"name":"page_size","value":1000,"display_name":"Page Size","advanced":false,"dynamic":false,"info":"Number of records per page","title_case":false,"type":"int","_input_type":"IntInput","load_from_db":false},"schema":{"tool_mode":false,"trace_as_metadata":true,"options":["public"],"combobox":false,"required":true,"placeholder":"","show":true,"name":"schema","value":"public","display_name":"Schema","advanced":false,"dynamic":false,"info":"Database schema","refresh_button":true,"title_case":false,"type":"str","_input_type":"DropdownInput","load_from_db":false},"sort_direction":{"tool_mode":false,"trace_as_metadata":true,"options":["ASC","DESC"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"sort_direction","value":"ASC","display_name":"Sort Direction","advanced":false,"dynamic":false,"info":"Sort direction","title_case":false,"type":"str","_input_type":"DropdownInput"},"sort_field":{"tool_mode":false,"trace_as_metadata":true,"options":["id","key","pushName","participant","messageType","message","contextInfo","source","messageTimestamp","chatwootMessageId","chatwootInboxId","chatwootConversationId","chatwootContactInboxSourceId","chatwootIsRead","instanceId","webhookUrl","sessionId","status"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"sort_field","value":"id","display_name":"Sort Field","advanced":false,"dynamic":false,"info":"Field to sort by","title_case":false,"type":"str","_input_type":"DropdownInput","load_from_db":false},"start_time":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"start_time","value":"2024-12-25 00:00:00","display_name":"Start Time","advanced":false,"dynamic":false,"info":"Start time (YYYY-MM-DD HH:MM:SS)","title_case":false,"type":"str","_input_type":"StrInput"},"table":{"tool_mode":false,"trace_as_metadata":true,"options":["Chat","Chatwoot","Contact","Dify","DifySetting","EvolutionBot","EvolutionBotSetting","Flowise","FlowiseSetting","Instance","IntegrationSession","IsOnWhatsapp","Label","Media","Message","MessageUpdate","OpenaiBot","OpenaiCreds","OpenaiSetting","Proxy","Pusher","Rabbitmq","Session","Setting","Sqs","Template","Typebot","TypebotSetting","Webhook","Websocket","_prisma_migrations"],"combobox":false,"required":true,"placeholder":"","show":true,"name":"table","value":"Message","display_name":"Table","advanced":false,"dynamic":false,"info":"Database table","real_time_refresh":true,"refresh_button":true,"title_case":false,"type":"str","_input_type":"DropdownInput","load_from_db":false},"timestamp_field":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"timestamp_field","value":"messageTimestamp","display_name":"Timestamp Field","advanced":false,"dynamic":false,"info":"Field name for timestamp filtering","title_case":false,"type":"str","_input_type":"StrInput"}},"description":"Query data from PostgreSQL with dynamic table/field selection and pagination","icon":"database","base_classes":["Data"],"display_name":"PostgreSQL Select","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"results","hidden":null,"display_name":"Results","method":"execute_query","value":"__UNDEFINED__","cache":true,"required_inputs":null}],"field_order":["connection_string","schema","table","fields","filter_field","filter_operator","filter_value","timestamp_field","start_time","end_time","sort_field","sort_direction","page_size","page"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14","official":false},"type":"CustomComponent","id":"CustomComponent-bQoON"},"id":"CustomComponent-bQoON","position":{"x":0,"y":0},"type":"genericNode"}],"viewport":{"x":1,"y":1,"zoom":1}},"is_component":true,"updated_at":"2025-01-06T17:56:24+00:00","webhook":false,"endpoint_name":null,"tags":null,"locked":false,"id":"afa87469-751e-4ccf-be0a-7085651c39ca","user_id":"556fed76-1562-4baf-8a2e-ef9be2d194e4","folder_id":"22c5349e-60ef-45a2-a8ec-0debcd24f6dd"},{"name":"Audio Transcriber","description":"Transcribe audio files from URLs and store results in database","icon":null,"icon_bg_color":null,"gradient":null,"data":{"edges":[],"nodes":[{"data":{"node":{"template":{"_type":"Component","input_data":{"tool_mode":false,"trace_as_metadata":true,"list":false,"trace_as_input":true,"required":true,"placeholder":"","show":true,"name":"input_data","value":"","display_name":"Input Data","advanced":false,"input_types":["Data"],"dynamic":false,"info":"Audio message data containing URL and metadata","title_case":false,"type":"other","_input_type":"DataInput"},"api_key":{"load_from_db":false,"required":true,"placeholder":"","show":true,"name":"api_key","value":null,"display_name":"API Key","advanced":false,"input_types":["Message"],"dynamic":false,"info":"API key for authentication","title_case":false,"password":true,"type":"str","_input_type":"SecretStrInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Dict, Any, Optional\r\nfrom sqlalchemy import create_engine, text\r\nimport uuid\r\nimport time\r\nimport string\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    SecretStrInput,\r\n    StrInput,\r\n    DataInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\ndef base36encode(number: int) -> str:\r\n    \"\"\"Convert an integer to base36 string.\"\"\"\r\n    alphabet = string.digits + string.ascii_lowercase\r\n    base36 = ''\r\n    \r\n    while number:\r\n        number, i = divmod(number, 36)\r\n        base36 = alphabet[i] + base36\r\n    \r\n    return base36 or '0'\r\n\r\n\r\nclass AudioProcessorComponent(Component):\r\n    display_name = \"Audio Transcriber\"\r\n    description = \"Transcribe audio files from URLs and store results in database\"\r\n    icon = \"mic\"\r\n    name = \"audio_transcriber\"\r\n\r\n    def __init__(self, **data):\r\n        super().__init__(**data)\r\n        self._engine = None\r\n\r\n    inputs = [\r\n        DataInput(\r\n            name=\"input_data\",\r\n            display_name=\"Input Data\",\r\n            info=\"Audio message data containing URL and metadata\",\r\n            required=True,\r\n            is_list=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"server_url\",\r\n            display_name=\"Server URL\",\r\n            info=\"Transcription server URL (e.g., http://localhost:4040)\",\r\n            required=True,\r\n        ),\r\n        StrInput(\r\n            name=\"connection_string\",\r\n            display_name=\"Connection String\",\r\n            info=\"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)\",\r\n            required=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"language\",\r\n            display_name=\"Language\",\r\n            info=\"Optional: Language code for transcription\",\r\n            required=False,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"api_key\",\r\n            display_name=\"API Key\",\r\n            info=\"API key for authentication\",\r\n            required=True,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"transcription\",\r\n            display_name=\"Transcription\",\r\n            method=\"transcribe_audio\",\r\n        ),\r\n    ]\r\n\r\n    def generate_cuid2(self) -> str:\r\n        \"\"\"Generate a CUID2-like ID.\"\"\"\r\n        # Get current time in milliseconds and convert to base36\r\n        timestamp = int(time.time() * 1000)\r\n        timestamp_b36 = base36encode(timestamp)\r\n\r\n        # Generate some random bytes\r\n        random_bytes = uuid.uuid4().bytes[:8]\r\n        random_b36 = base36encode(int.from_bytes(random_bytes, 'big'))\r\n\r\n        # Combine to match pattern length (25 chars)\r\n        cuid = f\"{timestamp_b36[:6]}{random_b36[:19]}\"\r\n        return cuid\r\n\r\n    def get_engine(self):\r\n        \"\"\"Get or create SQLAlchemy engine.\"\"\"\r\n        if not self._engine:\r\n            try:\r\n                self._engine = create_engine(\r\n                    self.connection_string,\r\n                    echo=False\r\n                )\r\n                \r\n                # Test the connection\r\n                with self._engine.connect() as conn:\r\n                    conn.execute(text(\"SELECT 1\"))\r\n                    \r\n            except Exception as e:\r\n                self.log(f\"Failed to create database engine: {str(e)}\")\r\n                raise ValueError(f\"Database connection failed: {str(e)}\") from e\r\n        return self._engine\r\n\r\n    def extract_message_id(self, key: Dict[str, Any]) -> Optional[str]:\r\n        \"\"\"Extract message ID from key dictionary.\"\"\"\r\n        try:\r\n            if isinstance(key, str):\r\n                key = json.loads(key)\r\n            # Return just the base ID without any _TRANS suffix\r\n            msg_id = key.get('id', '')\r\n            return msg_id.split('_')[0] if '_' in msg_id else msg_id\r\n        except Exception as e:\r\n            self.log(f\"Error extracting message ID: {str(e)}\")\r\n            return None\r\n\r\n    def check_existing_transcription(self, message_id: str) -> Optional[Dict[str, Any]]:\r\n        \"\"\"Check if transcription already exists for this message.\"\"\"\r\n        try:\r\n            query = '''\r\n                SELECT message\r\n                FROM public.\"Message\"\r\n                WHERE id = :transcription_id\r\n            '''\r\n            \r\n            # Create the transcription ID to check\r\n            transcription_id = f\"{message_id}_TRANS\"\r\n            \r\n            self.log(f\"Checking for existing transcription with ID: {transcription_id}\")\r\n                \r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                result = conn.execute(\r\n                    text(query),\r\n                    {\"transcription_id\": transcription_id}\r\n                )\r\n                row = result.fetchone()\r\n                \r\n                if row:\r\n                    self.log(f\"Found existing transcription for message {message_id}\")\r\n                    return row[0] if isinstance(row[0], dict) else json.loads(row[0])\r\n                    \r\n                self.log(f\"No existing transcription found for message {message_id}\")\r\n                return None\r\n                \r\n        except Exception as e:\r\n            self.log(f\"Error checking existing transcription: {str(e)}\")\r\n            raise ValueError(f\"Failed to check existing transcription: {str(e)}\") from e\r\n\r\n    def insert_transcription(self, transcription: str, original_data: Dict[str, Any]) -> None:\r\n        \"\"\"Insert transcription into database.\"\"\"\r\n        try:\r\n            # Prepare the message data\r\n            message_data = {\"conversation\": transcription}\r\n            \r\n            # Get original key data and message ID\r\n            original_key = original_data.get(\"key\", {})\r\n            if isinstance(original_key, str):\r\n                original_key = json.loads(original_key)\r\n                \r\n            original_id = original_key.get(\"id\")\r\n            if not original_id:\r\n                raise ValueError(\"No message ID found in original key\")\r\n                \r\n            # Create transcription ID by appending suffix\r\n            transcription_id = f\"{original_id}_TRANS\"\r\n            \r\n            # Create the key object for the transcription matching the ID\r\n            transcription_key = {\r\n                \"id\": transcription_id,\r\n                \"fromMe\": original_key.get(\"fromMe\", False),\r\n                \"remoteJid\": original_key.get(\"remoteJid\", \"\")\r\n            }\r\n            \r\n            query = '''\r\n                INSERT INTO public.\"Message\" (\r\n                    id,\r\n                    \"messageTimestamp\",\r\n                    \"messageType\",\r\n                    message,\r\n                    \"pushName\",\r\n                    key,\r\n                    \"instanceId\",\r\n                    \"contextInfo\",\r\n                    source\r\n                ) VALUES (\r\n                    :id,\r\n                    :timestamp,\r\n                    'audioTranscription',\r\n                    :message,\r\n                    :push_name,\r\n                    :key,\r\n                    :instance_id,\r\n                    :context_info,\r\n                    :source\r\n                )\r\n            '''\r\n            \r\n            params = {\r\n                \"id\": transcription_id,\r\n                \"timestamp\": original_data.get(\"messageTimestamp\"),\r\n                \"message\": json.dumps(message_data),\r\n                \"push_name\": original_data.get(\"pushName\"),\r\n                \"key\": json.dumps(transcription_key),\r\n                \"instance_id\": self.instance_id,\r\n                \"context_info\": json.dumps(original_data.get(\"contextInfo\")),\r\n                \"source\": original_data.get(\"source\", \"android\")  # Use original source or fallback to android\r\n            }\r\n            \r\n            self.log(\"Inserting transcription into database\")\r\n            \r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                conn.execute(text(query), params)\r\n                conn.commit()\r\n                \r\n            self.log(\"Successfully inserted transcription\")\r\n            \r\n        except Exception as e:\r\n            self.log(f\"Error inserting transcription: {str(e)}\")\r\n            raise ValueError(f\"Failed to insert transcription: {str(e)}\") from e\r\n\r\n    def transcribe_audio(self) -> Data:\r\n        \"\"\"\r\n        Transcribe audio and store in database.\r\n        \"\"\"\r\n        try:\r\n            # Debug logging for input data\r\n            self.log(f\"Input data object: {self.input_data}\")\r\n            self.log(f\"Input data type: {type(self.input_data)}\")\r\n            \r\n            # Handle list input\r\n            if isinstance(self.input_data, list):\r\n                if not self.input_data:\r\n                    self.log(\"Error: Empty input list\")\r\n                    return Data(data={\"error\": \"No input data provided\"})\r\n                    \r\n                input_item = self.input_data[0]\r\n                self.log(f\"Using first item from list: {input_item}\")\r\n            else:\r\n                input_item = self.input_data\r\n            \r\n            # Extract data from input item\r\n            if not hasattr(input_item, 'data'):\r\n                self.log(\"Error: input item has no 'data' attribute\")\r\n                return Data(data={\"error\": \"Invalid input data format\"})\r\n                \r\n            input_data = input_item.data\r\n            self.log(f\"Extracted input data: {input_data}\")\r\n            \r\n            if not input_data:\r\n                self.log(\"Error: Input data is empty\")\r\n                return Data(data={\"error\": \"Input data is empty\"})\r\n                \r\n            # Extract message ID and check for existing transcription\r\n            message_id = self.extract_message_id(input_data.get(\"key\", {}))\r\n            if not message_id:\r\n                raise ValueError(\"Could not extract message ID from input data\")\r\n                \r\n            # Check for existing transcription\r\n            existing = self.check_existing_transcription(message_id)\r\n            if existing:\r\n                self.log(\"Returning existing transcription\")\r\n                return Data(data=existing)\r\n\r\n            # Get audio URL\r\n            audio_url = input_data.get(\"parsed_url\")\r\n            if not audio_url:\r\n                raise ValueError(\"No audio URL found in input data\")\r\n\r\n            # Ensure server URL format\r\n            server_url = self.server_url.rstrip('/')\r\n            self.log(f\"Using server URL: {server_url}\")\r\n            \r\n            # Build API endpoint URL\r\n            url = f\"{server_url}/transcribe\"\r\n            self.log(f\"Full API endpoint URL: {url}\")\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n            }\r\n            self.log(\"Headers prepared (apikey hidden)\")\r\n\r\n            # Prepare payload\r\n            payload = {\r\n                \"url\": audio_url\r\n            }\r\n            \r\n            # Add optional language if provided\r\n            if hasattr(self, 'language') and self.language:\r\n                payload[\"language\"] = self.language\r\n            \r\n            # Log the request (excluding sensitive data)\r\n            request_info = {\r\n                \"url\": url,\r\n                \"headers\": {\r\n                    \"apikey\": \"***hidden***\"\r\n                },\r\n                \"payload\": payload\r\n            }\r\n            self.log(f\"Making request: {json.dumps(request_info, indent=2)}\")\r\n\r\n            # Make API request\r\n            response = requests.post(\r\n                url, \r\n                headers=headers,\r\n                data=payload\r\n            )\r\n            \r\n            self.log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Check for successful response\r\n            response.raise_for_status()\r\n            \r\n            # Parse response\r\n            data = response.json()\r\n            \r\n            # Extract transcription\r\n            transcription = data.get(\"transcription\", \"\")\r\n            if not transcription:\r\n                raise ValueError(\"No transcription found in response\")\r\n            \r\n            self.log(\"Successfully extracted transcription\")\r\n            \r\n            # Insert into database\r\n            self.insert_transcription(transcription, input_data)\r\n            \r\n            # Return transcription as data\r\n            return Data(data={\"conversation\": transcription})\r\n            \r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"API request failed: {str(e)}\"\r\n            self.log(f\"Request error: {error_msg}\")\r\n            return Data(data={\"error\": error_msg})\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Unexpected error: {error_msg}\")\r\n            return Data(data={\"error\": error_msg})","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"connection_string":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"connection_string","value":"postgresql://evolution_user:Duassenha2024@192.168.112.131:5432/evolution_db","display_name":"Connection String","advanced":false,"dynamic":false,"info":"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)","title_case":false,"type":"str","_input_type":"StrInput"},"instance_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"","display_name":"Instance ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"MessageTextInput"},"language":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"language","value":"","display_name":"Language","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Optional: Language code for transcription","title_case":false,"type":"str","_input_type":"MessageTextInput"},"server_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"server_url","value":"http://192.168.112.131:4040","display_name":"Server URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Transcription server URL (e.g., http://localhost:4040)","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Transcribe audio files from URLs and store results in database","icon":"mic","base_classes":["Data"],"display_name":"Audio Transcriber","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"transcription","display_name":"Transcription","method":"transcribe_audio","value":"__UNDEFINED__","cache":true}],"field_order":["input_data","instance_id","server_url","connection_string","language","api_key"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14","official":false},"type":"CustomComponent","id":"CustomComponent-Ah9NS"},"id":"CustomComponent-Ah9NS","position":{"x":0,"y":0},"type":"genericNode"}],"viewport":{"x":1,"y":1,"zoom":1}},"is_component":true,"updated_at":"2025-01-06T17:56:25+00:00","webhook":false,"endpoint_name":null,"tags":null,"locked":false,"id":"bdf8eb48-0df7-44c3-9c0c-29757e45cd62","user_id":"556fed76-1562-4baf-8a2e-ef9be2d194e4","folder_id":"22c5349e-60ef-45a2-a8ec-0debcd24f6dd"},{"name":"WhatsApp Audio to Message Automation 1D (prod)","description":"","icon":null,"icon_bg_color":null,"gradient":null,"data":{"nodes":[{"id":"CustomComponent-88JDQ","type":"genericNode","position":{"x":-3037.3774153953773,"y":-1027.247038058798},"data":{"node":{"template":{"_type":"Component","input_data":{"tool_mode":false,"trace_as_metadata":true,"list":true,"trace_as_input":true,"required":true,"placeholder":"","show":true,"name":"input_data","value":"","display_name":"Input Data","advanced":false,"input_types":["Data"],"dynamic":false,"info":"Audio message data containing URL and metadata","title_case":false,"type":"other","_input_type":"DataInput"},"api_key":{"load_from_db":true,"required":true,"placeholder":"","show":true,"name":"api_key","value":"audio_trans","display_name":"API Key","advanced":false,"input_types":["Message"],"dynamic":false,"info":"API key for authentication","title_case":false,"password":true,"type":"str","_input_type":"SecretStrInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Dict, Any, Optional, List\r\nfrom sqlalchemy import create_engine, text\r\nimport uuid\r\nimport time\r\nimport string\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    SecretStrInput,\r\n    StrInput,\r\n    DataInput,\r\n    IntInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data, Message\r\n\r\n\r\ndef base36encode(number: int) -> str:\r\n    \"\"\"Convert an integer to base36 string.\"\"\"\r\n    alphabet = string.digits + string.ascii_lowercase\r\n    base36 = ''\r\n    \r\n    while number:\r\n        number, i = divmod(number, 36)\r\n        base36 = alphabet[i] + base36\r\n    \r\n    return base36 or '0'\r\n\r\n\r\nclass AudioProcessorIteratorComponent(Component):\r\n    display_name = \"Audio Transcriber Iterator\"\r\n    description = \"Transcribe multiple audio files from URLs and store results in database\"\r\n    icon = \"mic\"\r\n    name = \"audio_transcriber_iterator\"\r\n\r\n    def __init__(self, **data):\r\n        super().__init__(**data)\r\n        self._engine = None\r\n        self._last_api_call = False  # Track last API call for delay logic\r\n\r\n    def __del__(self):\r\n        \"\"\"Cleanup method to dispose of the engine when component is destroyed.\"\"\"\r\n        self.cleanup()\r\n\r\n    def cleanup(self):\r\n        \"\"\"Cleanup database resources.\"\"\"\r\n        if self._engine:\r\n            self.log(\"Disposing database engine...\")\r\n            self._engine.dispose()\r\n            self._engine = None\r\n\r\n    inputs = [\r\n        IntInput(\r\n            name=\"transcription_delay\",\r\n            display_name=\"Transcription Delay\",\r\n            info=\"Delay in milliseconds between transcription API calls (for rate limiting)\",\r\n            advanced=True,\r\n            required=False,\r\n        ),\r\n        DataInput(\r\n            name=\"input_data\",\r\n            display_name=\"Input Data\",\r\n            info=\"Audio message data containing URL and metadata\",\r\n            required=True,\r\n            is_list=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"server_url\",\r\n            display_name=\"Server URL\",\r\n            info=\"Transcription server URL (e.g., http://localhost:4040)\",\r\n            required=True,\r\n        ),\r\n        StrInput(\r\n            name=\"connection_string\",\r\n            display_name=\"Connection String\",\r\n            info=\"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)\",\r\n            required=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"language\",\r\n            display_name=\"Language\",\r\n            info=\"Optional: Language code for transcription\",\r\n            required=False,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"api_key\",\r\n            display_name=\"API Key\",\r\n            info=\"API key for authentication\",\r\n            required=True,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"summary\",\r\n            display_name=\"Processing Summary\",\r\n            method=\"transcribe_audio\",\r\n            type=\"Message\"\r\n        ),\r\n    ]\r\n\r\n    def get_engine(self):\r\n        \"\"\"Get or create SQLAlchemy engine with proper connection pooling.\"\"\"\r\n        if not self._engine:\r\n            try:\r\n                self._engine = create_engine(\r\n                    self.connection_string,\r\n                    echo=False,\r\n                    pool_size=5,  # Set maximum pool size\r\n                    max_overflow=10,  # Allow up to 10 connections to overflow\r\n                    pool_timeout=30,  # Wait up to 30 seconds for available connection\r\n                    pool_recycle=3600,  # Recycle connections after 1 hour\r\n                    pool_pre_ping=True  # Verify connection is still valid before using\r\n                )\r\n                \r\n                # Test the connection\r\n                with self._engine.connect() as conn:\r\n                    conn.execute(text(\"SELECT 1\"))\r\n                    \r\n            except Exception as e:\r\n                self.log(f\"Failed to create database engine: {str(e)}\")\r\n                self.cleanup()  # Ensure cleanup on error\r\n                raise ValueError(f\"Database connection failed: {str(e)}\") from e\r\n        return self._engine\r\n\r\n    def extract_message_id(self, key: Dict[str, Any]) -> Optional[str]:\r\n        \"\"\"Extract message ID from key dictionary.\"\"\"\r\n        try:\r\n            if isinstance(key, str):\r\n                key = json.loads(key)\r\n            # Return just the base ID without any _TRANS suffix\r\n            msg_id = key.get('id', '')\r\n            return msg_id.split('_')[0] if '_' in msg_id else msg_id\r\n        except Exception as e:\r\n            self.log(f\"Error extracting message ID: {str(e)}\")\r\n            return None\r\n\r\n    def check_existing_transcription(self, message_id: str) -> Optional[Dict[str, Any]]:\r\n        \"\"\"Check if transcription already exists for this message.\"\"\"\r\n        try:\r\n            query = '''\r\n                SELECT message\r\n                FROM public.\"Message\"\r\n                WHERE id = :transcription_id\r\n            '''\r\n            \r\n            # Create the transcription ID to check\r\n            transcription_id = f\"{message_id}_TRANS\"\r\n            \r\n            self.log(f\"Checking for existing transcription with ID: {transcription_id}\")\r\n                \r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                result = conn.execute(\r\n                    text(query),\r\n                    {\"transcription_id\": transcription_id}\r\n                )\r\n                row = result.fetchone()\r\n                \r\n                if row:\r\n                    self.log(f\"Found existing transcription for message {message_id}\")\r\n                    return row[0] if isinstance(row[0], dict) else json.loads(row[0])\r\n                    \r\n                self.log(f\"No existing transcription found for message {message_id}\")\r\n                return None\r\n                \r\n        except Exception as e:\r\n            self.log(f\"Error checking existing transcription: {str(e)}\")\r\n            self.cleanup()  # Ensure cleanup on error\r\n            raise ValueError(f\"Failed to check existing transcription: {str(e)}\") from e\r\n\r\n    def insert_transcription(self, transcription: str, original_data: Dict[str, Any]) -> None:\r\n        \"\"\"Insert transcription into database.\"\"\"\r\n        try:\r\n            # Prepare the message data\r\n            message_data = {\"conversation\": transcription}\r\n            \r\n            # Get original key data and message ID\r\n            original_key = original_data.get(\"key\", {})\r\n            if isinstance(original_key, str):\r\n                original_key = json.loads(original_key)\r\n                \r\n            original_id = original_key.get(\"id\")\r\n            if not original_id:\r\n                raise ValueError(\"No message ID found in original key\")\r\n                \r\n            # Create transcription ID by appending suffix\r\n            transcription_id = f\"{original_id}_TRANS\"\r\n            \r\n            # Create the key object for the transcription matching the ID\r\n            transcription_key = {\r\n                \"id\": transcription_id,\r\n                \"fromMe\": original_key.get(\"fromMe\", False),\r\n                \"remoteJid\": original_key.get(\"remoteJid\", \"\")\r\n            }\r\n            \r\n            query = '''\r\n                INSERT INTO public.\"Message\" (\r\n                    id,\r\n                    \"messageTimestamp\",\r\n                    \"messageType\",\r\n                    message,\r\n                    \"pushName\",\r\n                    key,\r\n                    \"instanceId\",\r\n                    \"contextInfo\",\r\n                    source\r\n                ) VALUES (\r\n                    :id,\r\n                    :timestamp,\r\n                    'audioTranscription',\r\n                    :message,\r\n                    :push_name,\r\n                    :key,\r\n                    :instance_id,\r\n                    :context_info,\r\n                    :source\r\n                )\r\n            '''\r\n            \r\n            params = {\r\n                \"id\": transcription_id,\r\n                \"timestamp\": original_data.get(\"messageTimestamp\"),\r\n                \"message\": json.dumps(message_data),\r\n                \"push_name\": original_data.get(\"pushName\"),\r\n                \"key\": json.dumps(transcription_key),\r\n                \"instance_id\": self.instance_id,\r\n                \"context_info\": json.dumps(original_data.get(\"contextInfo\")),\r\n                \"source\": original_data.get(\"source\", \"android\")  # Use original source or fallback to android\r\n            }\r\n            \r\n            self.log(\"Inserting transcription into database\")\r\n            \r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                conn.execute(text(query), params)\r\n                conn.commit()\r\n                \r\n            self.log(\"Successfully inserted transcription\")\r\n            \r\n        except Exception as e:\r\n            self.log(f\"Error inserting transcription: {str(e)}\")\r\n            self.cleanup()  # Ensure cleanup on error\r\n            raise ValueError(f\"Failed to insert transcription: {str(e)}\") from e\r\n\r\n    def process_single_audio(self, input_data: Dict[str, Any]) -> Dict[str, Any]:\r\n        \"\"\"Process a single audio message.\"\"\"\r\n        try:\r\n            # Extract message ID and check for existing transcription\r\n            message_id = self.extract_message_id(input_data.get(\"key\", {}))\r\n            if not message_id:\r\n                return {\"error\": \"Could not extract message ID from input data\"}\r\n                \r\n            # Get audio URL\r\n            audio_url = input_data.get(\"parsed_url\")\r\n            if not audio_url:\r\n                return {\"error\": \"No audio URL found in input data\"}\r\n\r\n            # Add delay if there was a previous API call\r\n            delay_needed = hasattr(self, '_last_api_call') and self._last_api_call and hasattr(self, 'transcription_delay') and self.transcription_delay\r\n            if delay_needed:\r\n                delay_seconds = self.transcription_delay / 1000  # Convert ms to seconds\r\n                self.log(f\"Waiting {delay_seconds} seconds before next transcription request...\")\r\n                time.sleep(delay_seconds)\r\n            \r\n            # Reset API call flag\r\n            self._last_api_call = True\r\n            \r\n            # Ensure server URL format\r\n            server_url = self.server_url.rstrip('/')\r\n            self.log(f\"Using server URL: {server_url}\")\r\n            \r\n            # Build API endpoint URL\r\n            url = f\"{server_url}/transcribe\"\r\n            self.log(f\"Full API endpoint URL: {url}\")\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n            }\r\n            self.log(\"Headers prepared (apikey hidden)\")\r\n\r\n            # Prepare payload\r\n            payload = {\r\n                \"url\": audio_url\r\n            }\r\n            \r\n            # Add optional language if provided\r\n            if hasattr(self, 'language') and self.language:\r\n                payload[\"language\"] = self.language\r\n            \r\n            # Log the request (excluding sensitive data)\r\n            request_info = {\r\n                \"url\": url,\r\n                \"headers\": {\r\n                    \"apikey\": \"***hidden***\"\r\n                },\r\n                \"payload\": payload\r\n            }\r\n            self.log(f\"Making request: {json.dumps(request_info, indent=2)}\")\r\n\r\n            # Make API request\r\n            response = requests.post(\r\n                url, \r\n                headers=headers,\r\n                data=payload\r\n            )\r\n            \r\n            self.log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Check for successful response\r\n            response.raise_for_status()\r\n            \r\n            # Parse response\r\n            data = response.json()\r\n            \r\n            # Extract transcription\r\n            transcription = data.get(\"transcription\", \"\")\r\n            if not transcription:\r\n                return {\"error\": \"No transcription found in response\"}\r\n            \r\n            self.log(\"Successfully extracted transcription\")\r\n            \r\n            # Insert into database\r\n            self.insert_transcription(transcription, input_data)\r\n            \r\n            # Return success\r\n            return {\"success\": True, \"transcription\": transcription}\r\n            \r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"API request failed: {str(e)}\"\r\n            self.log(f\"Request error: {error_msg}\")\r\n            return {\"error\": error_msg}\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Unexpected error: {error_msg}\")\r\n            return {\"error\": error_msg}\r\n\r\n    def transcribe_audio(self) -> Message:\r\n        \"\"\"\r\n        Transcribe multiple audio files and store in database.\r\n        Returns a summary message of the processing run.\r\n        \"\"\"\r\n        start_time = time.time()\r\n        summary = {\r\n            \"total_attempted\": 0,\r\n            \"cached_transcriptions\": 0,\r\n            \"new_transcriptions\": 0,\r\n            \"failed_transcriptions\": 0,\r\n            \"errors\": []\r\n        }\r\n        \r\n        try:\r\n            if not self.input_data:\r\n                return Message(text=\"Error: No input data provided\")\r\n                \r\n            # Convert single item to list if necessary\r\n            input_list = self.input_data if isinstance(self.input_data, list) else [self.input_data]\r\n            summary[\"total_attempted\"] = len(input_list)\r\n            \r\n            # Process each item\r\n            for input_item in input_list:\r\n                try:\r\n                    if not hasattr(input_item, 'data'):\r\n                        summary[\"failed_transcriptions\"] += 1\r\n                        summary[\"errors\"].append(\"Invalid input data format - missing data attribute\")\r\n                        continue\r\n                        \r\n                    input_data = input_item.data\r\n                    if not input_data:\r\n                        summary[\"failed_transcriptions\"] += 1\r\n                        summary[\"errors\"].append(\"Empty input data\")\r\n                        continue\r\n                    \r\n                    # Check if transcription exists before processing\r\n                    message_id = self.extract_message_id(input_data.get(\"key\", {}))\r\n                    if not message_id:\r\n                        summary[\"failed_transcriptions\"] += 1\r\n                        summary[\"errors\"].append(\"Could not extract message ID\")\r\n                        continue\r\n                        \r\n                    existing = self.check_existing_transcription(message_id)\r\n                    if existing:\r\n                        summary[\"cached_transcriptions\"] += 1\r\n                        continue\r\n                    \r\n                    # Process new transcription\r\n                    result = self.process_single_audio(input_data)\r\n                    if \"error\" in result:\r\n                        summary[\"failed_transcriptions\"] += 1\r\n                        summary[\"errors\"].append(result[\"error\"])\r\n                    else:\r\n                        summary[\"new_transcriptions\"] += 1\r\n                \r\n                except Exception as e:\r\n                    summary[\"failed_transcriptions\"] += 1\r\n                    summary[\"errors\"].append(str(e))\r\n            \r\n            # Calculate timing and format summary message\r\n            total_time = time.time() - start_time\r\n            delay_info = f\"{self.transcription_delay}ms between calls\" if hasattr(self, 'transcription_delay') and self.transcription_delay else \"no delay\"\r\n            language_info = f\"Language: {self.language}\" if hasattr(self, 'language') and self.language else \"Language: auto-detect\"\r\n            \r\n            summary_text = [\r\n                f\"Transcription Processing Summary\",\r\n                f\"Time elapsed: {total_time:.2f} seconds\",\r\n                f\"Configuration: {delay_info}, {language_info}\",\r\n                f\"Total files attempted: {summary['total_attempted']}\",\r\n                f\"Cached transcriptions: {summary['cached_transcriptions']}\",\r\n                f\"New transcriptions: {summary['new_transcriptions']}\",\r\n                f\"Failed transcriptions: {summary['failed_transcriptions']}\"\r\n            ]\r\n            \r\n            if summary[\"errors\"]:\r\n                summary_text.append(\"\\nErrors encountered:\")\r\n                for error in summary[\"errors\"]:\r\n                    summary_text.append(f\"- {error}\")\r\n            \r\n            return Message(text=\"\\n\".join(summary_text))\r\n            \r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error in batch processing: {str(e)}\"\r\n            self.log(f\"Batch processing error: {error_msg}\")\r\n            self.cleanup()  # Ensure cleanup on error\r\n            return Message(text=f\"Critical Error: {error_msg}\")","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"connection_string":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"connection_string","value":"postgresql://evolution_user:Duassenha2024@192.168.112.131:5432/evolution_db","display_name":"Connection String","advanced":false,"dynamic":false,"info":"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)","title_case":false,"type":"str","_input_type":"StrInput"},"instance_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":true,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"felipe_evo_instance","display_name":"Instance ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"MessageTextInput"},"language":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"language","value":"","display_name":"Language","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Optional: Language code for transcription","title_case":false,"type":"str","_input_type":"MessageTextInput"},"server_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"server_url","value":"http://192.168.112.131:4040","display_name":"Server URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Transcription server URL (e.g., http://localhost:4040)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"transcription_delay":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"transcription_delay","value":1500,"display_name":"Transcription Delay","advanced":true,"dynamic":false,"info":"Delay in milliseconds between transcription API calls (for rate limiting)","title_case":false,"type":"int","_input_type":"IntInput","load_from_db":false}},"description":"Transcribe multiple audio files from URLs and store results in database","icon":"mic","base_classes":["Message"],"display_name":"Audio Transcriber Iterator","documentation":"","minimized":false,"custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"summary","display_name":"Processing Summary","method":"transcribe_audio","value":"__UNDEFINED__","cache":true}],"field_order":["transcription_delay","input_data","instance_id","server_url","connection_string","language","api_key"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev22"},"type":"CustomComponent","id":"CustomComponent-88JDQ"},"selected":false,"measured":{"width":320,"height":645},"dragging":false},{"id":"CustomComponent-8IQeG","type":"genericNode","position":{"x":-3506.8472731941656,"y":-1127.2687716050864},"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from typing import Any, Dict, List, Optional\r\nfrom sqlalchemy import create_engine, text\r\nimport json\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    StrInput,\r\n    MessageTextInput,\r\n    IntInput,\r\n    DropdownInput,\r\n    Output\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass AudioMessageQueryComponent(Component):\r\n    display_name = \"Evolution Audio Message Query\"\r\n    description = \"Query audio messages from Evolution database with different filter options\"\r\n    icon = \"mic\"\r\n    name = \"evolution_audio_message_query\"\r\n\r\n    def __init__(self, **data):\r\n        super().__init__(**data)\r\n        self._engine = None\r\n\r\n    def __del__(self):\r\n        \"\"\"Cleanup method to dispose of the engine when component is destroyed.\"\"\"\r\n        self.cleanup()\r\n\r\n    def cleanup(self):\r\n        \"\"\"Cleanup database resources.\"\"\"\r\n        if self._engine:\r\n            self.log(\"Disposing database engine...\")\r\n            self._engine.dispose()\r\n            self._engine = None\r\n\r\n    inputs = [\r\n        StrInput(\r\n            name=\"connection_string\",\r\n            display_name=\"Connection String\",\r\n            info=\"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)\",\r\n            required=True\r\n        ),\r\n        StrInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"message_id\",\r\n            display_name=\"Message ID\",\r\n            info=\"Find specific audio message by ID\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"remote_jid\",\r\n            display_name=\"Remote JID\",\r\n            info=\"Filter by remote JID (e.g., 555199999999@s.whatsapp.net)\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"push_name\",\r\n            display_name=\"Push Name\",\r\n            info=\"Filter by contact name\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"start_time\",\r\n            display_name=\"Start Time\",\r\n            info=\"Start time (YYYY-MM-DD HH:MM:SS)\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"end_time\",\r\n            display_name=\"End Time\", \r\n            info=\"End time (YYYY-MM-DD HH:MM:SS)\",\r\n            required=False\r\n        ),\r\n        DropdownInput(\r\n            name=\"sort_direction\",\r\n            display_name=\"Sort Direction\",\r\n            info=\"Sort direction by messageTimestamp\",\r\n            options=[\"ASC\", \"DESC\"],\r\n            value=\"DESC\",\r\n            required=False\r\n        ),\r\n        IntInput(\r\n            name=\"page_size\",\r\n            display_name=\"Page Size\",\r\n            info=\"Number of records per page\",\r\n            value=100,\r\n            required=True\r\n        ),\r\n        IntInput(\r\n            name=\"page\",\r\n            display_name=\"Page\",\r\n            info=\"Page number (starts at 1)\",\r\n            value=1,\r\n            required=True\r\n        )\r\n    ]\r\n\r\n    outputs = [\r\n        Output(name=\"messages\", display_name=\"Messages\", method=\"execute_query\"),\r\n        Output(name=\"parsed_urls\", display_name=\"Parsed URLs\", method=\"get_parsed_urls\")\r\n    ]\r\n\r\n    def parse_media_url(self, message: Any) -> str:\r\n        \"\"\"Extract and parse media URL from audio message.\"\"\"\r\n        try:\r\n            if isinstance(message, str):\r\n                message = json.loads(message)\r\n                \r\n            if \"mediaUrl\" in message:\r\n                url = message[\"mediaUrl\"]\r\n                if \"?\" in url:\r\n                    return url.split(\"?\")[0]\r\n                return url\r\n                \r\n            return None\r\n            \r\n        except Exception as e:\r\n            self.log(f\"Error parsing media URL: {str(e)}\")\r\n            return None\r\n\r\n    def get_engine(self):\r\n        \"\"\"Get or create SQLAlchemy engine.\"\"\"\r\n        if not self._engine:\r\n            try:\r\n                self._engine = create_engine(\r\n                    self.connection_string,\r\n                    echo=False,\r\n                    pool_size=5,  # Set maximum pool size\r\n                    max_overflow=10,  # Allow up to 10 connections to overflow\r\n                    pool_timeout=30,  # Wait up to 30 seconds for available connection\r\n                    pool_recycle=3600,  # Recycle connections after 1 hour\r\n                    pool_pre_ping=True  # Verify connection is still valid before using\r\n                )\r\n                \r\n                # Test the connection\r\n                with self._engine.connect() as conn:\r\n                    conn.execute(text(\"SELECT 1\"))\r\n                    \r\n            except Exception as e:\r\n                self.log(f\"Failed to create database engine: {str(e)}\")\r\n                self.cleanup()  # Ensure cleanup on error\r\n                raise ValueError(f\"Database connection failed: {str(e)}\") from e\r\n        return self._engine\r\n\r\n    def build_query(self) -> tuple[str, dict]:\r\n        \"\"\"Build the SQL query and parameters.\"\"\"\r\n        try:\r\n            query = '''\r\n                SELECT \r\n                    \"messageTimestamp\", \r\n                    \"messageType\", \r\n                    message, \r\n                    \"pushName\", \r\n                    key,\r\n                    \"contextInfo\"\r\n                FROM public.\"Message\"\r\n                WHERE \"messageType\" = 'audioMessage'\r\n                AND \"instanceId\" = :instance_id\r\n            '''\r\n            params = {\"instance_id\": self.instance_id}\r\n\r\n            # Add message ID filter if specified\r\n            if hasattr(self, 'message_id') and self.message_id:\r\n                query += \" AND key->>'id' = :message_id\"\r\n                params[\"message_id\"] = str(self.message_id).strip()\r\n\r\n            # Add remote JID filter if specified\r\n            if hasattr(self, 'remote_jid') and self.remote_jid:\r\n                query += \" AND key->>'remoteJid' = :remote_jid\"\r\n                params[\"remote_jid\"] = str(self.remote_jid).strip()\r\n\r\n            # Add push name filter if specified\r\n            if hasattr(self, 'push_name') and self.push_name:\r\n                query += ' AND \"pushName\" = :push_name'\r\n                params[\"push_name\"] = str(self.push_name).strip()\r\n\r\n            # Add timestamp range if specified\r\n            if hasattr(self, 'start_time') and self.start_time:\r\n                query += ' AND \"messageTimestamp\" >= (extract(epoch from timestamp :start_time)::bigint)'\r\n                params[\"start_time\"] = str(self.start_time).strip()\r\n            if hasattr(self, 'end_time') and self.end_time:\r\n                query += ' AND \"messageTimestamp\" <= (extract(epoch from timestamp :end_time)::bigint)'\r\n                params[\"end_time\"] = str(self.end_time).strip()\r\n\r\n            # Add ORDER BY\r\n            query += f' ORDER BY \"messageTimestamp\" {self.sort_direction}'\r\n\r\n            # Add pagination\r\n            page = max(1, self.page)\r\n            page_size = max(1, self.page_size)\r\n            offset = (page - 1) * page_size\r\n            query += \" LIMIT :limit OFFSET :offset\"\r\n            params.update({\"limit\": page_size, \"offset\": offset})\r\n\r\n            return query, params\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error building query: {str(e)}\")\r\n            raise ValueError(f\"Failed to build query: {str(e)}\") from e\r\n\r\n    def execute_query(self) -> List[Data]:\r\n        \"\"\"Execute the query and return results with all fields.\"\"\"\r\n        try:\r\n            query, params = self.build_query()\r\n            self.log(f\"Executing query: {query} with params: {params}\")\r\n\r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                # Execute main query\r\n                result = conn.execute(text(query), params)\r\n                rows = [dict(zip(row._fields, row)) for row in result]\r\n\r\n                # Get total count\r\n                count_query = '''\r\n                    SELECT COUNT(*) \r\n                    FROM public.\"Message\"\r\n                    WHERE \"messageType\" = 'audioMessage'\r\n                    AND \"instanceId\" = :instance_id\r\n                '''\r\n                count_params = {\"instance_id\": self.instance_id}\r\n                \r\n                # Add message ID filter to count query\r\n                if hasattr(self, 'message_id') and self.message_id:\r\n                    count_query += \" AND key->>'id' = :message_id\"\r\n                    count_params[\"message_id\"] = str(self.message_id).strip()\r\n\r\n                # Add remote JID filter to count query\r\n                if hasattr(self, 'remote_jid') and self.remote_jid:\r\n                    count_query += \" AND key->>'remoteJid' = :remote_jid\"\r\n                    count_params[\"remote_jid\"] = str(self.remote_jid).strip()\r\n\r\n                # Add push name filter to count query\r\n                if hasattr(self, 'push_name') and self.push_name:\r\n                    count_query += ' AND \"pushName\" = :push_name'\r\n                    count_params[\"push_name\"] = str(self.push_name).strip()\r\n\r\n                # Add timestamp range to count query\r\n                if hasattr(self, 'start_time') and self.start_time:\r\n                    count_query += ' AND \"messageTimestamp\" >= (extract(epoch from timestamp :start_time)::bigint)'\r\n                    count_params[\"start_time\"] = str(self.start_time).strip()\r\n                if hasattr(self, 'end_time') and self.end_time:\r\n                    count_query += ' AND \"messageTimestamp\" <= (extract(epoch from timestamp :end_time)::bigint)'\r\n                    count_params[\"end_time\"] = str(self.end_time).strip()\r\n\r\n                count_result = conn.execute(text(count_query), count_params)\r\n                total_count = count_result.scalar()\r\n\r\n            # Convert rows to Data objects with pagination info\r\n            return [\r\n                Data(\r\n                    data={\r\n                        \"messageTimestamp\": row[\"messageTimestamp\"],\r\n                        \"key\": row[\"key\"],\r\n                        \"pushName\": row[\"pushName\"],\r\n                        \"message\": row[\"message\"],\r\n                        \"contextInfo\": row[\"contextInfo\"],\r\n                        \"parsed_url\": self.parse_media_url(row[\"message\"]),\r\n                        \"__meta__\": {\r\n                            \"total_records\": total_count,\r\n                            \"page\": self.page,\r\n                            \"page_size\": self.page_size,\r\n                            \"total_pages\": -(-total_count // self.page_size)\r\n                        }\r\n                    }\r\n                )\r\n                for row in rows\r\n            ]\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error executing query: {str(e)}\")\r\n            self.cleanup()  # Ensure cleanup on error\r\n            raise ValueError(f\"Query execution failed: {str(e)}\") from e\r\n\r\n    def get_parsed_urls(self) -> List[Data]:\r\n        \"\"\"Return just the parsed URLs from the audio messages.\"\"\"\r\n        try:\r\n            query, params = self.build_query()\r\n            \r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                result = conn.execute(text(query), params)\r\n                rows = [dict(zip(row._fields, row)) for row in result]\r\n\r\n            # Return just the parsed URLs\r\n            return [\r\n                Data(\r\n                    data={\r\n                        \"url\": self.parse_media_url(row[\"message\"])\r\n                    }\r\n                )\r\n                for row in rows\r\n                if self.parse_media_url(row[\"message\"]) is not None\r\n            ]\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error getting parsed URLs: {str(e)}\")\r\n            self.cleanup()  # Ensure cleanup on error\r\n            raise ValueError(f\"Failed to get parsed URLs: {str(e)}\") from e","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"connection_string":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"connection_string","value":"postgresql://evolution_user:Duassenha2024@192.168.112.131:5432/evolution_db","display_name":"Connection String","advanced":false,"dynamic":false,"info":"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)","title_case":false,"type":"str","_input_type":"StrInput"},"end_time":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"end_time","value":"","display_name":"End Time","advanced":false,"input_types":["Message"],"dynamic":false,"info":"End time (YYYY-MM-DD HH:MM:SS)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"instance_id":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":true,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"felipe_evo_instance","display_name":"Instance ID","advanced":false,"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"StrInput"},"message_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"message_id","value":"","display_name":"Message ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Find specific audio message by ID","title_case":false,"type":"str","_input_type":"MessageTextInput"},"page":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":true,"placeholder":"","show":true,"name":"page","value":1,"display_name":"Page","advanced":false,"dynamic":false,"info":"Page number (starts at 1)","title_case":false,"type":"int","_input_type":"IntInput"},"page_size":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":true,"placeholder":"","show":true,"name":"page_size","value":100,"display_name":"Page Size","advanced":false,"dynamic":false,"info":"Number of records per page","title_case":false,"type":"int","_input_type":"IntInput"},"push_name":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"push_name","value":"","display_name":"Push Name","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Filter by contact name","title_case":false,"type":"str","_input_type":"MessageTextInput"},"remote_jid":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"remote_jid","value":"","display_name":"Remote JID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Filter by remote JID (e.g., 555199999999@s.whatsapp.net)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"sort_direction":{"tool_mode":false,"trace_as_metadata":true,"options":["ASC","DESC"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"sort_direction","value":"DESC","display_name":"Sort Direction","advanced":false,"dynamic":false,"info":"Sort direction by messageTimestamp","title_case":false,"type":"str","_input_type":"DropdownInput"},"start_time":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"start_time","value":"","display_name":"Start Time","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Start time (YYYY-MM-DD HH:MM:SS)","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Query audio messages from Evolution database with different filter options","icon":"mic","base_classes":["Data"],"display_name":"Evolution Audio Message Query","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"messages","display_name":"Messages","method":"execute_query","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"parsed_urls","display_name":"Parsed URLs","method":"get_parsed_urls","value":"__UNDEFINED__","cache":true}],"field_order":["connection_string","instance_id","message_id","remote_jid","push_name","start_time","end_time","sort_direction","page_size","page"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev22"},"type":"CustomComponent","id":"CustomComponent-8IQeG"},"selected":false,"measured":{"width":320,"height":1075},"dragging":false},{"id":"CurrentDate-BKLgt","type":"genericNode","position":{"x":-4004.651681146568,"y":-819.1368946144758},"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from datetime import datetime, timedelta\r\nfrom zoneinfo import ZoneInfo\r\nfrom langflow.custom import Component\r\nfrom langflow.io import DropdownInput, Output, MessageInput\r\nfrom langflow.schema.message import Message\r\n\r\nclass TimeIntervalComponent(Component):\r\n    display_name = \"Time Interval\"\r\n    description = \"Returns the start and end dates for different time intervals in the selected timezone.\"\r\n    icon = \"clock\"\r\n    name = \"TimeInterval\"\r\n    \r\n    inputs = [\r\n        DropdownInput(\r\n            name=\"timezone\",\r\n            display_name=\"Timezone\",\r\n            options=[\r\n                \"UTC\",\r\n                \"US/Eastern\", \r\n                \"US/Central\", \r\n                \"US/Mountain\",\r\n                \"US/Pacific\",\r\n                \"Europe/London\",\r\n                \"Europe/Paris\",\r\n                \"Europe/Berlin\",\r\n                \"Europe/Moscow\",\r\n                \"Asia/Tokyo\",\r\n                \"Asia/Shanghai\",\r\n                \"Asia/Singapore\",\r\n                \"Asia/Dubai\",\r\n                \"Australia/Sydney\",\r\n                \"Australia/Melbourne\",\r\n                \"Pacific/Auckland\",\r\n                \"America/Sao_Paulo\",\r\n                \"America/Mexico_City\",\r\n                \"America/Toronto\",\r\n                \"America/Vancouver\",\r\n                \"Africa/Cairo\",\r\n                \"Africa/Johannesburg\",\r\n                \"Atlantic/Reykjavik\",\r\n                \"Indian/Maldives\",\r\n                \"America/Bogota\",\r\n                \"America/Lima\",\r\n                \"America/Santiago\",\r\n                \"America/Buenos_Aires\",\r\n                \"America/Caracas\",\r\n                \"America/La_Paz\",\r\n                \"America/Montevideo\",\r\n                \"America/Asuncion\",\r\n                \"America/Cuiaba\",\r\n            ],\r\n            value=\"UTC\",\r\n            info=\"Select the timezone for the time interval calculation.\",\r\n            tool_mode=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"interval\",\r\n            display_name=\"Time Interval\",\r\n            options=[\r\n                \"1 hour\",\r\n                \"12 hours\",\r\n                \"1 day\",\r\n                \"7 days\",\r\n                \"15 days\",\r\n                \"1 month\"\r\n            ],\r\n            value=\"1 day\",\r\n            info=\"Select the time interval to calculate.\",\r\n            tool_mode=True,\r\n        ),\r\n        MessageInput(\r\n            name=\"webhook\",\r\n            display_name=\"Webhook Data\",\r\n            info=\"Message input used to trigger component execution. The message itself is not used.\",\r\n            tool_mode=True,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            display_name=\"Start Time\", \r\n            name=\"start_time\", \r\n            method=\"get_start_time\"\r\n        ),\r\n        Output(\r\n            display_name=\"End Time\", \r\n            name=\"end_time\", \r\n            method=\"get_end_time\"\r\n        ),\r\n    ]\r\n\r\n    def calculate_times(self):\r\n        \"\"\"Helper method to calculate interval times.\"\"\"\r\n        # Get current time in specified timezone\r\n        tz = ZoneInfo(self.timezone)\r\n        end_time = datetime.now(tz)\r\n        \r\n        # Calculate start time based on selected interval\r\n        interval_map = {\r\n            \"1 hour\": timedelta(hours=1),\r\n            \"12 hours\": timedelta(hours=12),\r\n            \"1 day\": timedelta(days=1),\r\n            \"7 days\": timedelta(days=7),\r\n            \"15 days\": timedelta(days=15),\r\n            \"1 month\": timedelta(days=30)  # Approximating month as 30 days\r\n        }\r\n        \r\n        interval = interval_map[self.interval]\r\n        start_time = end_time - interval\r\n        \r\n        # Format with full timestamp\r\n        start_formatted = start_time.strftime(\"%Y-%m-%d %H:%M:%S\")\r\n        end_formatted = end_time.strftime(\"%Y-%m-%d %H:%M:%S\")\r\n        \r\n        return start_formatted, end_formatted\r\n\r\n    def get_start_time(self) -> Message:\r\n        \"\"\"Return the start time for the selected interval.\"\"\"\r\n        try:\r\n            start_time, _ = self.calculate_times()\r\n            return Message(text=start_time)\r\n        except Exception as e:\r\n            return Message(text=f\"Error calculating start time: {str(e)}\")\r\n\r\n    def get_end_time(self) -> Message:\r\n        \"\"\"Return the end time for the selected interval.\"\"\"\r\n        try:\r\n            _, end_time = self.calculate_times()\r\n            return Message(text=end_time)\r\n        except Exception as e:\r\n            return Message(text=f\"Error calculating end time: {str(e)}\")","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"interval":{"tool_mode":true,"trace_as_metadata":true,"options":["1 hour","12 hours","1 day","7 days","15 days","1 month"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"interval","value":"1 day","display_name":"Time Interval","advanced":false,"dynamic":false,"info":"Select the time interval to calculate.","title_case":false,"type":"str","_input_type":"DropdownInput"},"timezone":{"tool_mode":true,"trace_as_metadata":true,"options":["UTC","US/Eastern","US/Central","US/Mountain","US/Pacific","Europe/London","Europe/Paris","Europe/Berlin","Europe/Moscow","Asia/Tokyo","Asia/Shanghai","Asia/Singapore","Asia/Dubai","Australia/Sydney","Australia/Melbourne","Pacific/Auckland","America/Sao_Paulo","America/Mexico_City","America/Toronto","America/Vancouver","Africa/Cairo","Africa/Johannesburg","Atlantic/Reykjavik","Indian/Maldives","America/Bogota","America/Lima","America/Santiago","America/Buenos_Aires","America/Caracas","America/La_Paz","America/Montevideo","America/Asuncion","America/Cuiaba"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"timezone","value":"America/Sao_Paulo","display_name":"Timezone","advanced":false,"dynamic":false,"info":"Select the timezone for the time interval calculation.","title_case":false,"type":"str","_input_type":"DropdownInput","load_from_db":false},"webhook":{"trace_as_input":true,"tool_mode":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"webhook","value":"","display_name":"Webhook Data","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Message input used to trigger component execution. The message itself is not used.","title_case":false,"type":"str","_input_type":"MessageInput"}},"description":"Returns the start and end dates for different time intervals in the selected timezone.","icon":"clock","base_classes":["Message"],"display_name":"Time Interval","documentation":"","minimized":false,"custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"start_time","display_name":"Start Time","method":"get_start_time","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"end_time","display_name":"End Time","method":"get_end_time","value":"__UNDEFINED__","cache":true}],"field_order":["timezone","interval","webhook"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false},"type":"CurrentDate","id":"CurrentDate-BKLgt"},"selected":true,"measured":{"width":320,"height":473},"dragging":false},{"id":"CustomComponent-QYtaC","type":"genericNode","position":{"x":-2115.9487371860782,"y":-625.6014384750142},"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from typing import List\r\nfrom sqlalchemy import create_engine, text\r\nimport json\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import MultilineInput, StrInput, Output\r\nfrom langflow.schema import Data\r\n\r\nclass PostgreSQLQueryComponent(Component):\r\n    display_name = \"PostgreSQL Query\"\r\n    description = \"Execute arbitrary SQL queries against a PostgreSQL database\"\r\n    icon = \"database\"\r\n    name = \"postgresql_query\"\r\n\r\n    def __init__(self, **data):\r\n        super().__init__(**data)\r\n        self._engine = None\r\n\r\n    inputs = [\r\n        MultilineInput(\r\n            name=\"query\",\r\n            display_name=\"SQL Query\",\r\n            info=\"The SQL query to execute\",\r\n            required=True,\r\n            placeholder=\"Enter your SQL query here\"\r\n        ),\r\n        StrInput(\r\n            name=\"connection_string\",\r\n            display_name=\"Connection String\",\r\n            info=\"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)\",\r\n            required=True,\r\n        )\r\n    ]\r\n\r\n    outputs = [\r\n        Output(name=\"results\", display_name=\"Query Results\", method=\"execute_query\")\r\n    ]\r\n\r\n    def get_engine(self):\r\n        \"\"\"Get or create SQLAlchemy engine.\"\"\"\r\n        if not self._engine:\r\n            try:\r\n                self._engine = create_engine(\r\n                    self.connection_string,\r\n                    echo=False\r\n                )\r\n                \r\n                # Test the connection\r\n                with self._engine.connect() as conn:\r\n                    conn.execute(text(\"SELECT 1\"))\r\n                    \r\n            except Exception as e:\r\n                self.log(f\"Failed to create database engine: {str(e)}\")\r\n                raise ValueError(f\"Database connection failed: {str(e)}\") from e\r\n        return self._engine\r\n\r\n    def execute_query(self) -> List[Data]:\r\n        \"\"\"Execute the SQL query and return results.\"\"\"\r\n        try:\r\n            self.log(f\"Executing query: {self.query}\")\r\n            \r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                # Execute query\r\n                result = conn.execute(text(self.query))\r\n                \r\n                # Convert results to list of dictionaries\r\n                rows = [dict(zip(row._fields, row)) for row in result]\r\n                \r\n                # Return results as list of Data objects\r\n                return [\r\n                    Data(\r\n                        data={\r\n                            **row,\r\n                            \"__meta__\": {\r\n                                \"row_number\": i + 1,\r\n                                \"total_rows\": len(rows)\r\n                            }\r\n                        }\r\n                    )\r\n                    for i, row in enumerate(rows)\r\n                ]\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error executing query: {str(e)}\")\r\n            # Return error as Data object\r\n            return [Data(\r\n                data={\r\n                    \"error\": str(e),\r\n                    \"__meta__\": {\r\n                        \"status\": \"error\",\r\n                        \"message\": f\"Query execution failed: {str(e)}\"\r\n                    }\r\n                }\r\n            )]","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"connection_string":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"connection_string","value":"postgresql://evolution_user:Duassenha2024@192.168.112.131:5432/evolution_db","display_name":"Connection String","advanced":false,"dynamic":false,"info":"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)","title_case":false,"type":"str","_input_type":"StrInput"},"query":{"tool_mode":false,"trace_as_input":true,"multiline":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"Enter your SQL query here","show":true,"name":"query","value":"SELECT * FROM pg_stat_activity;","display_name":"SQL Query","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The SQL query to execute","title_case":false,"type":"str","_input_type":"MultilineInput"}},"description":"Execute arbitrary SQL queries against a PostgreSQL database","icon":"database","base_classes":["Data"],"display_name":"PostgreSQL Query","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"results","display_name":"Query Results","method":"execute_query","value":"__UNDEFINED__","cache":true}],"field_order":["query","connection_string"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev22","official":false},"type":"CustomComponent","id":"CustomComponent-QYtaC"},"selected":false,"measured":{"width":320,"height":339},"dragging":false},{"id":"ParseData-Vfknv","type":"genericNode","position":{"x":-2565.0000000000005,"y":-685.8301595406849},"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from typing import Optional, Tuple, List\r\nfrom langflow.custom import Component\r\nfrom langflow.helpers.data import data_to_text, data_to_text_list\r\nfrom langflow.io import DataInput, MultilineInput, Output, StrInput\r\nfrom langflow.schema import Data\r\nfrom langflow.schema.message import Message\r\n\r\nclass ParseDataComponent(Component):\r\n    display_name = \"Parse Data\"\r\n    description = \"Convert Data into plain text following a specified template.\"\r\n    icon = \"braces\"\r\n    name = \"ParseData\"\r\n\r\n    inputs = [\r\n        MessageInput(\r\n            name=\"data\",\r\n            display_name=\"Data\",\r\n            info=\"The data to convert to text.\",\r\n            is_list=True,\r\n            required=False,\r\n        ),\r\n        MultilineInput(\r\n            name=\"template\",\r\n            display_name=\"Template\",\r\n            info=\"The template to use for formatting the data. \"\r\n            \"It can contain the keys {text}, {data} or any other key in the Data.\",\r\n            value=\"{text}\",\r\n            required=False,\r\n        ),\r\n        StrInput(\r\n            name=\"sep\",\r\n            display_name=\"Separator\",\r\n            advanced=True,\r\n            value=\"\\n\",\r\n            required=False,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            display_name=\"Text\",\r\n            name=\"text\",\r\n            info=\"Data as a single Message, with each input Data separated by Separator\",\r\n            method=\"parse_data\",\r\n        ),\r\n        Output(\r\n            display_name=\"Data List\",\r\n            name=\"data_list\",\r\n            info=\"Data as a list of new Data, each having `text` formatted by Template\",\r\n            method=\"parse_data_as_list\",\r\n        ),\r\n    ]\r\n\r\n    def _clean_args(self) -> Tuple[List[Data], str, str]:\r\n        \"\"\"Clean and validate input arguments with safe defaults.\"\"\"\r\n        try:\r\n            # Handle data input\r\n            data = getattr(self, 'data', None)\r\n            if data is None:\r\n                data = []\r\n            elif not isinstance(data, list):\r\n                data = [data]\r\n\r\n            # Handle template input\r\n            template = getattr(self, 'template', '{text}') or '{text}'\r\n\r\n            # Handle separator input\r\n            sep = getattr(self, 'sep', '\\n') or '\\n'\r\n\r\n            return data, template, sep\r\n        except Exception as e:\r\n            self.log(f\"Error in _clean_args: {str(e)}\")\r\n            return [], '{text}', '\\n'\r\n\r\n    def parse_data(self) -> Message:\r\n        \"\"\"Parse data into a single message.\"\"\"\r\n        try:\r\n            data, template, sep = self._clean_args()\r\n            if not data:\r\n                result_string = \"\"\r\n            else:\r\n                result_string = data_to_text(template, data, sep)\r\n            self.status = result_string\r\n            return Message(text=result_string)\r\n        except Exception as e:\r\n            self.log(f\"Error in parse_data: {str(e)}\")\r\n            return Message(text=\"\")\r\n\r\n    def parse_data_as_list(self) -> List[Data]:\r\n        \"\"\"Parse data into a list of Data objects.\"\"\"\r\n        try:\r\n            data, template, _ = self._clean_args()\r\n            if not data:\r\n                return []\r\n            \r\n            text_list, data_list = data_to_text_list(template, data)\r\n            for item, text in zip(data_list, text_list, strict=True):\r\n                item.set_text(text)\r\n            self.status = data_list\r\n            return data_list\r\n        except Exception as e:\r\n            self.log(f\"Error in parse_data_as_list: {str(e)}\")\r\n            return []","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"data":{"trace_as_input":true,"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":true,"required":false,"placeholder":"","show":true,"name":"data","value":"","display_name":"Data","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The data to convert to text.","title_case":false,"type":"str","_input_type":"MessageInput"},"sep":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"sep","value":"\n","display_name":"Separator","advanced":true,"dynamic":false,"info":"","title_case":false,"type":"str","_input_type":"StrInput"},"template":{"tool_mode":false,"trace_as_input":true,"multiline":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"template","value":"SELECT pg_terminate_backend(pid) FROM pg_stat_activity  WHERE datname = 'evolution_db'   AND state = 'idle'   AND pid <> pg_backend_pid();","display_name":"Template","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The template to use for formatting the data. It can contain the keys {text}, {data} or any other key in the Data.","title_case":false,"type":"str","_input_type":"MultilineInput"}},"description":"Convert Data into plain text following a specified template.","icon":"braces","base_classes":["Data","Message"],"display_name":"Parse Data","documentation":"","minimized":false,"custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"text","display_name":"Text","method":"parse_data","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"data_list","display_name":"Data List","method":"parse_data_as_list","value":"__UNDEFINED__","cache":true}],"field_order":["data","template","sep"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev22"},"type":"ParseData","id":"ParseData-Vfknv"},"selected":false,"measured":{"width":320,"height":387},"dragging":false},{"id":"ChatOutput-0cetX","type":"genericNode","position":{"x":-2538.6741114240444,"y":-186.78176494522904},"data":{"node":{"template":{"_type":"Component","background_color":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"background_color","value":"","display_name":"Background Color","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The background color of the icon.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"chat_icon":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"chat_icon","value":"","display_name":"Icon","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The icon of the message.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.io import DropdownInput, MessageInput, MessageTextInput, Output\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        MessageInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Message to be passed as output.\",\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            source_dict[\"source\"] = source\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n        background_color = self.background_color\n        text_color = self.text_color\n        if self.chat_icon:\n            icon = self.chat_icon\n        message = self.input_value if isinstance(self.input_value, Message) else Message(text=self.input_value)\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n        message.properties.icon = icon\n        message.properties.background_color = background_color\n        message.properties.text_color = text_color\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = await self.send_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"data_template":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"data_template","value":"{text}","display_name":"Data Template","advanced":true,"input_types":["Message"],"dynamic":false,"info":"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"input_value":{"trace_as_input":true,"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"input_value","value":"","display_name":"Text","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Message to be passed as output.","title_case":false,"type":"str","_input_type":"MessageInput"},"sender":{"tool_mode":false,"trace_as_metadata":true,"options":["Machine","User"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"sender","value":"Machine","display_name":"Sender Type","advanced":true,"dynamic":false,"info":"Type of sender.","title_case":false,"type":"str","_input_type":"DropdownInput"},"sender_name":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"sender_name","value":"AI","display_name":"Sender Name","advanced":true,"input_types":["Message"],"dynamic":false,"info":"Name of the sender.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"session_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"session_id","value":"","display_name":"Session ID","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The session ID of the chat. If empty, the current session ID parameter will be used.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"should_store_message":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"should_store_message","value":true,"display_name":"Store Messages","advanced":true,"dynamic":false,"info":"Store the message in the history.","title_case":false,"type":"bool","_input_type":"BoolInput"},"text_color":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"text_color","value":"","display_name":"Text Color","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The text color of the name","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Display a chat message in the Playground.","icon":"MessagesSquare","base_classes":["Message"],"display_name":"Chat Output","documentation":"","minimized":true,"custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"message","display_name":"Message","method":"message_response","value":"__UNDEFINED__","cache":true}],"field_order":["input_value","should_store_message","sender","sender_name","session_id","data_template","background_color","chat_icon","text_color"],"beta":false,"legacy":false,"edited":false,"metadata":{},"tool_mode":false,"category":"outputs","key":"ChatOutput","score":0.003169567463043492,"lf_version":"1.1.1.dev22"},"showNode":true,"type":"ChatOutput","id":"ChatOutput-0cetX"},"selected":false,"measured":{"width":320,"height":233},"dragging":false},{"id":"ChatInput-fiBS9","type":"genericNode","position":{"x":-4504.285596823217,"y":-724.2855968232166},"data":{"node":{"template":{"_type":"Component","files":{"trace_as_metadata":true,"file_path":"","fileTypes":["txt","md","mdx","csv","json","yaml","yml","xml","html","htm","pdf","docx","py","sh","sql","js","ts","tsx","jpg","jpeg","png","bmp","image"],"list":true,"required":false,"placeholder":"","show":true,"name":"files","value":"","display_name":"Files","advanced":true,"dynamic":false,"info":"Files to be sent with the message.","title_case":false,"type":"file","_input_type":"FileInput"},"background_color":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"background_color","value":"","display_name":"Background Color","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The background color of the icon.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"chat_icon":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"chat_icon","value":"","display_name":"Icon","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The icon of the message.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from langflow.base.data.utils import IMG_FILE_TYPES, TEXT_FILE_TYPES\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.io import (\n    DropdownInput,\n    FileInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n)\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_USER,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatInput(ChatComponent):\n    display_name = \"Chat Input\"\n    description = \"Get chat inputs from the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatInput\"\n    minimized = True\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            value=\"\",\n            info=\"Message to be passed as input.\",\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_USER,\n            info=\"Type of sender.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_USER,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        FileInput(\n            name=\"files\",\n            display_name=\"Files\",\n            file_types=TEXT_FILE_TYPES + IMG_FILE_TYPES,\n            info=\"Files to be sent with the message.\",\n            advanced=True,\n            is_list=True,\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Message\", name=\"message\", method=\"message_response\"),\n    ]\n\n    async def message_response(self) -> Message:\n        background_color = self.background_color\n        text_color = self.text_color\n        icon = self.chat_icon\n\n        message = await Message.create(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n            files=self.files,\n            properties={\n                \"background_color\": background_color,\n                \"text_color\": text_color,\n                \"icon\": icon,\n            },\n        )\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = await self.send_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"input_value":{"tool_mode":false,"trace_as_input":true,"multiline":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"input_value","value":"","display_name":"Text","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Message to be passed as input.","title_case":false,"type":"str","_input_type":"MultilineInput"},"sender":{"tool_mode":false,"trace_as_metadata":true,"options":["Machine","User"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"sender","value":"User","display_name":"Sender Type","advanced":true,"dynamic":false,"info":"Type of sender.","title_case":false,"type":"str","_input_type":"DropdownInput"},"sender_name":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"sender_name","value":"User","display_name":"Sender Name","advanced":true,"input_types":["Message"],"dynamic":false,"info":"Name of the sender.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"session_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"session_id","value":"","display_name":"Session ID","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The session ID of the chat. If empty, the current session ID parameter will be used.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"should_store_message":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"should_store_message","value":false,"display_name":"Store Messages","advanced":true,"dynamic":false,"info":"Store the message in the history.","title_case":false,"type":"bool","_input_type":"BoolInput"},"text_color":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"text_color","value":"","display_name":"Text Color","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The text color of the name","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Get chat inputs from the Playground.","icon":"MessagesSquare","base_classes":["Message"],"display_name":"Chat Input","documentation":"","minimized":true,"custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"message","display_name":"Message","method":"message_response","value":"__UNDEFINED__","cache":true}],"field_order":["input_value","should_store_message","sender","sender_name","session_id","files","background_color","chat_icon","text_color"],"beta":false,"legacy":false,"edited":false,"metadata":{},"tool_mode":false,"category":"inputs","key":"ChatInput","score":0.0020353564437605998},"showNode":true,"type":"ChatInput","id":"ChatInput-fiBS9"},"selected":false,"measured":{"width":320,"height":233},"dragging":false}],"edges":[{"source":"CustomComponent-8IQeG","sourceHandle":"{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-8IQeGœ,œnameœ:œmessagesœ,œoutput_typesœ:[œDataœ]}","target":"CustomComponent-88JDQ","targetHandle":"{œfieldNameœ:œinput_dataœ,œidœ:œCustomComponent-88JDQœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","data":{"targetHandle":{"fieldName":"input_data","id":"CustomComponent-88JDQ","inputTypes":["Data"],"type":"other"},"sourceHandle":{"dataType":"CustomComponent","id":"CustomComponent-8IQeG","name":"messages","output_types":["Data"]}},"id":"reactflow__edge-CustomComponent-8IQeG{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-8IQeGœ,œnameœ:œmessagesœ,œoutput_typesœ:[œDataœ]}-CustomComponent-88JDQ{œfieldNameœ:œinput_dataœ,œidœ:œCustomComponent-88JDQœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","animated":false,"className":""},{"source":"ParseData-Vfknv","sourceHandle":"{œdataTypeœ:œParseDataœ,œidœ:œParseData-Vfknvœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}","target":"CustomComponent-QYtaC","targetHandle":"{œfieldNameœ:œqueryœ,œidœ:œCustomComponent-QYtaCœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"query","id":"CustomComponent-QYtaC","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"ParseData","id":"ParseData-Vfknv","name":"text","output_types":["Message"]}},"id":"reactflow__edge-ParseData-Vfknv{œdataTypeœ:œParseDataœ,œidœ:œParseData-Vfknvœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-CustomComponent-QYtaC{œfieldNameœ:œqueryœ,œidœ:œCustomComponent-QYtaCœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","className":"","animated":false},{"source":"CustomComponent-88JDQ","sourceHandle":"{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-88JDQœ,œnameœ:œsummaryœ,œoutput_typesœ:[œMessageœ]}","target":"ParseData-Vfknv","targetHandle":"{œfieldNameœ:œdataœ,œidœ:œParseData-Vfknvœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"data","id":"ParseData-Vfknv","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"CustomComponent","id":"CustomComponent-88JDQ","name":"summary","output_types":["Message"]}},"id":"xy-edge__CustomComponent-88JDQ{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-88JDQœ,œnameœ:œsummaryœ,œoutput_typesœ:[œMessageœ]}-ParseData-Vfknv{œfieldNameœ:œdataœ,œidœ:œParseData-Vfknvœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","animated":false,"className":""},{"source":"CustomComponent-88JDQ","sourceHandle":"{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-88JDQœ,œnameœ:œsummaryœ,œoutput_typesœ:[œMessageœ]}","target":"ChatOutput-0cetX","targetHandle":"{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-0cetXœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"input_value","id":"ChatOutput-0cetX","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"CustomComponent","id":"CustomComponent-88JDQ","name":"summary","output_types":["Message"]}},"id":"xy-edge__CustomComponent-88JDQ{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-88JDQœ,œnameœ:œsummaryœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-0cetX{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-0cetXœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","animated":false,"className":""},{"source":"ChatInput-fiBS9","sourceHandle":"{œdataTypeœ:œChatInputœ,œidœ:œChatInput-fiBS9œ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}","target":"CurrentDate-BKLgt","targetHandle":"{œfieldNameœ:œwebhookœ,œidœ:œCurrentDate-BKLgtœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"webhook","id":"CurrentDate-BKLgt","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"ChatInput","id":"ChatInput-fiBS9","name":"message","output_types":["Message"]}},"id":"xy-edge__ChatInput-fiBS9{œdataTypeœ:œChatInputœ,œidœ:œChatInput-fiBS9œ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}-CurrentDate-BKLgt{œfieldNameœ:œwebhookœ,œidœ:œCurrentDate-BKLgtœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"},{"source":"CurrentDate-BKLgt","sourceHandle":"{œdataTypeœ:œCurrentDateœ,œidœ:œCurrentDate-BKLgtœ,œnameœ:œstart_timeœ,œoutput_typesœ:[œMessageœ]}","target":"CustomComponent-8IQeG","targetHandle":"{œfieldNameœ:œstart_timeœ,œidœ:œCustomComponent-8IQeGœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"start_time","id":"CustomComponent-8IQeG","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"CurrentDate","id":"CurrentDate-BKLgt","name":"start_time","output_types":["Message"]}},"id":"xy-edge__CurrentDate-BKLgt{œdataTypeœ:œCurrentDateœ,œidœ:œCurrentDate-BKLgtœ,œnameœ:œstart_timeœ,œoutput_typesœ:[œMessageœ]}-CustomComponent-8IQeG{œfieldNameœ:œstart_timeœ,œidœ:œCustomComponent-8IQeGœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"},{"source":"CurrentDate-BKLgt","sourceHandle":"{œdataTypeœ:œCurrentDateœ,œidœ:œCurrentDate-BKLgtœ,œnameœ:œend_timeœ,œoutput_typesœ:[œMessageœ]}","target":"CustomComponent-8IQeG","targetHandle":"{œfieldNameœ:œend_timeœ,œidœ:œCustomComponent-8IQeGœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"end_time","id":"CustomComponent-8IQeG","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"CurrentDate","id":"CurrentDate-BKLgt","name":"end_time","output_types":["Message"]}},"id":"xy-edge__CurrentDate-BKLgt{œdataTypeœ:œCurrentDateœ,œidœ:œCurrentDate-BKLgtœ,œnameœ:œend_timeœ,œoutput_typesœ:[œMessageœ]}-CustomComponent-8IQeG{œfieldNameœ:œend_timeœ,œidœ:œCustomComponent-8IQeGœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"}],"viewport":{"x":2833.348766680245,"y":865.612809533874,"zoom":0.5403493182615308}},"is_component":false,"updated_at":"2025-01-07T16:43:58+00:00","webhook":false,"endpoint_name":"audio_to_messages_1d","tags":null,"locked":null,"id":"9b6b04c3-64d0-4a02-a3ef-a9ae126b733d","user_id":"556fed76-1562-4baf-8a2e-ef9be2d194e4","folder_id":"22c5349e-60ef-45a2-a8ec-0debcd24f6dd"},{"name":"Webhook","description":"Defines a webhook input for the flow.","icon":null,"icon_bg_color":null,"gradient":null,"data":{"edges":[],"nodes":[{"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nfrom langflow.custom import Component\r\nfrom langflow.io import MultilineInput, Output\r\nfrom langflow.schema import Data\r\nfrom langflow.schema.message import Message\r\n\r\nclass WebhookComponent(Component):\r\n    display_name = \"Webhook\"\r\n    description = \"Defines a webhook input for the flow.\"\r\n    name = \"Webhook\"\r\n    icon = \"webhook\"\r\n    inputs = [\r\n        MultilineInput(\r\n            name=\"data\",\r\n            display_name=\"Payload\",\r\n            info=\"Receives a payload from external systems via HTTP POST.\",\r\n        )\r\n    ]\r\n    outputs = [\r\n        Output(display_name=\"Raw Payload\", name=\"raw_payload\", method=\"forward_raw_payload\", type=\"Message\"),\r\n        Output(display_name=\"Data\", name=\"output_data\", method=\"build_data\"),\r\n    ]\r\n\r\n    def forward_raw_payload(self) -> Message:\r\n        \"\"\"Forward the raw payload as a Message type.\"\"\"\r\n        if not self.data:\r\n            return Message(text=\"\")\r\n        return Message(text=self.data)\r\n\r\n    def build_data(self) -> Data:\r\n        message: str | Data = \"\"\r\n        if not self.data:\r\n            self.status = \"No data provided.\"\r\n            return Data(data={})\r\n        try:\r\n            body = json.loads(self.data or \"{}\")\r\n        except json.JSONDecodeError:\r\n            body = {\"payload\": self.data}\r\n            message = f\"Invalid JSON payload. Please check the format.\\n\\n{self.data}\"\r\n        data = Data(data=body)\r\n        if not message:\r\n            message = data\r\n        self.status = message\r\n        return data\r\n\r\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"data":{"tool_mode":false,"trace_as_input":true,"multiline":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"data","value":"{\"event\":\"messages.upsert\",\"instance\":\"felipe8888\",\"data\":{\"key\":{\"remoteJid\":\"5511986780008@s.whatsapp.net\",\"fromMe\":false,\"id\":\"16997DF673CF93D164860D01FA5F581F\"},\"pushName\":\"Felipe Rosa ॐ\",\"status\":\"DELIVERY_ACK\",\"message\":{\"audioMessage\":{\"url\":\"https://mmg.whatsapp.net/v/t62.7117-24/40139540_899149179051043_1472731274373192113_n.enc?ccb=11-4&oh=01_Q5AaIHU2CisduH6YEgcdHts_PlkVqceGqqRjJFfp1vPD8Oio&oe=6793FCB9&_nc_sid=5e03e0&mms3=true\",\"mimetype\":\"audio/ogg; codecs=opus\",\"fileSha256\":\"yevmILkR5OuEgatRPK1Z5zUm/w8HPtgqrSS2odt5ZzY=\",\"fileLength\":\"4716\",\"seconds\":2,\"ptt\":true,\"mediaKey\":\"9/rQOd1C0pL1dTfOUwOjcTCjAsrZq6W7EEifCqcRERw=\",\"fileEncSha256\":\"hqYTSi0AG/zbSDtUn7+V+V8x+9x+HBP0iYSZteRO9m4=\",\"directPath\":\"/v/t62.7117-24/40139540_899149179051043_1472731274373192113_n.enc?ccb=11-4&oh=01_Q5AaIHU2CisduH6YEgcdHts_PlkVqceGqqRjJFfp1vPD8Oio&oe=6793FCB9&_nc_sid=5e03e0\",\"mediaKeyTimestamp\":\"1735160700\",\"waveform\":\"AAwSEgwICw0QFhgYGx0dHh4dGRURDw4QFBgXFBArQ09TU1BRU1BMSSUWJzpIRj83MiwmMTUxKSIeMkRENiEPBw==\"},\"messageContextInfo\":{\"deviceListMetadata\":{\"senderKeyHash\":\"l4AAJmUuyVRZWA==\",\"senderTimestamp\":\"1734542287\",\"recipientKeyHash\":\"/JyvoTCTQQ/q8A==\",\"recipientTimestamp\":\"1734537386\"},\"deviceListMetadataVersion\":2,\"messageSecret\":\"b1IvVBZrUO8pxp4N8huOwYHOqs8CSTYyukAhCTZDf4I=\"},\"mediaUrl\":\"http://minio:9000/evolution/evolution-api/ec7ffe43-823e-4535-aa57-1ac66eff4f7f/5511986780008%40s.whatsapp.net/audioMessage/16997DF673CF93D164860D01FA5F581F.oga?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=minio_access%2F20241225%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20241225T210502Z&X-Amz-Expires=604800&X-Amz-SignedHeaders=host&X-Amz-Signature=b42aa20230db54e82e08e72cff83c2b9c951ae4570b1c16ef0b97ceb7dcc6457\"},\"contextInfo\":null,\"messageType\":\"audioMessage\",\"messageTimestamp\":1735160701,\"instanceId\":\"ec7ffe43-823e-4535-aa57-1ac66eff4f7f\",\"source\":\"android\"},\"destination\":\"http://192.168.112.129/api/v1/webhook/felipe-whats?api_key=sk-JXCm-YtyH8OwTzf5v_74EL799UQSXPs__a5jBptqmsc\",\"date_time\":\"2024-12-25T18:05:02.276Z\",\"sender\":\"5512982298888@s.whatsapp.net\",\"server_url\":\"http://evo.namastex.io\",\"apikey\":\"3CFB7C3D17A5-4DE7-BD57-1062D00B2FA3888\"}","display_name":"Payload","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Receives a payload from external systems via HTTP POST.","title_case":false,"type":"str","_input_type":"MultilineInput"}},"description":"Defines a webhook input for the flow.","icon":"webhook","base_classes":["Data","Message"],"display_name":"Webhook","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"raw_payload","display_name":"Raw Payload","method":"forward_raw_payload","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"output_data","display_name":"Data","method":"build_data","value":"__UNDEFINED__","cache":true}],"field_order":["data"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14","official":false},"type":"Webhook","id":"Webhook-Jc2Du"},"id":"Webhook-Jc2Du","position":{"x":0,"y":0},"type":"genericNode"}],"viewport":{"x":1,"y":1,"zoom":1}},"is_component":true,"updated_at":"2025-01-06T17:56:24+00:00","webhook":false,"endpoint_name":null,"tags":null,"locked":false,"id":"5959080b-ebb7-496d-8f14-eeb6bf648019","user_id":"556fed76-1562-4baf-8a2e-ef9be2d194e4","folder_id":"22c5349e-60ef-45a2-a8ec-0debcd24f6dd"},{"name":"Evolution Send Reaction","description":"Send a reaction emoji to a specific message using Evolution API","icon":null,"icon_bg_color":null,"gradient":null,"data":{"edges":[],"nodes":[{"data":{"node":{"template":{"_type":"Component","api_key":{"load_from_db":false,"required":true,"placeholder":"","show":true,"name":"api_key","value":null,"display_name":"API Key","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API key for authentication","title_case":false,"password":true,"type":"str","_input_type":"SecretStrInput"},"base_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"base_url","value":"","display_name":"API Base URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API base URL (e.g., http://example.com:8080)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Dict, Any\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    SecretStrInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass SendReactionComponent(Component):\r\n    display_name = \"Evolution Send Reaction\"\r\n    description = \"Send a reaction emoji to a specific message using Evolution API\"\r\n    icon = \"smile\"\r\n    name = \"send_reaction\"\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"base_url\",\r\n            display_name=\"API Base URL\",\r\n            info=\"Evolution API base URL (e.g., http://example.com:8080)\",\r\n            required=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"api_key\",\r\n            display_name=\"API Key\",\r\n            info=\"Evolution API key for authentication\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"remote_jid\",\r\n            display_name=\"Chat ID\",\r\n            info=\"WhatsApp chat ID (e.g., 5511999999999@s.whatsapp.net)\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"message_id\",\r\n            display_name=\"Message ID\",\r\n            info=\"ID of the message to react to\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"reaction\",\r\n            display_name=\"Reaction Emoji\",\r\n            info=\"Emoji to use as reaction (e.g., 👍, ❤️, 🔥)\",\r\n            required=True,\r\n            tool_mode=True,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"message\",\r\n            display_name=\"Message\",\r\n            method=\"send_reaction\",\r\n        ),\r\n    ]\r\n\r\n    def build_raw_payload(self) -> str:\r\n        \"\"\"\r\n        Build the request payload as a raw JSON string to avoid any escaping.\r\n        \"\"\"\r\n        # Construct JSON manually to avoid any escaping\r\n        payload = f'''{{\r\n    \"key\": {{\r\n        \"remoteJid\": \"{self.remote_jid}\",\r\n        \"fromMe\": true,\r\n        \"id\": \"{self.message_id}\"\r\n    }},\r\n    \"reaction\": \"{self.reaction}\"\r\n}}'''\r\n        \r\n        # Log payload (excluding sensitive data)\r\n        safe_payload = payload.replace(self.remote_jid, \"***hidden***\")\r\n        self.log(f\"Built payload: {safe_payload}\")\r\n        \r\n        return payload\r\n\r\n    def send_reaction(self) -> Data:\r\n        \"\"\"\r\n        Send a reaction to a message via Evolution API.\r\n        \"\"\"\r\n        try:\r\n            # Ensure base URL format\r\n            base_url = self.base_url.rstrip('/')\r\n            self.log(f\"Using base URL: {base_url}\")\r\n            \r\n            # Build API endpoint URL\r\n            url = f\"{base_url}/message/sendReaction/{self.instance_id}\"\r\n            self.log(f\"Full API endpoint URL: {url}\")\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n                \"Content-Type\": \"application/json\"\r\n            }\r\n            self.log(\"Headers prepared (apikey hidden)\")\r\n\r\n            # Build raw payload\r\n            payload = self.build_raw_payload()\r\n            \r\n            # Log the complete request (excluding sensitive data)\r\n            self.log(f\"Making request to: {url}\")\r\n            self.log(\"Headers: Content-Type: application/json, apikey: ***hidden***\")\r\n\r\n            # Make API request with raw payload\r\n            response = requests.post(\r\n                url, \r\n                headers=headers, \r\n                data=payload.encode('utf-8')\r\n            )\r\n            \r\n            self.log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Check for successful response\r\n            response.raise_for_status()\r\n            \r\n            # Parse response\r\n            data = response.json()\r\n            \r\n            # Process response into consistent format\r\n            processed_response = {\r\n                \"key\": data.get(\"key\", {}),\r\n                \"pushName\": data.get(\"pushName\", \"\"),\r\n                \"status\": data.get(\"status\"),\r\n                \"message\": data.get(\"message\", {}),\r\n                \"contextInfo\": data.get(\"contextInfo\"),\r\n                \"messageType\": data.get(\"messageType\"),\r\n                \"messageTimestamp\": data.get(\"messageTimestamp\"),\r\n                \"instanceId\": data.get(\"instanceId\"),\r\n                \"source\": data.get(\"source\")\r\n            }\r\n            \r\n            self.log(\"Reaction sent successfully\")\r\n            self.log(f\"Message status: {processed_response.get('status')}\")\r\n            \r\n            return Data(data=processed_response)\r\n\r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"API request failed: {str(e)}\"\r\n            self.log(f\"Request error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Unexpected error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"instance_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"felipe8888","display_name":"Instance ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"MessageTextInput"},"message_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"message_id","value":"3FD14CEFF7EF90F157FF","display_name":"Message ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"ID of the message to react to","title_case":false,"type":"str","_input_type":"MessageTextInput"},"reaction":{"tool_mode":true,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"reaction","value":"","display_name":"Reaction Emoji","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Emoji to use as reaction (e.g., 👍, ❤️, 🔥)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"remote_jid":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"remote_jid","value":"5511986780008@s.whatsapp.net","display_name":"Chat ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"WhatsApp chat ID (e.g., 5511999999999@s.whatsapp.net)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"tools_metadata":{"tool_mode":false,"is_list":true,"table_schema":{"columns":[{"name":"name","display_name":"Tool Name","sortable":false,"filterable":false,"type":"text","description":"Specify the name of the tool.","disable_edit":false,"edit_mode":"inline","formatter":"text"},{"name":"description","display_name":"Tool Description","sortable":false,"filterable":false,"type":"text","description":"Describe the purpose of the tool.","disable_edit":false,"edit_mode":"inline","formatter":"text"},{"name":"tags","display_name":"Tool Identifiers","sortable":false,"filterable":false,"type":"text","description":"These are the default identifiers for the tools and cannot be changed. Tool Name and Tool Description are the only editable fields.","disable_edit":true,"edit_mode":"inline","formatter":"text"}]},"trigger_text":"Open toolset","trigger_icon":"Hammer","table_options":{"block_add":true,"block_delete":true,"block_edit":true,"block_sort":true,"block_filter":true,"block_hide":true,"block_select":true,"hide_options":true,"field_parsers":{"name":"snake_case"}},"trace_as_metadata":true,"required":false,"placeholder":"","show":true,"name":"tools_metadata","value":[{"name":"send_reaction-send_reaction","description":"send_reaction(api_key: Message, base_url: Message, instance_id: Message, message_id: Message, reaction: Message, remote_jid: Message) - Send a reaction emoji to a specific message using Evolution API","tags":["send_reaction-send_reaction"]}],"display_name":"Toolset configuration","advanced":false,"dynamic":false,"info":"Use the table to configure the tools.","real_time_refresh":true,"title_case":false,"type":"table","_input_type":"TableInput"}},"description":"Send a reaction emoji to a specific message using Evolution API","icon":"smile","base_classes":["Data"],"display_name":"Evolution Send Reaction","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Tool"],"selected":"Tool","name":"component_as_tool","hidden":null,"display_name":"Toolset","method":"to_toolkit","value":"__UNDEFINED__","cache":true,"required_inputs":null}],"field_order":["base_url","api_key","instance_id","remote_jid","message_id","reaction"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":true,"lf_version":"1.1.1","official":false},"type":"CustomComponent","id":"CustomComponent-sOfEZ"},"id":"CustomComponent-sOfEZ","position":{"x":0,"y":0},"type":"genericNode"}],"viewport":{"x":1,"y":1,"zoom":1}},"is_component":true,"updated_at":"2025-01-06T17:56:24+00:00","webhook":false,"endpoint_name":null,"tags":null,"locked":false,"id":"131389fc-043c-4c58-b0fe-e5b7ec24157f","user_id":"556fed76-1562-4baf-8a2e-ef9be2d194e4","folder_id":"22c5349e-60ef-45a2-a8ec-0debcd24f6dd"},{"name":"Evolution Audio Message Query","description":"Query audio messages from Evolution database with different filter options","icon":null,"icon_bg_color":null,"gradient":null,"data":{"edges":[],"nodes":[{"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from typing import Any, Dict, List, Optional\r\nfrom sqlalchemy import create_engine, text\r\nimport json\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    StrInput,\r\n    MessageTextInput,\r\n    IntInput,\r\n    DropdownInput,\r\n    Output\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass AudioMessageQueryComponent(Component):\r\n    display_name = \"Evolution Audio Message Query\"\r\n    description = \"Query audio messages from Evolution database with different filter options\"\r\n    icon = \"mic\"\r\n    name = \"evolution_audio_message_query\"\r\n\r\n    def __init__(self, **data):\r\n        super().__init__(**data)\r\n        self._engine = None\r\n\r\n    inputs = [\r\n        StrInput(\r\n            name=\"connection_string\",\r\n            display_name=\"Connection String\",\r\n            info=\"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)\",\r\n            required=True\r\n        ),\r\n        StrInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"message_id\",\r\n            display_name=\"Message ID\",\r\n            info=\"Find specific audio message by ID\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"remote_jid\",\r\n            display_name=\"Remote JID\",\r\n            info=\"Filter by remote JID (e.g., 555199999999@s.whatsapp.net)\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"push_name\",\r\n            display_name=\"Push Name\",\r\n            info=\"Filter by contact name\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"start_time\",\r\n            display_name=\"Start Time\",\r\n            info=\"Start time (YYYY-MM-DD HH:MM:SS)\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"end_time\",\r\n            display_name=\"End Time\", \r\n            info=\"End time (YYYY-MM-DD HH:MM:SS)\",\r\n            required=False\r\n        ),\r\n        DropdownInput(\r\n            name=\"sort_direction\",\r\n            display_name=\"Sort Direction\",\r\n            info=\"Sort direction by messageTimestamp\",\r\n            options=[\"ASC\", \"DESC\"],\r\n            value=\"DESC\",\r\n            required=False\r\n        ),\r\n        IntInput(\r\n            name=\"page_size\",\r\n            display_name=\"Page Size\",\r\n            info=\"Number of records per page\",\r\n            value=100,\r\n            required=True\r\n        ),\r\n        IntInput(\r\n            name=\"page\",\r\n            display_name=\"Page\",\r\n            info=\"Page number (starts at 1)\",\r\n            value=1,\r\n            required=True\r\n        )\r\n    ]\r\n\r\n    outputs = [\r\n        Output(name=\"messages\", display_name=\"Messages\", method=\"execute_query\"),\r\n        Output(name=\"parsed_urls\", display_name=\"Parsed URLs\", method=\"get_parsed_urls\")\r\n    ]\r\n\r\n    def parse_media_url(self, message: Any) -> str:\r\n        \"\"\"Extract and parse media URL from audio message.\"\"\"\r\n        try:\r\n            if isinstance(message, str):\r\n                message = json.loads(message)\r\n                \r\n            if \"mediaUrl\" in message:\r\n                url = message[\"mediaUrl\"]\r\n                if \"?\" in url:\r\n                    return url.split(\"?\")[0]\r\n                return url\r\n                \r\n            return None\r\n            \r\n        except Exception as e:\r\n            self.log(f\"Error parsing media URL: {str(e)}\")\r\n            return None\r\n\r\n    def get_engine(self):\r\n        \"\"\"Get or create SQLAlchemy engine.\"\"\"\r\n        if not self._engine:\r\n            try:\r\n                self._engine = create_engine(\r\n                    self.connection_string,\r\n                    echo=False\r\n                )\r\n                \r\n                # Test the connection\r\n                with self._engine.connect() as conn:\r\n                    conn.execute(text(\"SELECT 1\"))\r\n                    \r\n            except Exception as e:\r\n                self.log(f\"Failed to create database engine: {str(e)}\")\r\n                raise ValueError(f\"Database connection failed: {str(e)}\") from e\r\n        return self._engine\r\n\r\n    def build_query(self) -> tuple[str, dict]:\r\n        \"\"\"Build the SQL query and parameters.\"\"\"\r\n        try:\r\n            query = '''\r\n                SELECT \r\n                    \"messageTimestamp\", \r\n                    \"messageType\", \r\n                    message, \r\n                    \"pushName\", \r\n                    key,\r\n                    \"contextInfo\"\r\n                FROM public.\"Message\"\r\n                WHERE \"messageType\" = 'audioMessage'\r\n                AND \"instanceId\" = :instance_id\r\n            '''\r\n            params = {\"instance_id\": self.instance_id}\r\n\r\n            # Add message ID filter if specified\r\n            if hasattr(self, 'message_id') and self.message_id:\r\n                query += \" AND key->>'id' = :message_id\"\r\n                params[\"message_id\"] = str(self.message_id).strip()\r\n\r\n            # Add remote JID filter if specified\r\n            if hasattr(self, 'remote_jid') and self.remote_jid:\r\n                query += \" AND key->>'remoteJid' = :remote_jid\"\r\n                params[\"remote_jid\"] = str(self.remote_jid).strip()\r\n\r\n            # Add push name filter if specified\r\n            if hasattr(self, 'push_name') and self.push_name:\r\n                query += ' AND \"pushName\" = :push_name'\r\n                params[\"push_name\"] = str(self.push_name).strip()\r\n\r\n            # Add timestamp range if specified\r\n            if hasattr(self, 'start_time') and self.start_time:\r\n                query += ' AND \"messageTimestamp\" >= (extract(epoch from timestamp :start_time)::bigint)'\r\n                params[\"start_time\"] = str(self.start_time).strip()\r\n            if hasattr(self, 'end_time') and self.end_time:\r\n                query += ' AND \"messageTimestamp\" <= (extract(epoch from timestamp :end_time)::bigint)'\r\n                params[\"end_time\"] = str(self.end_time).strip()\r\n\r\n            # Add ORDER BY\r\n            query += f' ORDER BY \"messageTimestamp\" {self.sort_direction}'\r\n\r\n            # Add pagination\r\n            page = max(1, self.page)\r\n            page_size = max(1, self.page_size)\r\n            offset = (page - 1) * page_size\r\n            query += \" LIMIT :limit OFFSET :offset\"\r\n            params.update({\"limit\": page_size, \"offset\": offset})\r\n\r\n            return query, params\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error building query: {str(e)}\")\r\n            raise ValueError(f\"Failed to build query: {str(e)}\") from e\r\n\r\n    def execute_query(self) -> List[Data]:\r\n        \"\"\"Execute the query and return results with all fields.\"\"\"\r\n        try:\r\n            query, params = self.build_query()\r\n            self.log(f\"Executing query: {query} with params: {params}\")\r\n\r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                # Execute main query\r\n                result = conn.execute(text(query), params)\r\n                rows = [dict(zip(row._fields, row)) for row in result]\r\n\r\n                # Get total count\r\n                count_query = '''\r\n                    SELECT COUNT(*) \r\n                    FROM public.\"Message\"\r\n                    WHERE \"messageType\" = 'audioMessage'\r\n                    AND \"instanceId\" = :instance_id\r\n                '''\r\n                count_params = {\"instance_id\": self.instance_id}\r\n                \r\n                # Add message ID filter to count query\r\n                if hasattr(self, 'message_id') and self.message_id:\r\n                    count_query += \" AND key->>'id' = :message_id\"\r\n                    count_params[\"message_id\"] = str(self.message_id).strip()\r\n\r\n                # Add remote JID filter to count query\r\n                if hasattr(self, 'remote_jid') and self.remote_jid:\r\n                    count_query += \" AND key->>'remoteJid' = :remote_jid\"\r\n                    count_params[\"remote_jid\"] = str(self.remote_jid).strip()\r\n\r\n                # Add push name filter to count query\r\n                if hasattr(self, 'push_name') and self.push_name:\r\n                    count_query += ' AND \"pushName\" = :push_name'\r\n                    count_params[\"push_name\"] = str(self.push_name).strip()\r\n\r\n                # Add timestamp range to count query\r\n                if hasattr(self, 'start_time') and self.start_time:\r\n                    count_query += ' AND \"messageTimestamp\" >= (extract(epoch from timestamp :start_time)::bigint)'\r\n                    count_params[\"start_time\"] = str(self.start_time).strip()\r\n                if hasattr(self, 'end_time') and self.end_time:\r\n                    count_query += ' AND \"messageTimestamp\" <= (extract(epoch from timestamp :end_time)::bigint)'\r\n                    count_params[\"end_time\"] = str(self.end_time).strip()\r\n\r\n                count_result = conn.execute(text(count_query), count_params)\r\n                total_count = count_result.scalar()\r\n\r\n            # Convert rows to Data objects with pagination info\r\n            return [\r\n                Data(\r\n                    data={\r\n                        \"messageTimestamp\": row[\"messageTimestamp\"],\r\n                        \"key\": row[\"key\"],\r\n                        \"pushName\": row[\"pushName\"],\r\n                        \"message\": row[\"message\"],\r\n                        \"contextInfo\": row[\"contextInfo\"],\r\n                        \"parsed_url\": self.parse_media_url(row[\"message\"]),\r\n                        \"__meta__\": {\r\n                            \"total_records\": total_count,\r\n                            \"page\": self.page,\r\n                            \"page_size\": self.page_size,\r\n                            \"total_pages\": -(-total_count // self.page_size)\r\n                        }\r\n                    }\r\n                )\r\n                for row in rows\r\n            ]\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error executing query: {str(e)}\")\r\n            raise ValueError(f\"Query execution failed: {str(e)}\") from e\r\n\r\n    def get_parsed_urls(self) -> List[Data]:\r\n        \"\"\"Return just the parsed URLs from the audio messages.\"\"\"\r\n        try:\r\n            query, params = self.build_query()\r\n            \r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                result = conn.execute(text(query), params)\r\n                rows = [dict(zip(row._fields, row)) for row in result]\r\n\r\n            # Return just the parsed URLs\r\n            return [\r\n                Data(\r\n                    data={\r\n                        \"url\": self.parse_media_url(row[\"message\"])\r\n                    }\r\n                )\r\n                for row in rows\r\n                if self.parse_media_url(row[\"message\"]) is not None\r\n            ]\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error getting parsed URLs: {str(e)}\")\r\n            raise ValueError(f\"Failed to get parsed URLs: {str(e)}\") from e","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"connection_string":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"connection_string","value":"postgresql://evolution_user:Duassenha2024@192.168.112.131:5432/evolution_db","display_name":"Connection String","advanced":false,"dynamic":false,"info":"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)","title_case":false,"type":"str","_input_type":"StrInput"},"end_time":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"end_time","value":"2024-12-26 23:59:59","display_name":"End Time","advanced":false,"input_types":["Message"],"dynamic":false,"info":"End time (YYYY-MM-DD HH:MM:SS)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"instance_id":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"","display_name":"Instance ID","advanced":false,"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"StrInput"},"message_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"message_id","value":"","display_name":"Message ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Find specific audio message by ID","title_case":false,"type":"str","_input_type":"MessageTextInput"},"page":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":true,"placeholder":"","show":true,"name":"page","value":1,"display_name":"Page","advanced":false,"dynamic":false,"info":"Page number (starts at 1)","title_case":false,"type":"int","_input_type":"IntInput"},"page_size":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":true,"placeholder":"","show":true,"name":"page_size","value":100,"display_name":"Page Size","advanced":false,"dynamic":false,"info":"Number of records per page","title_case":false,"type":"int","_input_type":"IntInput"},"push_name":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"push_name","value":"","display_name":"Push Name","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Filter by contact name","title_case":false,"type":"str","_input_type":"MessageTextInput"},"remote_jid":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"remote_jid","value":"","display_name":"Remote JID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Filter by remote JID (e.g., 555199999999@s.whatsapp.net)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"sort_direction":{"tool_mode":false,"trace_as_metadata":true,"options":["ASC","DESC"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"sort_direction","value":"DESC","display_name":"Sort Direction","advanced":false,"dynamic":false,"info":"Sort direction by messageTimestamp","title_case":false,"type":"str","_input_type":"DropdownInput"},"start_time":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"start_time","value":"2024-12-25 00:00:00","display_name":"Start Time","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Start time (YYYY-MM-DD HH:MM:SS)","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Query audio messages from Evolution database with different filter options","icon":"mic","base_classes":["Data"],"display_name":"Evolution Audio Message Query","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"messages","display_name":"Messages","method":"execute_query","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"parsed_urls","display_name":"Parsed URLs","method":"get_parsed_urls","value":"__UNDEFINED__","cache":true}],"field_order":["connection_string","instance_id","message_id","remote_jid","push_name","start_time","end_time","sort_direction","page_size","page"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14","official":false},"type":"CustomComponent","id":"CustomComponent-V7kon"},"id":"CustomComponent-V7kon","position":{"x":0,"y":0},"type":"genericNode"}],"viewport":{"x":1,"y":1,"zoom":1}},"is_component":true,"updated_at":"2025-01-06T17:56:26+00:00","webhook":false,"endpoint_name":null,"tags":null,"locked":false,"id":"0a08d817-640d-4519-b034-c3792cfdfb22","user_id":"556fed76-1562-4baf-8a2e-ef9be2d194e4","folder_id":"22c5349e-60ef-45a2-a8ec-0debcd24f6dd"},{"name":"whatsapp_reaction_audio_transcribe (prod)","description":"","icon":null,"icon_bg_color":null,"gradient":null,"data":{"nodes":[{"id":"Webhook-JOUAz","type":"genericNode","position":{"x":-2356.7929003421086,"y":-760.8725222191356},"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nfrom langflow.custom import Component\r\nfrom langflow.io import MultilineInput, Output\r\nfrom langflow.schema import Data\r\nfrom langflow.schema.message import Message\r\n\r\nclass WebhookComponent(Component):\r\n    display_name = \"Webhook\"\r\n    description = \"Defines a webhook input for the flow.\"\r\n    name = \"Webhook\"\r\n    icon = \"webhook\"\r\n    inputs = [\r\n        MultilineInput(\r\n            name=\"data\",\r\n            display_name=\"Payload\",\r\n            info=\"Receives a payload from external systems via HTTP POST.\",\r\n        )\r\n    ]\r\n    outputs = [\r\n        Output(display_name=\"Raw Payload\", name=\"raw_payload\", method=\"forward_raw_payload\", type=\"Message\"),\r\n        Output(display_name=\"Data\", name=\"output_data\", method=\"build_data\"),\r\n    ]\r\n\r\n    def forward_raw_payload(self) -> Message:\r\n        \"\"\"Forward the raw payload as a Message type.\"\"\"\r\n        if not self.data:\r\n            return Message(text=\"\")\r\n        return Message(text=self.data)\r\n\r\n    def build_data(self) -> Data:\r\n        message: str | Data = \"\"\r\n        if not self.data:\r\n            self.status = \"No data provided.\"\r\n            return Data(data={})\r\n        try:\r\n            body = json.loads(self.data or \"{}\")\r\n        except json.JSONDecodeError:\r\n            body = {\"payload\": self.data}\r\n            message = f\"Invalid JSON payload. Please check the format.\\n\\n{self.data}\"\r\n        data = Data(data=body)\r\n        if not message:\r\n            message = data\r\n        self.status = message\r\n        return data\r\n\r\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"data":{"tool_mode":false,"trace_as_input":true,"multiline":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"data","value":"{\"timestamp\": \"2025-01-06 15:25:54 GMT-3\", \"messageType\": \"reactionMessage\", \"pushName\": \"Felipe Rosa\", \"remoteJid\": \"555197285829@s.whatsapp.net\", \"messageId\": \"357012D10102F6F9ED3629824E794EAE\", \"fromMe\": \"true\", \"message\": \"\\ud83d\\ude49\", \"participant\": \"\"}","display_name":"Payload","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Receives a payload from external systems via HTTP POST.","title_case":false,"type":"str","_input_type":"MultilineInput"}},"description":"Defines a webhook input for the flow.","icon":"webhook","base_classes":["Data","Message"],"display_name":"Webhook + Raw Payload","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"raw_payload","display_name":"Raw Payload","method":"forward_raw_payload","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"output_data","display_name":"Data","method":"build_data","value":"__UNDEFINED__","cache":true}],"field_order":["data"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev22"},"type":"Webhook","id":"Webhook-JOUAz"},"selected":false,"width":320,"height":233,"positionAbsolute":{"x":-53.512037586403494,"y":171.84531224859728},"dragging":false,"measured":{"width":320,"height":233}},{"id":"CustomComponent-0GoMy","type":"genericNode","position":{"x":-1927.5025190581862,"y":-1165.687503358656},"data":{"node":{"template":{"_type":"Component","data":{"tool_mode":false,"trace_as_metadata":true,"list":false,"trace_as_input":true,"required":true,"placeholder":"","show":true,"name":"data","value":"","display_name":"Message Data","advanced":false,"input_types":["Data"],"dynamic":false,"info":"Evolution API message data to parse","title_case":false,"type":"other","_input_type":"DataInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nfrom typing import List\r\nfrom urllib.parse import urlparse, urlunparse\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    DataInput,\r\n    MessageTextInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\nfrom langflow.schema.message import Message\r\n\r\n\r\nclass EvolutionDataParserComponent(Component):\r\n    display_name = \"Evolution Webhook Parser\"\r\n    description = \"Parse Evolution API webhook message data into structured format\"\r\n    icon = \"webhook\"\r\n    name = \"evolution_data_parser\"\r\n\r\n    inputs = [\r\n        DataInput(\r\n            name=\"data\",\r\n            display_name=\"Message Data\",\r\n            info=\"Evolution API message data to parse\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"media_server_url\",\r\n            display_name=\"Media Server URL\",\r\n            info=\"Base URL for media server (e.g., https://media.server.com)\",\r\n            required=False,\r\n            value=\"http://minio:9000\"\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"timestamp\",\r\n            display_name=\"Message Timestamp\",\r\n            description=\"Message timestamp in GMT-3\",\r\n            method=\"get_timestamp\",\r\n        ),\r\n        Output(\r\n            name=\"message_type\",\r\n            display_name=\"Message Type\",\r\n            description=\"Type of the message (conversation, audioMessage, etc)\",\r\n            method=\"get_message_type\",\r\n        ),\r\n        Output(\r\n            name=\"push_name\",\r\n            display_name=\"Push Name\",\r\n            description=\"Sender's push name\",\r\n            method=\"get_push_name\",\r\n        ),\r\n        Output(\r\n            name=\"remote_jid\",\r\n            display_name=\"Remote JID\",\r\n            description=\"WhatsApp ID of the remote contact\",\r\n            method=\"get_remote_jid\",\r\n        ),\r\n        Output(\r\n            name=\"message_id\",\r\n            display_name=\"Message ID\",\r\n            description=\"Unique identifier of the message\",\r\n            method=\"get_message_id\",\r\n        ),\r\n        Output(\r\n            name=\"from_me\",\r\n            display_name=\"From Me\",\r\n            description=\"Whether the message was sent by the user\",\r\n            method=\"get_from_me\",\r\n        ),\r\n        Output(\r\n            name=\"message_content\",\r\n            display_name=\"Message Content\",\r\n            description=\"Content of the message (text or media URL)\",\r\n            method=\"get_message_content\",\r\n        ),\r\n    ]\r\n\r\n    def clean_media_url(self, url: str) -> str:\r\n        \"\"\"Clean media URL by removing query parameters\"\"\"\r\n        if not url:\r\n            return \"\"\r\n            \r\n        parsed = urlparse(url)\r\n        clean_url = urlunparse((\r\n            parsed.scheme,\r\n            parsed.netloc,\r\n            parsed.path,\r\n            '',  # params\r\n            '',  # query\r\n            ''   # fragment\r\n        ))\r\n        \r\n        # Replace minio URL if media server URL is provided\r\n        if self.media_server_url:\r\n            clean_url = clean_url.replace(\"http://minio:9000\", self.media_server_url.rstrip('/'))\r\n            \r\n        return clean_url\r\n\r\n    def parse_message_content(self, message: str, message_type: str) -> str:\r\n        \"\"\"Process message content based on message type\"\"\"\r\n        self.log(f\"Processing message content for type: {message_type}\")\r\n        \r\n        if not message:\r\n            self.log(\"No message content found\")\r\n            return \"\"\r\n            \r\n        if message_type == \"audioMessage\":\r\n            self.log(f\"Found media URL: {message}\")\r\n            cleaned_url = self.clean_media_url(message)\r\n            self.log(f\"Cleaned media URL: {cleaned_url}\")\r\n            return cleaned_url\r\n            \r\n        # For other message types, return content as is\r\n        return message\r\n\r\n    def parse_data(self) -> None:\r\n        \"\"\"Parse Evolution API message data into structured format\"\"\"\r\n        try:\r\n            # Get input data\r\n            if not hasattr(self.data, 'data'):\r\n                raise ValueError(\"Input data missing 'data' field\")\r\n            \r\n            input_data = self.data.data\r\n            self.log(f\"Processing input data: {json.dumps(input_data, indent=2)}\")\r\n\r\n            # Process message content if needed\r\n            message = self.parse_message_content(\r\n                input_data.get(\"message\", \"\"),\r\n                input_data.get(\"messageType\", \"\")\r\n            )\r\n\r\n            # Store parsed data\r\n            self._parsed_data = {\r\n                \"timestamp\": input_data.get(\"timestamp\", \"\"),\r\n                \"messageType\": input_data.get(\"messageType\", \"\"),\r\n                \"pushName\": input_data.get(\"pushName\", \"\"),\r\n                \"remoteJid\": input_data.get(\"remoteJid\", \"\"),\r\n                \"messageId\": input_data.get(\"messageId\", \"\"),\r\n                \"fromMe\": input_data.get(\"fromMe\", \"false\"),\r\n                \"message\": message\r\n            }\r\n\r\n        except Exception as e:\r\n            error_msg = f\"Error parsing data: {str(e)}\"\r\n            self.log(error_msg)\r\n            \r\n            # Initialize empty data on error\r\n            self._parsed_data = {\r\n                \"timestamp\": \"\",\r\n                \"messageType\": \"\",\r\n                \"pushName\": \"\",\r\n                \"remoteJid\": \"\",\r\n                \"messageId\": \"\",\r\n                \"fromMe\": \"false\",\r\n                \"message\": \"\"\r\n            }\r\n            \r\n    def get_timestamp(self) -> Message:\r\n        \"\"\"Get the message timestamp.\"\"\"\r\n        self.parse_data()\r\n        return Message(text=self._parsed_data.get(\"timestamp\", \"\"))\r\n        \r\n    def get_message_type(self) -> Message:\r\n        \"\"\"Get the message type.\"\"\"\r\n        self.parse_data()\r\n        return Message(text=self._parsed_data.get(\"messageType\", \"\"))\r\n        \r\n    def get_push_name(self) -> Message:\r\n        \"\"\"Get the sender's push name.\"\"\"\r\n        self.parse_data()\r\n        return Message(text=self._parsed_data.get(\"pushName\", \"\"))\r\n        \r\n    def get_remote_jid(self) -> Message:\r\n        \"\"\"Get the remote JID.\"\"\"\r\n        self.parse_data()\r\n        return Message(text=self._parsed_data.get(\"remoteJid\", \"\"))\r\n\r\n    def get_message_id(self) -> Message:\r\n        \"\"\"Get the message ID.\"\"\"\r\n        self.parse_data()\r\n        return Message(text=self._parsed_data.get(\"messageId\", \"\"))\r\n\r\n    def get_from_me(self) -> Message:\r\n        \"\"\"Get whether the message was sent by the user.\"\"\"\r\n        self.parse_data()\r\n        return Message(text=self._parsed_data.get(\"fromMe\", \"false\"))\r\n        \r\n    def get_message_content(self) -> Message:\r\n        \"\"\"Get the message content.\"\"\"\r\n        self.parse_data()\r\n        return Message(text=self._parsed_data.get(\"message\", \"\"))","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"media_server_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"media_server_url","value":"http://192.168.112.131:9000","display_name":"Media Server URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Base URL for media server (e.g., https://media.server.com)","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Parse Evolution API webhook message data into structured format","icon":"webhook","base_classes":["Message"],"display_name":"Evolution Webhook Parser","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"timestamp","display_name":"Message Timestamp","method":"get_timestamp","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"message_type","display_name":"Message Type","method":"get_message_type","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"push_name","display_name":"Push Name","method":"get_push_name","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"remote_jid","display_name":"Remote JID","method":"get_remote_jid","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"message_id","display_name":"Message ID","method":"get_message_id","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"from_me","display_name":"From Me","method":"get_from_me","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"message_content","display_name":"Message Content","method":"get_message_content","value":"__UNDEFINED__","cache":true}],"field_order":["data","media_server_url"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev22"},"type":"CustomComponent","id":"CustomComponent-0GoMy"},"selected":false,"measured":{"width":320,"height":589},"dragging":false},{"id":"CustomComponent-ObIjr","type":"genericNode","position":{"x":-394.2384939590431,"y":-1083.4318234344576},"data":{"node":{"template":{"_type":"Component","api_key":{"load_from_db":true,"required":true,"placeholder":"","show":true,"name":"api_key","value":"audio_trans","display_name":"API Key","advanced":false,"input_types":["Message"],"dynamic":false,"info":"API key for authentication","title_case":false,"password":true,"type":"str","_input_type":"SecretStrInput"},"audio_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"audio_url","value":"","display_name":"Audio URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"URL of the audio file to transcribe","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Dict, Any\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    SecretStrInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Message\r\n\r\nclass AudioProcessorComponent(Component):\r\n    display_name = \"Audio Transcriber\"\r\n    description = \"Transcribe audio files from URLs\"\r\n    icon = \"mic\"\r\n    name = \"audio_transcriber\"\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"audio_url\",\r\n            display_name=\"Audio URL\",\r\n            info=\"URL of the audio file to transcribe\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"server_url\",\r\n            display_name=\"Server URL\",\r\n            info=\"Transcription server URL (e.g., http://localhost:4040)\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"language\",\r\n            display_name=\"Language\",\r\n            info=\"Optional: Language code for transcription\",\r\n            required=False,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"api_key\",\r\n            display_name=\"API Key\",\r\n            info=\"API key for authentication\",\r\n            required=True,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"transcription\",\r\n            display_name=\"Transcription\",\r\n            method=\"transcribe_audio\",\r\n        ),\r\n    ]\r\n\r\n    def transcribe_audio(self) -> Message:\r\n        \"\"\"\r\n        Transcribe audio from URL.\r\n        \"\"\"\r\n        try:\r\n            # Ensure server URL format\r\n            server_url = self.server_url.rstrip('/')\r\n            self.log(f\"Using server URL: {server_url}\")\r\n            \r\n            # Build API endpoint URL\r\n            url = f\"{server_url}/transcribe\"\r\n            self.log(f\"Full API endpoint URL: {url}\")\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n            }\r\n            self.log(\"Headers prepared (apikey hidden)\")\r\n\r\n            # Prepare payload\r\n            payload = {\r\n                \"url\": self.audio_url\r\n            }\r\n            \r\n            # Add optional language if provided\r\n            if hasattr(self, 'language') and self.language:\r\n                payload[\"language\"] = self.language\r\n            \r\n            # Log the request (excluding sensitive data)\r\n            request_info = {\r\n                \"url\": url,\r\n                \"headers\": {\r\n                    \"apikey\": \"***hidden***\"\r\n                },\r\n                \"payload\": payload\r\n            }\r\n            self.log(f\"Making request: {json.dumps(request_info, indent=2)}\")\r\n\r\n            # Make API request\r\n            response = requests.post(\r\n                url, \r\n                headers=headers,\r\n                data=payload\r\n            )\r\n            \r\n            self.log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Check for successful response\r\n            response.raise_for_status()\r\n            \r\n            # Parse response\r\n            data = response.json()\r\n            \r\n            # Extract transcription\r\n            transcription = data.get(\"transcription\", \"\")\r\n            if not transcription:\r\n                self.log(\"Warning: No transcription found in response\")\r\n            \r\n            self.log(\"Successfully extracted transcription\")\r\n            \r\n            # Return transcription as message\r\n            return Message(text=transcription)\r\n\r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"API request failed: {str(e)}\"\r\n            self.log(f\"Request error: {error_msg}\")\r\n            return Message(content=f\"Error: {error_msg}\")\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Unexpected error: {error_msg}\")\r\n            return Message(content=f\"Error: {error_msg}\")","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"language":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"language","value":"","display_name":"Language","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Optional: Language code for transcription","title_case":false,"type":"str","_input_type":"MessageTextInput"},"server_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"server_url","value":"http://192.168.112.131:4040","display_name":"Server URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Transcription server URL (e.g., http://localhost:4040)","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Transcribe audio files from URLs","icon":"mic","base_classes":["Message"],"display_name":"Audio Transcriber","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"transcription","display_name":"Transcription","method":"transcribe_audio","value":"__UNDEFINED__","cache":true}],"field_order":["audio_url","server_url","language","api_key"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev22"},"type":"CustomComponent","id":"CustomComponent-ObIjr"},"selected":false,"measured":{"width":320,"height":491},"dragging":false},{"id":"CustomComponent-Pn9Li","type":"genericNode","position":{"x":372.88266620446086,"y":-964.4663144858885},"data":{"node":{"template":{"_type":"Component","api_key":{"load_from_db":true,"required":true,"placeholder":"","show":true,"name":"api_key","value":"felipe_evo","display_name":"API Key","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API key for authentication","title_case":false,"password":true,"type":"str","_input_type":"SecretStrInput"},"base_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"base_url","value":"http://192.168.112.131:8080","display_name":"API Base URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API base URL (e.g., http://example.com:8080)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Dict, Any\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    SecretStrInput,\r\n    IntInput,\r\n    BoolInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass SendTextMessageComponent(Component):\r\n    display_name = \"Evolution Send Text Message\"\r\n    description = \"Send a text message using Evolution API\"\r\n    icon = \"message-square\"\r\n    name = \"send_text_message\"\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"base_url\",\r\n            display_name=\"API Base URL\",\r\n            info=\"Evolution API base URL (e.g., http://example.com:8080)\",\r\n            required=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"api_key\",\r\n            display_name=\"API Key\",\r\n            info=\"Evolution API key for authentication\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"number\",\r\n            display_name=\"Recipient Number\",\r\n            info=\"WhatsApp ID of the recipient (e.g., 5511999999999@s.whatsapp.net)\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"text\",\r\n            display_name=\"Message Text\",\r\n            info=\"The text message to send\",\r\n            required=True,\r\n        ),\r\n        # Advanced options\r\n        MessageTextInput(\r\n            name=\"quoted_message_id\",\r\n            display_name=\"Quoted Message ID\",\r\n            info=\"ID of the message to quote (optional)\",\r\n            advanced=True,\r\n            required=False,\r\n        ),\r\n        IntInput(\r\n            name=\"delay\",\r\n            display_name=\"Delay\",\r\n            info=\"Optional delay in milliseconds\",\r\n            advanced=True,\r\n        ),\r\n        BoolInput(\r\n            name=\"mentions_everyone\",\r\n            display_name=\"Mention Everyone\",\r\n            info=\"Whether to mention all participants\",\r\n            advanced=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"mentioned\",\r\n            display_name=\"Mentioned Numbers\",\r\n            info=\"List of WhatsApp IDs to mention (comma-separated)\",\r\n            advanced=True,\r\n            is_list=True,\r\n        ),\r\n        BoolInput(\r\n            name=\"link_preview\",\r\n            display_name=\"Link Preview\",\r\n            info=\"Whether to show link previews in the message\",\r\n            advanced=True,\r\n        ),\r\n        BoolInput(\r\n            name=\"show_typing\",\r\n            display_name=\"Show Typing\",\r\n            info=\"Show typing indicator before sending message\",\r\n            advanced=True,\r\n        ),\r\n        IntInput(\r\n            name=\"typing_delay\",\r\n            display_name=\"Typing Delay\",\r\n            info=\"How long to show typing indicator (in milliseconds)\",\r\n            advanced=True,\r\n            value=3000,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"message\",\r\n            display_name=\"Message\",\r\n            method=\"send_message\",\r\n        ),\r\n    ]\r\n\r\n    def build_payload(self) -> Dict[str, Any]:\r\n        \"\"\"Build the request payload.\"\"\"\r\n        payload = {\r\n            \"number\": self.number,\r\n            \"text\": self.text\r\n        }\r\n        \r\n        # Add optional fields if provided\r\n        if hasattr(self, 'delay') and self.delay:\r\n            payload[\"delay\"] = self.delay\r\n            \r\n        if hasattr(self, 'mentions_everyone'):\r\n            payload[\"mentionsEveryOne\"] = self.mentions_everyone\r\n            \r\n        if hasattr(self, 'mentioned') and self.mentioned:\r\n            payload[\"mentioned\"] = self.mentioned\r\n\r\n        if hasattr(self, 'link_preview'):\r\n            payload[\"linkPreview\"] = self.link_preview\r\n\r\n        # Add quoted message if ID is provided\r\n        if hasattr(self, 'quoted_message_id') and self.quoted_message_id:\r\n            payload[\"quoted\"] = {\r\n                \"key\": {\r\n                    \"id\": self.quoted_message_id\r\n                }\r\n            }\r\n        \r\n        # Log payload (excluding sensitive data)\r\n        safe_payload = {**payload}\r\n        safe_payload[\"number\"] = \"***hidden***\"\r\n        self.log(f\"Built payload: {json.dumps(safe_payload, indent=2)}\")\r\n        \r\n        return payload\r\n\r\n    def send_presence(self) -> None:\r\n        \"\"\"Send typing presence indicator.\"\"\"\r\n        try:\r\n            base_url = self.base_url.rstrip('/')\r\n            url = f\"{base_url}/chat/sendPresence/{self.instance_id}\"\r\n            \r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n                \"Content-Type\": \"application/json\"\r\n            }\r\n            \r\n            payload = {\r\n                \"number\": self.number,\r\n                \"delay\": self.typing_delay,\r\n                \"presence\": \"composing\"\r\n            }\r\n            \r\n            self.log(\"Sending typing presence indicator...\")\r\n            response = requests.post(url, headers=headers, json=payload)\r\n            response.raise_for_status()\r\n            self.log(\"Typing indicator sent successfully\")\r\n            \r\n        except Exception as e:\r\n            self.log(f\"Error sending typing presence: {str(e)}\")\r\n\r\n    def send_message(self) -> Data:\r\n        \"\"\"\r\n        Send a text message via Evolution API.\r\n        \"\"\"\r\n        try:\r\n            # Ensure base URL format\r\n            base_url = self.base_url.rstrip('/')\r\n            self.log(f\"Using base URL: {base_url}\")\r\n            \r\n            # Send typing presence if enabled\r\n            if hasattr(self, 'show_typing') and self.show_typing:\r\n                self.send_presence()\r\n            \r\n            # Build API endpoint URL\r\n            url = f\"{base_url}/message/sendText/{self.instance_id}\"\r\n            self.log(f\"Full API endpoint URL: {url}\")\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n                \"Content-Type\": \"application/json\"\r\n            }\r\n            self.log(\"Headers prepared (apikey hidden)\")\r\n\r\n            # Build payload\r\n            payload = self.build_payload()\r\n            \r\n            # Log the complete request (excluding sensitive data)\r\n            request_info = {\r\n                \"url\": url,\r\n                \"headers\": {\r\n                    \"Content-Type\": \"application/json\",\r\n                    \"apikey\": \"***hidden***\"\r\n                },\r\n                \"payload\": {\r\n                    \"number\": \"***hidden***\",\r\n                    \"text\": payload[\"text\"]\r\n                }\r\n            }\r\n            self.log(f\"Making request: {json.dumps(request_info, indent=2)}\")\r\n\r\n            # Make API request\r\n            response = requests.post(\r\n                url, \r\n                headers=headers, \r\n                data=json.dumps(payload)\r\n            )\r\n            \r\n            self.log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Check for successful response\r\n            response.raise_for_status()\r\n            \r\n            # Parse response\r\n            data = response.json()\r\n            \r\n            # Process response into consistent format\r\n            processed_response = {\r\n                \"key\": data.get(\"key\", {}),\r\n                \"pushName\": data.get(\"pushName\", \"\"),\r\n                \"status\": data.get(\"status\"),\r\n                \"message\": data.get(\"message\", {}),\r\n                \"contextInfo\": data.get(\"contextInfo\"),\r\n                \"messageType\": data.get(\"messageType\"),\r\n                \"messageTimestamp\": data.get(\"messageTimestamp\"),\r\n                \"instanceId\": data.get(\"instanceId\"),\r\n                \"source\": data.get(\"source\")\r\n            }\r\n            \r\n            self.log(\"Message sent successfully\")\r\n            self.log(f\"Message status: {processed_response.get('status')}\")\r\n            \r\n            return Data(data=processed_response)\r\n\r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"API request failed: {str(e)}\"\r\n            self.log(f\"Request error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Unexpected error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"delay":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"delay","value":"","display_name":"Delay","advanced":true,"dynamic":false,"info":"Optional delay in milliseconds","title_case":false,"type":"int","_input_type":"IntInput"},"instance_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"felipe8888","display_name":"Instance ID","advanced":true,"input_types":["Message"],"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"MessageTextInput"},"link_preview":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"link_preview","value":false,"display_name":"Link Preview","advanced":true,"dynamic":false,"info":"Whether to show link previews in the message","title_case":false,"type":"bool","_input_type":"BoolInput"},"mentioned":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":true,"required":false,"placeholder":"","show":true,"name":"mentioned","value":"","display_name":"Mentioned Numbers","advanced":true,"input_types":["Message"],"dynamic":false,"info":"List of WhatsApp IDs to mention (comma-separated)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"mentions_everyone":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"mentions_everyone","value":false,"display_name":"Mention Everyone","advanced":true,"dynamic":false,"info":"Whether to mention all participants","title_case":false,"type":"bool","_input_type":"BoolInput"},"number":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"number","value":"","display_name":"Recipient Number","advanced":false,"input_types":["Message"],"dynamic":false,"info":"WhatsApp ID of the recipient (e.g., 5511999999999@s.whatsapp.net)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"quoted_message_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"quoted_message_id","value":"","display_name":"Quoted Message ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"ID of the message to quote (optional)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"show_typing":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"show_typing","value":false,"display_name":"Show Typing","advanced":true,"dynamic":false,"info":"Show typing indicator before sending message","title_case":false,"type":"bool","_input_type":"BoolInput"},"text":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"text","value":"","display_name":"Message Text","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The text message to send","title_case":false,"type":"str","_input_type":"MessageTextInput"},"typing_delay":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"typing_delay","value":3000,"display_name":"Typing Delay","advanced":true,"dynamic":false,"info":"How long to show typing indicator (in milliseconds)","title_case":false,"type":"int","_input_type":"IntInput"}},"description":"Send a text message using Evolution API","icon":"message-square","base_classes":["Data"],"display_name":"Evolution Send Text Message","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"message","display_name":"Message","method":"send_message","value":"__UNDEFINED__","cache":true}],"field_order":["base_url","api_key","instance_id","number","text","quoted_message_id","delay","mentions_everyone","mentioned","link_preview","show_typing","typing_delay"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev22","official":false},"type":"CustomComponent","id":"CustomComponent-Pn9Li"},"selected":false,"measured":{"width":320,"height":577},"dragging":false},{"id":"ParseData-7WaOm","type":"genericNode","position":{"x":769.8683397787977,"y":-977.566567047006},"data":{"node":{"template":{"_type":"Component","data":{"tool_mode":false,"trace_as_metadata":true,"list":true,"trace_as_input":true,"required":false,"placeholder":"","show":true,"name":"data","value":"","display_name":"Data","advanced":false,"input_types":["Data"],"dynamic":false,"info":"The data to convert to text.","title_case":false,"type":"other","_input_type":"DataInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from langflow.custom import Component\nfrom langflow.helpers.data import data_to_text, data_to_text_list\nfrom langflow.io import DataInput, MultilineInput, Output, StrInput\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\n\n\nclass ParseDataComponent(Component):\n    display_name = \"Parse Data\"\n    description = \"Convert Data into plain text following a specified template.\"\n    icon = \"braces\"\n    name = \"ParseData\"\n\n    inputs = [\n        DataInput(name=\"data\", display_name=\"Data\", info=\"The data to convert to text.\", is_list=True),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. \"\n            \"It can contain the keys {text}, {data} or any other key in the Data.\",\n            value=\"{text}\",\n        ),\n        StrInput(name=\"sep\", display_name=\"Separator\", advanced=True, value=\"\\n\"),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Text\",\n            name=\"text\",\n            info=\"Data as a single Message, with each input Data separated by Separator\",\n            method=\"parse_data\",\n        ),\n        Output(\n            display_name=\"Data List\",\n            name=\"data_list\",\n            info=\"Data as a list of new Data, each having `text` formatted by Template\",\n            method=\"parse_data_as_list\",\n        ),\n    ]\n\n    def _clean_args(self) -> tuple[list[Data], str, str]:\n        data = self.data if isinstance(self.data, list) else [self.data]\n        template = self.template\n        sep = self.sep\n        return data, template, sep\n\n    def parse_data(self) -> Message:\n        data, template, sep = self._clean_args()\n        result_string = data_to_text(template, data, sep)\n        self.status = result_string\n        return Message(text=result_string)\n\n    def parse_data_as_list(self) -> list[Data]:\n        data, template, _ = self._clean_args()\n        text_list, data_list = data_to_text_list(template, data)\n        for item, text in zip(data_list, text_list, strict=True):\n            item.set_text(text)\n        self.status = data_list\n        return data_list\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"sep":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"sep","value":"\n","display_name":"Separator","advanced":true,"dynamic":false,"info":"","title_case":false,"type":"str","_input_type":"StrInput"},"template":{"tool_mode":false,"trace_as_input":true,"multiline":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"template","value":"{key}\\n\\n{status}\\n\\n{message}\\n\\n{messageType}","display_name":"Template","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The template to use for formatting the data. It can contain the keys {text}, {data} or any other key in the Data.","title_case":false,"type":"str","_input_type":"MultilineInput"}},"description":"Convert Data into plain text following a specified template.","icon":"braces","base_classes":["Data","Message"],"display_name":"Parse Data","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"text","display_name":"Text","method":"parse_data","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"data_list","display_name":"Data List","method":"parse_data_as_list","value":"__UNDEFINED__","cache":true}],"field_order":["data","template","sep"],"beta":false,"legacy":false,"edited":false,"metadata":{},"tool_mode":false,"category":"processing","key":"ParseData","score":0.05900406050629291,"lf_version":"1.1.1.dev22"},"type":"ParseData","id":"ParseData-7WaOm"},"selected":false,"measured":{"width":320,"height":349},"dragging":false},{"id":"ChatOutput-TzYh9","type":"genericNode","position":{"x":1256.2156310983587,"y":-991.1869224844686},"data":{"node":{"template":{"_type":"Component","background_color":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"background_color","value":"","display_name":"Background Color","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The background color of the icon.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"chat_icon":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"chat_icon","value":"","display_name":"Icon","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The icon of the message.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.io import DropdownInput, MessageInput, MessageTextInput, Output\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        MessageInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Message to be passed as output.\",\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            source_dict[\"source\"] = source\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n        background_color = self.background_color\n        text_color = self.text_color\n        if self.chat_icon:\n            icon = self.chat_icon\n        message = self.input_value if isinstance(self.input_value, Message) else Message(text=self.input_value)\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n        message.properties.icon = icon\n        message.properties.background_color = background_color\n        message.properties.text_color = text_color\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = await self.send_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"data_template":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"data_template","value":"{text}","display_name":"Data Template","advanced":true,"input_types":["Message"],"dynamic":false,"info":"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"input_value":{"trace_as_input":true,"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"input_value","value":"","display_name":"Text","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Message to be passed as output.","title_case":false,"type":"str","_input_type":"MessageInput"},"sender":{"tool_mode":false,"trace_as_metadata":true,"options":["Machine","User"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"sender","value":"Machine","display_name":"Sender Type","advanced":true,"dynamic":false,"info":"Type of sender.","title_case":false,"type":"str","_input_type":"DropdownInput"},"sender_name":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"sender_name","value":"Audio Transcribed","display_name":"Sender Name","advanced":true,"input_types":["Message"],"dynamic":false,"info":"Name of the sender.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"session_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"session_id","value":"audios_transcribed","display_name":"Session ID","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The session ID of the chat. If empty, the current session ID parameter will be used.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"should_store_message":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"should_store_message","value":true,"display_name":"Store Messages","advanced":true,"dynamic":false,"info":"Store the message in the history.","title_case":false,"type":"bool","_input_type":"BoolInput"},"text_color":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"text_color","value":"","display_name":"Text Color","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The text color of the name","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Display a chat message in the Playground.","icon":"MessagesSquare","base_classes":["Message"],"display_name":"Chat Output","documentation":"","minimized":true,"custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"message","display_name":"Message","method":"message_response","value":"__UNDEFINED__","cache":true}],"field_order":["input_value","should_store_message","sender","sender_name","session_id","data_template","background_color","chat_icon","text_color"],"beta":false,"legacy":false,"edited":false,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev22"},"type":"ChatOutput","id":"ChatOutput-TzYh9"},"selected":false,"measured":{"width":320,"height":233},"dragging":false},{"id":"ChatOutput-UlBVK","type":"genericNode","position":{"x":-1946.9706107499192,"y":-512.610656524417},"data":{"node":{"template":{"_type":"Component","background_color":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"background_color","value":"","display_name":"Background Color","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The background color of the icon.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"chat_icon":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"chat_icon","value":"","display_name":"Icon","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The icon of the message.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.io import DropdownInput, MessageInput, MessageTextInput, Output\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        MessageInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Message to be passed as output.\",\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            source_dict[\"source\"] = source\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n        background_color = self.background_color\n        text_color = self.text_color\n        if self.chat_icon:\n            icon = self.chat_icon\n        message = self.input_value if isinstance(self.input_value, Message) else Message(text=self.input_value)\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n        message.properties.icon = icon\n        message.properties.background_color = background_color\n        message.properties.text_color = text_color\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = await self.send_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"data_template":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"data_template","value":"{text}","display_name":"Data Template","advanced":true,"input_types":["Message"],"dynamic":false,"info":"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"input_value":{"trace_as_input":true,"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"input_value","value":"","display_name":"Text","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Message to be passed as output.","title_case":false,"type":"str","_input_type":"MessageInput"},"sender":{"tool_mode":false,"trace_as_metadata":true,"options":["Machine","User"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"sender","value":"Machine","display_name":"Sender Type","advanced":true,"dynamic":false,"info":"Type of sender.","title_case":false,"type":"str","_input_type":"DropdownInput"},"sender_name":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"sender_name","value":"raw_payload","display_name":"Sender Name","advanced":true,"input_types":["Message"],"dynamic":false,"info":"Name of the sender.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"session_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"session_id","value":"raw_payload_audio","display_name":"Session ID","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The session ID of the chat. If empty, the current session ID parameter will be used.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"should_store_message":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"should_store_message","value":true,"display_name":"Store Messages","advanced":true,"dynamic":false,"info":"Store the message in the history.","title_case":false,"type":"bool","_input_type":"BoolInput"},"text_color":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"text_color","value":"","display_name":"Text Color","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The text color of the name","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Display a chat message in the Playground.","icon":"MessagesSquare","base_classes":["Message"],"display_name":"Chat Output","documentation":"","minimized":true,"custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"message","display_name":"Message","method":"message_response","value":"__UNDEFINED__","cache":true}],"field_order":["input_value","should_store_message","sender","sender_name","session_id","data_template","background_color","chat_icon","text_color"],"beta":false,"legacy":false,"edited":false,"metadata":{},"tool_mode":false},"type":"ChatOutput","id":"ChatOutput-UlBVK"},"selected":false,"measured":{"width":320,"height":233},"dragging":false},{"id":"CustomComponent-8HviC","type":"genericNode","position":{"x":-1135.0900669566586,"y":-979.0484168214981},"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from typing import Any, Dict, List, Optional\r\nfrom sqlalchemy import create_engine, text\r\nimport json\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    StrInput,\r\n    MessageTextInput,\r\n    IntInput,\r\n    DropdownInput,\r\n    Output\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass AudioMessageQueryComponent(Component):\r\n    display_name = \"Evolution Audio Message Query\"\r\n    description = \"Query audio messages from Evolution database with different filter options\"\r\n    icon = \"mic\"\r\n    name = \"evolution_audio_message_query\"\r\n\r\n    def __init__(self, **data):\r\n        super().__init__(**data)\r\n        self._engine = None\r\n\r\n    inputs = [\r\n        StrInput(\r\n            name=\"connection_string\",\r\n            display_name=\"Connection String\",\r\n            info=\"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)\",\r\n            required=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"message_id\",\r\n            display_name=\"Message ID\",\r\n            info=\"Find specific audio message by ID\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"remote_jid\",\r\n            display_name=\"Remote JID\",\r\n            info=\"Filter by remote JID (e.g., 555199999999@s.whatsapp.net)\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"push_name\",\r\n            display_name=\"Push Name\",\r\n            info=\"Filter by contact name\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"start_time\",\r\n            display_name=\"Start Time\",\r\n            info=\"Start time (YYYY-MM-DD HH:MM:SS)\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"end_time\",\r\n            display_name=\"End Time\", \r\n            info=\"End time (YYYY-MM-DD HH:MM:SS)\",\r\n            required=False\r\n        ),\r\n        DropdownInput(\r\n            name=\"sort_direction\",\r\n            display_name=\"Sort Direction\",\r\n            info=\"Sort direction by messageTimestamp\",\r\n            options=[\"ASC\", \"DESC\"],\r\n            value=\"DESC\",\r\n            required=False\r\n        ),\r\n        IntInput(\r\n            name=\"page_size\",\r\n            display_name=\"Page Size\",\r\n            info=\"Number of records per page\",\r\n            value=100,\r\n            required=True\r\n        ),\r\n        IntInput(\r\n            name=\"page\",\r\n            display_name=\"Page\",\r\n            info=\"Page number (starts at 1)\",\r\n            value=1,\r\n            required=True\r\n        )\r\n    ]\r\n\r\n    outputs = [\r\n        Output(name=\"messages\", display_name=\"Messages\", method=\"execute_query\"),\r\n        Output(name=\"parsed_urls\", display_name=\"Parsed URLs\", method=\"get_parsed_urls\")\r\n    ]\r\n\r\n    def parse_media_url(self, message: Any) -> str:\r\n        \"\"\"Extract and parse media URL from audio message.\"\"\"\r\n        try:\r\n            if isinstance(message, str):\r\n                message = json.loads(message)\r\n                \r\n            if \"mediaUrl\" in message:\r\n                url = message[\"mediaUrl\"]\r\n                if \"?\" in url:\r\n                    return url.split(\"?\")[0]\r\n                return url\r\n                \r\n            return None\r\n            \r\n        except Exception as e:\r\n            self.log(f\"Error parsing media URL: {str(e)}\")\r\n            return None\r\n\r\n    def get_engine(self):\r\n        \"\"\"Get or create SQLAlchemy engine.\"\"\"\r\n        if not self._engine:\r\n            try:\r\n                self._engine = create_engine(\r\n                    self.connection_string,\r\n                    echo=False\r\n                )\r\n                \r\n                # Test the connection\r\n                with self._engine.connect() as conn:\r\n                    conn.execute(text(\"SELECT 1\"))\r\n                    \r\n            except Exception as e:\r\n                self.log(f\"Failed to create database engine: {str(e)}\")\r\n                raise ValueError(f\"Database connection failed: {str(e)}\") from e\r\n        return self._engine\r\n\r\n    def build_query(self) -> tuple[str, dict]:\r\n        \"\"\"Build the SQL query and parameters.\"\"\"\r\n        try:\r\n            query = '''\r\n                SELECT \r\n                    \"messageTimestamp\", \r\n                    \"messageType\", \r\n                    message, \r\n                    \"pushName\", \r\n                    key,\r\n                    \"contextInfo\"\r\n                FROM public.\"Message\"\r\n                WHERE \"messageType\" = 'audioMessage'\r\n            '''\r\n            params = {}\r\n\r\n            # Add message ID filter if specified\r\n            if hasattr(self, 'message_id') and self.message_id:\r\n                query += \" AND key->>'id' = :message_id\"\r\n                params[\"message_id\"] = str(self.message_id).strip()\r\n\r\n            # Add remote JID filter if specified\r\n            if hasattr(self, 'remote_jid') and self.remote_jid:\r\n                query += \" AND key->>'remoteJid' = :remote_jid\"\r\n                params[\"remote_jid\"] = str(self.remote_jid).strip()\r\n\r\n            # Add push name filter if specified\r\n            if hasattr(self, 'push_name') and self.push_name:\r\n                query += ' AND \"pushName\" = :push_name'\r\n                params[\"push_name\"] = str(self.push_name).strip()\r\n\r\n            # Add timestamp range if specified\r\n            if hasattr(self, 'start_time') and self.start_time:\r\n                query += ' AND \"messageTimestamp\" >= (extract(epoch from timestamp :start_time)::bigint)'\r\n                params[\"start_time\"] = str(self.start_time).strip()\r\n            if hasattr(self, 'end_time') and self.end_time:\r\n                query += ' AND \"messageTimestamp\" <= (extract(epoch from timestamp :end_time)::bigint)'\r\n                params[\"end_time\"] = str(self.end_time).strip()\r\n\r\n            # Add ORDER BY\r\n            query += f' ORDER BY \"messageTimestamp\" {self.sort_direction}'\r\n\r\n            # Add pagination\r\n            page = max(1, self.page)\r\n            page_size = max(1, self.page_size)\r\n            offset = (page - 1) * page_size\r\n            query += \" LIMIT :limit OFFSET :offset\"\r\n            params.update({\"limit\": page_size, \"offset\": offset})\r\n\r\n            return query, params\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error building query: {str(e)}\")\r\n            raise ValueError(f\"Failed to build query: {str(e)}\") from e\r\n\r\n    def execute_query(self) -> List[Data]:\r\n        \"\"\"Execute the query and return results with all fields.\"\"\"\r\n        try:\r\n            query, params = self.build_query()\r\n            self.log(f\"Executing query: {query} with params: {params}\")\r\n\r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                # Execute main query\r\n                result = conn.execute(text(query), params)\r\n                rows = [dict(zip(row._fields, row)) for row in result]\r\n\r\n                # Get total count\r\n                count_query = '''\r\n                    SELECT COUNT(*) \r\n                    FROM public.\"Message\"\r\n                    WHERE \"messageType\" = 'audioMessage'\r\n                '''\r\n                count_params = {}\r\n                \r\n                # Add message ID filter to count query\r\n                if hasattr(self, 'message_id') and self.message_id:\r\n                    count_query += \" AND key->>'id' = :message_id\"\r\n                    count_params[\"message_id\"] = str(self.message_id).strip()\r\n\r\n                # Add remote JID filter to count query\r\n                if hasattr(self, 'remote_jid') and self.remote_jid:\r\n                    count_query += \" AND key->>'remoteJid' = :remote_jid\"\r\n                    count_params[\"remote_jid\"] = str(self.remote_jid).strip()\r\n\r\n                # Add push name filter to count query\r\n                if hasattr(self, 'push_name') and self.push_name:\r\n                    count_query += ' AND \"pushName\" = :push_name'\r\n                    count_params[\"push_name\"] = str(self.push_name).strip()\r\n\r\n                # Add timestamp range to count query\r\n                if hasattr(self, 'start_time') and self.start_time:\r\n                    count_query += ' AND \"messageTimestamp\" >= (extract(epoch from timestamp :start_time)::bigint)'\r\n                    count_params[\"start_time\"] = str(self.start_time).strip()\r\n                if hasattr(self, 'end_time') and self.end_time:\r\n                    count_query += ' AND \"messageTimestamp\" <= (extract(epoch from timestamp :end_time)::bigint)'\r\n                    count_params[\"end_time\"] = str(self.end_time).strip()\r\n\r\n                count_result = conn.execute(text(count_query), count_params)\r\n                total_count = count_result.scalar()\r\n\r\n            # Convert rows to Data objects with pagination info\r\n            return [\r\n                Data(\r\n                    data={\r\n                        \"messageTimestamp\": row[\"messageTimestamp\"],\r\n                        \"key\": row[\"key\"],\r\n                        \"pushName\": row[\"pushName\"],\r\n                        \"message\": row[\"message\"],\r\n                        \"contextInfo\": row[\"contextInfo\"],\r\n                        \"parsed_url\": self.parse_media_url(row[\"message\"]),\r\n                        \"__meta__\": {\r\n                            \"total_records\": total_count,\r\n                            \"page\": self.page,\r\n                            \"page_size\": self.page_size,\r\n                            \"total_pages\": -(-total_count // self.page_size)\r\n                        }\r\n                    }\r\n                )\r\n                for row in rows\r\n            ]\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error executing query: {str(e)}\")\r\n            raise ValueError(f\"Query execution failed: {str(e)}\") from e\r\n\r\n    def get_parsed_urls(self) -> List[Data]:\r\n        \"\"\"Return just the parsed URLs from the audio messages.\"\"\"\r\n        try:\r\n            query, params = self.build_query()\r\n            \r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                result = conn.execute(text(query), params)\r\n                rows = [dict(zip(row._fields, row)) for row in result]\r\n\r\n            # Return just the parsed URLs\r\n            return [\r\n                Data(\r\n                    data={\r\n                        \"url\": self.parse_media_url(row[\"message\"])\r\n                    }\r\n                )\r\n                for row in rows\r\n                if self.parse_media_url(row[\"message\"]) is not None\r\n            ]\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error getting parsed URLs: {str(e)}\")\r\n            raise ValueError(f\"Failed to get parsed URLs: {str(e)}\") from e","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"connection_string":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"connection_string","value":"postgresql://evolution_user:Duassenha2024@192.168.112.131:5432/evolution_db","display_name":"Connection String","advanced":false,"dynamic":false,"info":"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)","title_case":false,"type":"str","_input_type":"StrInput"},"end_time":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"end_time","value":"","display_name":"End Time","advanced":true,"input_types":["Message"],"dynamic":false,"info":"End time (YYYY-MM-DD HH:MM:SS)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"message_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"message_id","value":"","display_name":"Message ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Find specific audio message by ID","title_case":false,"type":"str","_input_type":"MessageTextInput"},"page":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":true,"placeholder":"","show":true,"name":"page","value":1,"display_name":"Page","advanced":true,"dynamic":false,"info":"Page number (starts at 1)","title_case":false,"type":"int","_input_type":"IntInput"},"page_size":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":true,"placeholder":"","show":true,"name":"page_size","value":100,"display_name":"Page Size","advanced":true,"dynamic":false,"info":"Number of records per page","title_case":false,"type":"int","_input_type":"IntInput"},"push_name":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"push_name","value":"","display_name":"Push Name","advanced":true,"input_types":["Message"],"dynamic":false,"info":"Filter by contact name","title_case":false,"type":"str","_input_type":"MessageTextInput"},"remote_jid":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"remote_jid","value":"","display_name":"Remote JID","advanced":true,"input_types":["Message"],"dynamic":false,"info":"Filter by remote JID (e.g., 555199999999@s.whatsapp.net)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"sort_direction":{"tool_mode":false,"trace_as_metadata":true,"options":["ASC","DESC"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"sort_direction","value":"DESC","display_name":"Sort Direction","advanced":true,"dynamic":false,"info":"Sort direction by messageTimestamp","title_case":false,"type":"str","_input_type":"DropdownInput"},"start_time":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"start_time","value":"","display_name":"Start Time","advanced":true,"input_types":["Message"],"dynamic":false,"info":"Start time (YYYY-MM-DD HH:MM:SS)","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Query audio messages from Evolution database with different filter options","icon":"mic","base_classes":["Data"],"display_name":"Evolution Audio Message Query","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"messages","display_name":"Messages","method":"execute_query","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"parsed_urls","display_name":"Parsed URLs","method":"get_parsed_urls","value":"__UNDEFINED__","cache":true}],"field_order":["connection_string","message_id","remote_jid","push_name","start_time","end_time","sort_direction","page_size","page"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev22"},"type":"CustomComponent","id":"CustomComponent-8HviC"},"selected":false,"measured":{"width":320,"height":387},"dragging":false},{"id":"ParseData-aBR0L","type":"genericNode","position":{"x":-774.0163608559474,"y":-959.3006206115476},"data":{"node":{"template":{"_type":"Component","data":{"tool_mode":false,"trace_as_metadata":true,"list":true,"trace_as_input":true,"required":false,"placeholder":"","show":true,"name":"data","value":"","display_name":"Data","advanced":false,"input_types":["Data"],"dynamic":false,"info":"The data to convert to text.","title_case":false,"type":"other","_input_type":"DataInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from langflow.custom import Component\nfrom langflow.helpers.data import data_to_text, data_to_text_list\nfrom langflow.io import DataInput, MultilineInput, Output, StrInput\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\n\n\nclass ParseDataComponent(Component):\n    display_name = \"Parse Data\"\n    description = \"Convert Data into plain text following a specified template.\"\n    icon = \"braces\"\n    name = \"ParseData\"\n\n    inputs = [\n        DataInput(name=\"data\", display_name=\"Data\", info=\"The data to convert to text.\", is_list=True),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. \"\n            \"It can contain the keys {text}, {data} or any other key in the Data.\",\n            value=\"{text}\",\n        ),\n        StrInput(name=\"sep\", display_name=\"Separator\", advanced=True, value=\"\\n\"),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Text\",\n            name=\"text\",\n            info=\"Data as a single Message, with each input Data separated by Separator\",\n            method=\"parse_data\",\n        ),\n        Output(\n            display_name=\"Data List\",\n            name=\"data_list\",\n            info=\"Data as a list of new Data, each having `text` formatted by Template\",\n            method=\"parse_data_as_list\",\n        ),\n    ]\n\n    def _clean_args(self) -> tuple[list[Data], str, str]:\n        data = self.data if isinstance(self.data, list) else [self.data]\n        template = self.template\n        sep = self.sep\n        return data, template, sep\n\n    def parse_data(self) -> Message:\n        data, template, _ = self._clean_args()\n        if not data:\n            return Message(text=\"\")\n        result_string = data_to_text(template, [data[0]], \"\")\n        self.status = result_string\n        return Message(text=result_string)\n\n    def parse_data_as_list(self) -> list[Data]:\n        data, template, _ = self._clean_args()\n        text_list, data_list = data_to_text_list(template, data)\n        for item, text in zip(data_list, text_list, strict=True):\n            item.set_text(text)\n        self.status = data_list\n        return data_list\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"sep":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"sep","value":"\n","display_name":"Separator","advanced":true,"dynamic":false,"info":"","title_case":false,"type":"str","_input_type":"StrInput"},"template":{"tool_mode":false,"trace_as_input":true,"multiline":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"template","value":"{url}","display_name":"Template","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The template to use for formatting the data. It can contain the keys {text}, {data} or any other key in the Data.","title_case":false,"type":"str","_input_type":"MultilineInput"}},"description":"Convert Data into plain text following a specified template.","icon":"braces","base_classes":["Data","Message"],"display_name":"Parse Data","documentation":"","minimized":false,"custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"text","display_name":"Text","method":"parse_data","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"data_list","display_name":"Data List","method":"parse_data_as_list","value":"__UNDEFINED__","cache":true}],"field_order":["data","template","sep"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev22"},"type":"ParseData","id":"ParseData-aBR0L"},"selected":false,"measured":{"width":320,"height":349},"dragging":false},{"id":"CustomComponent-vcp3H","type":"genericNode","position":{"x":-1528.7046160381474,"y":-1083.460390826498},"data":{"node":{"template":{"_type":"Component","case_sensitive":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"case_sensitive","value":false,"display_name":"Case Sensitive","advanced":false,"dynamic":false,"info":"If true, the comparison will be case sensitive.","title_case":false,"type":"bool","_input_type":"BoolInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import re\r\nfrom typing import List\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageInput, MessageTextInput, Output\r\nfrom langflow.schema.message import Message\r\n\r\n\r\nclass ConditionalRouterComponent(Component):\r\n    display_name = \"If-Else\"\r\n    description = \"Routes an input message based on multiple text comparisons combined with AND/OR.\"\r\n    icon = \"split\"\r\n    name = \"ConditionalRouter\"\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        super().__init__(*args, **kwargs)\r\n        self.__iteration_updated = False\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"input_text\",\r\n            display_name=\"Text Input\",\r\n            info=\"The primary text input for the operation.\",\r\n        ),\r\n        MessageTextInput(\r\n            name=\"match_text\",\r\n            display_name=\"Match Text\",\r\n            info=\"Text to compare against. Add multiple entries for multiple conditions.\",\r\n            is_list=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"operator\",\r\n            display_name=\"Comparison Operator\",\r\n            options=[\"equals\", \"not equals\", \"contains\", \"starts with\", \"ends with\", \"matches regex\"],\r\n            info=\"The operator to use for all text comparisons.\",\r\n            value=\"equals\",\r\n            real_time_refresh=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"logical_operator\",\r\n            display_name=\"Logical Operator\",\r\n            options=[\"or\", \"and\"],\r\n            info=\"How to combine multiple conditions (OR: any match true, AND: all matches true).\",\r\n            value=\"or\",\r\n        ),\r\n        BoolInput(\r\n            name=\"case_sensitive\",\r\n            display_name=\"Case Sensitive\",\r\n            info=\"If true, the comparison will be case sensitive.\",\r\n            value=False,\r\n        ),\r\n        MessageInput(\r\n            name=\"message\",\r\n            display_name=\"Message\",\r\n            info=\"The message to pass through either route.\",\r\n            advanced=True,\r\n        ),\r\n        IntInput(\r\n            name=\"max_iterations\",\r\n            display_name=\"Max Iterations\",\r\n            info=\"The maximum number of iterations for the conditional router.\",\r\n            value=10,\r\n            advanced=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"default_route\",\r\n            display_name=\"Default Route\",\r\n            options=[\"true_result\", \"false_result\"],\r\n            info=\"The default route to take when max iterations are reached.\",\r\n            value=\"false_result\",\r\n            advanced=True,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(display_name=\"True\", name=\"true_result\", method=\"true_response\"),\r\n        Output(display_name=\"False\", name=\"false_result\", method=\"false_response\"),\r\n    ]\r\n\r\n    def _pre_run_setup(self):\r\n        self.__iteration_updated = False\r\n\r\n    def evaluate_single_condition(\r\n        self, input_text: str, match_text: str, operator: str, *, case_sensitive: bool\r\n    ) -> bool:\r\n        if not match_text:\r\n            return False\r\n            \r\n        if not case_sensitive and operator != \"matches regex\":\r\n            input_text = input_text.lower()\r\n            match_text = match_text.lower()\r\n\r\n        if operator == \"equals\":\r\n            return input_text == match_text\r\n        if operator == \"not equals\":\r\n            return input_text != match_text\r\n        if operator == \"contains\":\r\n            return match_text in input_text\r\n        if operator == \"starts with\":\r\n            return input_text.startswith(match_text)\r\n        if operator == \"ends with\":\r\n            return input_text.endswith(match_text)\r\n        if operator == \"matches regex\":\r\n            try:\r\n                return bool(re.match(match_text, input_text))\r\n            except re.error:\r\n                return False\r\n        return False\r\n\r\n    def evaluate_conditions(\r\n        self,\r\n        input_text: str,\r\n        match_texts: List[str],\r\n        operator: str,\r\n        logical_operator: str,\r\n        case_sensitive: bool,\r\n    ) -> bool:\r\n        if not match_texts:\r\n            return False\r\n            \r\n        results = [\r\n            self.evaluate_single_condition(input_text, match_text, operator, case_sensitive=case_sensitive)\r\n            for match_text in match_texts\r\n        ]\r\n        \r\n        return any(results) if logical_operator == \"or\" else all(results)\r\n\r\n    def iterate_and_stop_once(self, route_to_stop: str):\r\n        if not self.__iteration_updated:\r\n            self.update_ctx({f\"{self._id}_iteration\": self.ctx.get(f\"{self._id}_iteration\", 0) + 1})\r\n            self.__iteration_updated = True\r\n            if self.ctx.get(f\"{self._id}_iteration\", 0) >= self.max_iterations and route_to_stop == self.default_route:\r\n                route_to_stop = \"true_result\" if route_to_stop == \"false_result\" else \"false_result\"\r\n            self.stop(route_to_stop)\r\n\r\n    def true_response(self) -> Message:\r\n        result = self.evaluate_conditions(\r\n            self.input_text,\r\n            self.match_text,\r\n            self.operator,\r\n            self.logical_operator,\r\n            self.case_sensitive,\r\n        )\r\n        if result:\r\n            self.status = self.message\r\n            self.iterate_and_stop_once(\"false_result\")\r\n            return self.message\r\n        self.iterate_and_stop_once(\"true_result\")\r\n        return Message(content=\"\")\r\n\r\n    def false_response(self) -> Message:\r\n        result = self.evaluate_conditions(\r\n            self.input_text,\r\n            self.match_text,\r\n            self.operator,\r\n            self.logical_operator,\r\n            self.case_sensitive,\r\n        )\r\n        if not result:\r\n            self.status = self.message\r\n            self.iterate_and_stop_once(\"true_result\")\r\n            return self.message\r\n        self.iterate_and_stop_once(\"false_result\")\r\n        return Message(content=\"\")\r\n\r\n    def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None) -> dict:\r\n        if field_name == \"operator\":\r\n            if field_value == \"matches regex\":\r\n                if \"case_sensitive\" in build_config:\r\n                    del build_config[\"case_sensitive\"]\r\n            elif \"case_sensitive\" not in build_config:\r\n                case_sensitive_input = next(\r\n                    (input_field for input_field in self.inputs if input_field.name == \"case_sensitive\"), None\r\n                )\r\n                if case_sensitive_input:\r\n                    build_config[\"case_sensitive\"] = case_sensitive_input.to_dict()\r\n        return build_config","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"default_route":{"tool_mode":false,"trace_as_metadata":true,"options":["true_result","false_result"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"default_route","value":"false_result","display_name":"Default Route","advanced":true,"dynamic":false,"info":"The default route to take when max iterations are reached.","title_case":false,"type":"str","_input_type":"DropdownInput"},"input_text":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"input_text","value":"","display_name":"Text Input","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The primary text input for the operation.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"logical_operator":{"tool_mode":false,"trace_as_metadata":true,"options":["or","and"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"logical_operator","value":"or","display_name":"Logical Operator","advanced":false,"dynamic":false,"info":"How to combine multiple conditions (OR: any match true, AND: all matches true).","title_case":false,"type":"str","_input_type":"DropdownInput"},"match_text":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":true,"required":false,"placeholder":"","show":true,"name":"match_text","value":["🔇","🙉"],"display_name":"Match Text","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Text to compare against. Add multiple entries for multiple conditions.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"max_iterations":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"max_iterations","value":10,"display_name":"Max Iterations","advanced":true,"dynamic":false,"info":"The maximum number of iterations for the conditional router.","title_case":false,"type":"int","_input_type":"IntInput"},"message":{"trace_as_input":true,"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"message","value":"","display_name":"Message","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The message to pass through either route.","title_case":false,"type":"str","_input_type":"MessageInput"},"operator":{"tool_mode":false,"trace_as_metadata":true,"options":["equals","not equals","contains","starts with","ends with","matches regex"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"operator","value":"equals","display_name":"Comparison Operator","advanced":false,"dynamic":false,"info":"The operator to use for all text comparisons.","real_time_refresh":true,"title_case":false,"type":"str","_input_type":"DropdownInput"}},"description":"Routes an input message based on multiple text comparisons combined with AND/OR.","icon":"split","base_classes":["Message"],"display_name":"If-Else","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"true_result","display_name":"True","method":"true_response","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"false_result","display_name":"False","method":"false_response","value":"__UNDEFINED__","cache":true}],"field_order":["input_text","match_text","operator","logical_operator","case_sensitive","message","max_iterations","default_route"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev22"},"type":"CustomComponent","id":"CustomComponent-vcp3H"},"selected":false,"measured":{"width":320,"height":741},"dragging":false},{"id":"OpenAIModel-c8ESN","type":"genericNode","position":{"x":11.504748176278213,"y":-1004.831990856372},"data":{"node":{"template":{"_type":"Component","temperature":{"tool_mode":false,"min_label":"","max_label":"","min_label_icon":"","max_label_icon":"","slider_buttons":false,"slider_buttons_options":[],"slider_input":false,"range_spec":{"step_type":"float","min":0,"max":2,"step":0.01},"required":false,"placeholder":"","show":true,"name":"temperature","value":0.1,"display_name":"Temperature","advanced":false,"dynamic":false,"info":"","title_case":false,"type":"slider","_input_type":"SliderInput"},"api_key":{"load_from_db":true,"required":false,"placeholder":"","show":true,"name":"api_key","value":"OPENAI_API_KEY","display_name":"OpenAI API Key","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The OpenAI API Key to use for the OpenAI model.","title_case":false,"password":true,"type":"str","_input_type":"SecretStrInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from langchain_openai import ChatOpenAI\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.base.models.openai_constants import OPENAI_MODEL_NAMES\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs import BoolInput, DictInput, DropdownInput, IntInput, SecretStrInput, SliderInput, StrInput\n\n\nclass OpenAIModelComponent(LCModelComponent):\n    display_name = \"OpenAI\"\n    description = \"Generates text using OpenAI LLMs.\"\n    icon = \"OpenAI\"\n    name = \"OpenAIModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            info=\"The maximum number of tokens to generate. Set to 0 for unlimited tokens.\",\n            range_spec=RangeSpec(min=0, max=128000),\n        ),\n        DictInput(\n            name=\"model_kwargs\",\n            display_name=\"Model Kwargs\",\n            advanced=True,\n            info=\"Additional keyword arguments to pass to the model.\",\n        ),\n        BoolInput(\n            name=\"json_mode\",\n            display_name=\"JSON Mode\",\n            advanced=True,\n            info=\"If True, it will output JSON regardless of passing a schema.\",\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            advanced=False,\n            options=OPENAI_MODEL_NAMES,\n            value=OPENAI_MODEL_NAMES[0],\n        ),\n        StrInput(\n            name=\"openai_api_base\",\n            display_name=\"OpenAI API Base\",\n            advanced=True,\n            info=\"The base URL of the OpenAI API. \"\n            \"Defaults to https://api.openai.com/v1. \"\n            \"You can change this to use other APIs like JinaChat, LocalAI and Prem.\",\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"OpenAI API Key\",\n            info=\"The OpenAI API Key to use for the OpenAI model.\",\n            advanced=False,\n            value=\"OPENAI_API_KEY\",\n        ),\n        SliderInput(\n            name=\"temperature\", display_name=\"Temperature\", value=0.1, range_spec=RangeSpec(min=0, max=2, step=0.01)\n        ),\n        IntInput(\n            name=\"seed\",\n            display_name=\"Seed\",\n            info=\"The seed controls the reproducibility of the job.\",\n            advanced=True,\n            value=1,\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        openai_api_key = self.api_key\n        temperature = self.temperature\n        model_name: str = self.model_name\n        max_tokens = self.max_tokens\n        model_kwargs = self.model_kwargs or {}\n        openai_api_base = self.openai_api_base or \"https://api.openai.com/v1\"\n        json_mode = self.json_mode\n        seed = self.seed\n\n        api_key = SecretStr(openai_api_key).get_secret_value() if openai_api_key else None\n        output = ChatOpenAI(\n            max_tokens=max_tokens or None,\n            model_kwargs=model_kwargs,\n            model=model_name,\n            base_url=openai_api_base,\n            api_key=api_key,\n            temperature=temperature if temperature is not None else 0.1,\n            seed=seed,\n        )\n        if json_mode:\n            output = output.bind(response_format={\"type\": \"json_object\"})\n\n        return output\n\n    def _get_exception_message(self, e: Exception):\n        \"\"\"Get a message from an OpenAI exception.\n\n        Args:\n            e (Exception): The exception to get the message from.\n\n        Returns:\n            str: The message from the exception.\n        \"\"\"\n        try:\n            from openai import BadRequestError\n        except ImportError:\n            return None\n        if isinstance(e, BadRequestError):\n            message = e.body.get(\"message\")\n            if message:\n                return message\n        return None\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"input_value":{"trace_as_input":true,"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"input_value","value":"","display_name":"Input","advanced":false,"input_types":["Message"],"dynamic":false,"info":"","title_case":false,"type":"str","_input_type":"MessageInput"},"json_mode":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"json_mode","value":false,"display_name":"JSON Mode","advanced":true,"dynamic":false,"info":"If True, it will output JSON regardless of passing a schema.","title_case":false,"type":"bool","_input_type":"BoolInput"},"max_tokens":{"tool_mode":false,"trace_as_metadata":true,"range_spec":{"step_type":"float","min":0,"max":128000,"step":0.1},"list":false,"required":false,"placeholder":"","show":true,"name":"max_tokens","value":"","display_name":"Max Tokens","advanced":true,"dynamic":false,"info":"The maximum number of tokens to generate. Set to 0 for unlimited tokens.","title_case":false,"type":"int","_input_type":"IntInput"},"model_kwargs":{"tool_mode":false,"trace_as_input":true,"list":false,"required":false,"placeholder":"","show":true,"name":"model_kwargs","value":{},"display_name":"Model Kwargs","advanced":true,"dynamic":false,"info":"Additional keyword arguments to pass to the model.","title_case":false,"type":"dict","_input_type":"DictInput"},"model_name":{"tool_mode":false,"trace_as_metadata":true,"options":["gpt-4o-mini","gpt-4o","gpt-4-turbo","gpt-4-turbo-preview","gpt-4","gpt-3.5-turbo","gpt-3.5-turbo-0125"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"model_name","value":"gpt-4o-mini","display_name":"Model Name","advanced":false,"dynamic":false,"info":"","title_case":false,"type":"str","_input_type":"DropdownInput"},"openai_api_base":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"openai_api_base","value":"","display_name":"OpenAI API Base","advanced":true,"dynamic":false,"info":"The base URL of the OpenAI API. Defaults to https://api.openai.com/v1. You can change this to use other APIs like JinaChat, LocalAI and Prem.","title_case":false,"type":"str","_input_type":"StrInput"},"seed":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"seed","value":1,"display_name":"Seed","advanced":true,"dynamic":false,"info":"The seed controls the reproducibility of the job.","title_case":false,"type":"int","_input_type":"IntInput"},"stream":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"stream","value":false,"display_name":"Stream","advanced":false,"dynamic":false,"info":"Stream the response from the model. Streaming works only in Chat.","title_case":false,"type":"bool","_input_type":"BoolInput"},"system_message":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"system_message","value":"You are responsible for making whatsapp audio transcriptions better Human readable. Only output the rewritten message","display_name":"System Message","advanced":false,"input_types":["Message"],"dynamic":false,"info":"System message to pass to the model.","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Generates text using OpenAI LLMs.","icon":"OpenAI","base_classes":["LanguageModel","Message"],"display_name":"OpenAI","documentation":"","minimized":false,"custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"text_output","display_name":"Text","method":"text_response","value":"__UNDEFINED__","cache":true,"required_inputs":[]},{"types":["LanguageModel"],"selected":"LanguageModel","name":"model_output","display_name":"Language Model","method":"build_model","value":"__UNDEFINED__","cache":true,"required_inputs":[]}],"field_order":["input_value","system_message","stream","max_tokens","model_kwargs","json_mode","model_name","openai_api_base","api_key","temperature","seed"],"beta":false,"legacy":false,"edited":false,"metadata":{},"tool_mode":false,"category":"models","key":"OpenAIModel","score":2.220446049250313e-16,"lf_version":"1.1.1.dev22"},"showNode":true,"type":"OpenAIModel","id":"OpenAIModel-c8ESN"},"selected":false,"measured":{"width":320,"height":685},"dragging":false}],"edges":[{"source":"CustomComponent-Pn9Li","sourceHandle":"{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-Pn9Liœ,œnameœ:œmessageœ,œoutput_typesœ:[œDataœ]}","target":"ParseData-7WaOm","targetHandle":"{œfieldNameœ:œdataœ,œidœ:œParseData-7WaOmœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","data":{"targetHandle":{"fieldName":"data","id":"ParseData-7WaOm","inputTypes":["Data"],"type":"other"},"sourceHandle":{"dataType":"CustomComponent","id":"CustomComponent-Pn9Li","name":"message","output_types":["Data"]}},"id":"reactflow__edge-CustomComponent-Pn9Li{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-Pn9Liœ,œnameœ:œmessageœ,œoutput_typesœ:[œDataœ]}-ParseData-7WaOm{œfieldNameœ:œdataœ,œidœ:œParseData-7WaOmœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","animated":false,"className":"","selected":false},{"source":"ParseData-7WaOm","sourceHandle":"{œdataTypeœ:œParseDataœ,œidœ:œParseData-7WaOmœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}","target":"ChatOutput-TzYh9","targetHandle":"{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-TzYh9œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"input_value","id":"ChatOutput-TzYh9","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"ParseData","id":"ParseData-7WaOm","name":"text","output_types":["Message"]}},"id":"reactflow__edge-ParseData-7WaOm{œdataTypeœ:œParseDataœ,œidœ:œParseData-7WaOmœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-TzYh9{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-TzYh9œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","animated":false,"className":"","selected":false},{"source":"Webhook-JOUAz","sourceHandle":"{œdataTypeœ:œWebhookœ,œidœ:œWebhook-JOUAzœ,œnameœ:œoutput_dataœ,œoutput_typesœ:[œDataœ]}","target":"CustomComponent-0GoMy","targetHandle":"{œfieldNameœ:œdataœ,œidœ:œCustomComponent-0GoMyœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","data":{"targetHandle":{"fieldName":"data","id":"CustomComponent-0GoMy","inputTypes":["Data"],"type":"other"},"sourceHandle":{"dataType":"Webhook","id":"Webhook-JOUAz","name":"output_data","output_types":["Data"]}},"id":"reactflow__edge-Webhook-JOUAz{œdataTypeœ:œWebhookœ,œidœ:œWebhook-JOUAzœ,œnameœ:œoutput_dataœ,œoutput_typesœ:[œDataœ]}-CustomComponent-0GoMy{œfieldNameœ:œdataœ,œidœ:œCustomComponent-0GoMyœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","animated":false,"className":"","selected":false},{"source":"Webhook-JOUAz","sourceHandle":"{œdataTypeœ:œWebhookœ,œidœ:œWebhook-JOUAzœ,œnameœ:œraw_payloadœ,œoutput_typesœ:[œMessageœ]}","target":"ChatOutput-UlBVK","targetHandle":"{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-UlBVKœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"input_value","id":"ChatOutput-UlBVK","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"Webhook","id":"Webhook-JOUAz","name":"raw_payload","output_types":["Message"]}},"id":"reactflow__edge-Webhook-JOUAz{œdataTypeœ:œWebhookœ,œidœ:œWebhook-JOUAzœ,œnameœ:œraw_payloadœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-UlBVK{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-UlBVKœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","animated":false,"className":"","selected":false},{"source":"CustomComponent-8HviC","sourceHandle":"{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-8HviCœ,œnameœ:œparsed_urlsœ,œoutput_typesœ:[œDataœ]}","target":"ParseData-aBR0L","targetHandle":"{œfieldNameœ:œdataœ,œidœ:œParseData-aBR0Lœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","data":{"targetHandle":{"fieldName":"data","id":"ParseData-aBR0L","inputTypes":["Data"],"type":"other"},"sourceHandle":{"dataType":"CustomComponent","id":"CustomComponent-8HviC","name":"parsed_urls","output_types":["Data"]}},"id":"reactflow__edge-CustomComponent-8HviC{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-8HviCœ,œnameœ:œparsed_urlsœ,œoutput_typesœ:[œDataœ]}-ParseData-aBR0L{œfieldNameœ:œdataœ,œidœ:œParseData-aBR0Lœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","animated":false,"className":"","selected":false},{"source":"ParseData-aBR0L","sourceHandle":"{œdataTypeœ:œParseDataœ,œidœ:œParseData-aBR0Lœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}","target":"CustomComponent-ObIjr","targetHandle":"{œfieldNameœ:œaudio_urlœ,œidœ:œCustomComponent-ObIjrœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"audio_url","id":"CustomComponent-ObIjr","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"ParseData","id":"ParseData-aBR0L","name":"text","output_types":["Message"]}},"id":"reactflow__edge-ParseData-aBR0L{œdataTypeœ:œParseDataœ,œidœ:œParseData-aBR0Lœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-CustomComponent-ObIjr{œfieldNameœ:œaudio_urlœ,œidœ:œCustomComponent-ObIjrœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","animated":false,"className":"","selected":false},{"source":"CustomComponent-0GoMy","sourceHandle":"{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-0GoMyœ,œnameœ:œmessage_contentœ,œoutput_typesœ:[œMessageœ]}","target":"CustomComponent-vcp3H","targetHandle":"{œfieldNameœ:œinput_textœ,œidœ:œCustomComponent-vcp3Hœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"input_text","id":"CustomComponent-vcp3H","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"CustomComponent","id":"CustomComponent-0GoMy","name":"message_content","output_types":["Message"]}},"id":"reactflow__edge-CustomComponent-0GoMy{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-0GoMyœ,œnameœ:œmessage_contentœ,œoutput_typesœ:[œMessageœ]}-CustomComponent-vcp3H{œfieldNameœ:œinput_textœ,œidœ:œCustomComponent-vcp3Hœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","animated":false,"className":"","selected":false},{"source":"CustomComponent-0GoMy","sourceHandle":"{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-0GoMyœ,œnameœ:œmessage_idœ,œoutput_typesœ:[œMessageœ]}","target":"CustomComponent-vcp3H","targetHandle":"{œfieldNameœ:œmessageœ,œidœ:œCustomComponent-vcp3Hœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"message","id":"CustomComponent-vcp3H","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"CustomComponent","id":"CustomComponent-0GoMy","name":"message_id","output_types":["Message"]}},"id":"reactflow__edge-CustomComponent-0GoMy{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-0GoMyœ,œnameœ:œmessage_idœ,œoutput_typesœ:[œMessageœ]}-CustomComponent-vcp3H{œfieldNameœ:œmessageœ,œidœ:œCustomComponent-vcp3Hœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","animated":false,"className":"","selected":false},{"source":"CustomComponent-vcp3H","sourceHandle":"{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-vcp3Hœ,œnameœ:œtrue_resultœ,œoutput_typesœ:[œMessageœ]}","target":"CustomComponent-8HviC","targetHandle":"{œfieldNameœ:œmessage_idœ,œidœ:œCustomComponent-8HviCœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"message_id","id":"CustomComponent-8HviC","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"CustomComponent","id":"CustomComponent-vcp3H","name":"true_result","output_types":["Message"]}},"id":"reactflow__edge-CustomComponent-vcp3H{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-vcp3Hœ,œnameœ:œtrue_resultœ,œoutput_typesœ:[œMessageœ]}-CustomComponent-8HviC{œfieldNameœ:œmessage_idœ,œidœ:œCustomComponent-8HviCœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","className":"","animated":false,"selected":false},{"source":"CustomComponent-0GoMy","sourceHandle":"{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-0GoMyœ,œnameœ:œremote_jidœ,œoutput_typesœ:[œMessageœ]}","target":"CustomComponent-Pn9Li","targetHandle":"{œfieldNameœ:œnumberœ,œidœ:œCustomComponent-Pn9Liœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"number","id":"CustomComponent-Pn9Li","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"CustomComponent","id":"CustomComponent-0GoMy","name":"remote_jid","output_types":["Message"]}},"id":"reactflow__edge-CustomComponent-0GoMy{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-0GoMyœ,œnameœ:œremote_jidœ,œoutput_typesœ:[œMessageœ]}-CustomComponent-Pn9Li{œfieldNameœ:œnumberœ,œidœ:œCustomComponent-Pn9Liœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","className":"","selected":false,"animated":false},{"source":"CustomComponent-vcp3H","sourceHandle":"{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-vcp3Hœ,œnameœ:œtrue_resultœ,œoutput_typesœ:[œMessageœ]}","target":"CustomComponent-Pn9Li","targetHandle":"{œfieldNameœ:œquoted_message_idœ,œidœ:œCustomComponent-Pn9Liœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"quoted_message_id","id":"CustomComponent-Pn9Li","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"CustomComponent","id":"CustomComponent-vcp3H","name":"true_result","output_types":["Message"]}},"id":"reactflow__edge-CustomComponent-vcp3H{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-vcp3Hœ,œnameœ:œtrue_resultœ,œoutput_typesœ:[œMessageœ]}-CustomComponent-Pn9Li{œfieldNameœ:œquoted_message_idœ,œidœ:œCustomComponent-Pn9Liœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","className":"","selected":false,"animated":false},{"source":"OpenAIModel-c8ESN","sourceHandle":"{œdataTypeœ:œOpenAIModelœ,œidœ:œOpenAIModel-c8ESNœ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}","target":"CustomComponent-Pn9Li","targetHandle":"{œfieldNameœ:œtextœ,œidœ:œCustomComponent-Pn9Liœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"text","id":"CustomComponent-Pn9Li","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"OpenAIModel","id":"OpenAIModel-c8ESN","name":"text_output","output_types":["Message"]}},"id":"xy-edge__OpenAIModel-c8ESN{œdataTypeœ:œOpenAIModelœ,œidœ:œOpenAIModel-c8ESNœ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}-CustomComponent-Pn9Li{œfieldNameœ:œtextœ,œidœ:œCustomComponent-Pn9Liœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","animated":false,"className":""},{"source":"CustomComponent-ObIjr","sourceHandle":"{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-ObIjrœ,œnameœ:œtranscriptionœ,œoutput_typesœ:[œMessageœ]}","target":"OpenAIModel-c8ESN","targetHandle":"{œfieldNameœ:œinput_valueœ,œidœ:œOpenAIModel-c8ESNœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"input_value","id":"OpenAIModel-c8ESN","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"CustomComponent","id":"CustomComponent-ObIjr","name":"transcription","output_types":["Message"]}},"id":"xy-edge__CustomComponent-ObIjr{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-ObIjrœ,œnameœ:œtranscriptionœ,œoutput_typesœ:[œMessageœ]}-OpenAIModel-c8ESN{œfieldNameœ:œinput_valueœ,œidœ:œOpenAIModel-c8ESNœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","animated":false,"className":""}],"viewport":{"x":967.9490493815772,"y":715.817989215673,"zoom":0.37907598699335754}},"is_component":false,"updated_at":"2025-01-06T18:33:40+00:00","webhook":true,"endpoint_name":"wa-audio-transcription","tags":null,"locked":null,"id":"eec7d935-f0dc-4348-af3a-f19134f9a2fb","user_id":"556fed76-1562-4baf-8a2e-ef9be2d194e4","folder_id":"22c5349e-60ef-45a2-a8ec-0debcd24f6dd"},{"name":"Untitled document (1)","description":"Crafting Conversations, One Node at a Time.","icon":null,"icon_bg_color":null,"gradient":null,"data":{"nodes":[{"id":"CustomComponent-SbL1x","type":"genericNode","position":{"x":-315.0467809534532,"y":697.9637400046553},"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from typing import List\r\nfrom sqlalchemy import create_engine, text\r\nfrom datetime import datetime\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    StrInput,\r\n    MessageTextInput,\r\n    Output,\r\n    BoolInput\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass ChatDigestComponent(Component):\r\n    display_name = \"Evolution Chat Digest\"\r\n    description = \"Generate daily digests of WhatsApp conversations for a given time period\"\r\n    icon = \"message-square\"\r\n    name = \"evolution_chat_digest\"\r\n\r\n    def __init__(self, **data):\r\n        super().__init__(**data)\r\n        self._engine = None\r\n\r\n    inputs = [\r\n        StrInput(\r\n            name=\"connection_string\",\r\n            display_name=\"Connection String\",\r\n            info=\"PostgreSQL connection string\",\r\n            required=True\r\n        ),\r\n        StrInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"start_time\",\r\n            display_name=\"Start Time\",\r\n            info=\"Start time (YYYY-MM-DD HH:MM:SS)\",\r\n            required=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"end_time\",\r\n            display_name=\"End Time\", \r\n            info=\"End time (YYYY-MM-DD HH:MM:SS)\",\r\n            required=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"remote_jid\",\r\n            display_name=\"Remote JID Filter\",\r\n            info=\"Filter by specific WhatsApp ID (optional)\",\r\n            required=False\r\n        ),\r\n        BoolInput(\r\n            name=\"include_groups\",\r\n            display_name=\"Include Group Chats\",\r\n            info=\"Include group conversations in the output\",\r\n            value=True\r\n        )\r\n    ]\r\n\r\n    outputs = [\r\n        Output(name=\"chat_digests\", display_name=\"Chat Digests\", method=\"generate_digests\"),\r\n    ]\r\n\r\n    def get_engine(self):\r\n        \"\"\"Get or create SQLAlchemy engine.\"\"\"\r\n        if not self._engine:\r\n            try:\r\n                self._engine = create_engine(self.connection_string, echo=False)\r\n            except Exception as e:\r\n                self.log(f\"Database connection error: {str(e)}\")\r\n                raise\r\n        return self._engine\r\n\r\n    def format_timestamp(self, timestamp: int) -> str:\r\n        \"\"\"Format Unix timestamp to readable date/time.\"\"\"\r\n        try:\r\n            dt = datetime.fromtimestamp(timestamp)\r\n            return dt.strftime(\"%m/%d, %H:%M\")\r\n        except Exception as e:\r\n            self.log(f\"Error formatting timestamp: {str(e)}\")\r\n            return \"\"\r\n\r\n    def generate_digests(self) -> List[Data]:\r\n        \"\"\"Generate chat digests for each conversation.\"\"\"\r\n        try:\r\n            self.log(\"Starting digest generation...\")\r\n            \r\n            # Build query with conditional filters\r\n            query = '''\r\n                SELECT \r\n                    \"messageTimestamp\",\r\n                    message,\r\n                    \"pushName\",\r\n                    key,\r\n                    (key->>'fromMe')::boolean as from_me\r\n                FROM public.\"Message\"\r\n                WHERE \"messageType\" = 'conversation'\r\n                AND \"instanceId\" = :instance_id\r\n                AND \"messageTimestamp\" >= (extract(epoch from timestamp :start_time)::bigint)\r\n                AND \"messageTimestamp\" <= (extract(epoch from timestamp :end_time)::bigint)\r\n            '''\r\n            \r\n            # Build parameters\r\n            params = {\r\n                \"instance_id\": self.instance_id,\r\n                \"start_time\": self.start_time,\r\n                \"end_time\": self.end_time\r\n            }\r\n\r\n            # Add remoteJid filter if provided\r\n            if hasattr(self, 'remote_jid') and self.remote_jid:\r\n                self.log(f\"Adding remote_jid filter: {self.remote_jid}\")\r\n                query += \" AND (key->>'remoteJid') = :remote_jid\"\r\n                params[\"remote_jid\"] = self.remote_jid.strip()\r\n\r\n            # Add group filter if not including groups\r\n            if not self.include_groups:\r\n                self.log(\"Excluding group chats\")\r\n                query += \" AND (key->>'remoteJid') LIKE '%@s.whatsapp.net'\"\r\n\r\n            # Add ordering\r\n            query += ' ORDER BY key->>\\'remoteJid\\', \"messageTimestamp\"'\r\n\r\n            self.log(f\"Query parameters: {params}\")\r\n            engine = self.get_engine()\r\n            conversations = {}\r\n            \r\n            with engine.connect() as conn:\r\n                self.log(\"Executing query...\")\r\n                result = conn.execute(text(query), params)\r\n                rows = [dict(zip(row._fields, row)) for row in result]\r\n                self.log(f\"Retrieved {len(rows)} messages\")\r\n\r\n                for row in rows:\r\n                    # Extract key info (already a dict from PostgreSQL)\r\n                    key = row[\"key\"]\r\n                    remote_jid = key.get(\"remoteJid\", \"\")\r\n                    if not remote_jid:\r\n                        self.log(\"No remoteJid found, skipping message\")\r\n                        continue\r\n\r\n                    # Initialize conversation if needed\r\n                    if remote_jid not in conversations:\r\n                        is_group = remote_jid.endswith(\"@g.us\")\r\n                        conversations[remote_jid] = {\r\n                            \"messages\": [],\r\n                            \"contact_name\": row[\"pushName\"] if not row[\"from_me\"] else None,\r\n                            \"is_group\": is_group,\r\n                            \"participants\": set()\r\n                        }\r\n\r\n                    # For group chats, track participants\r\n                    if conversations[remote_jid][\"is_group\"] and \"participant\" in key:\r\n                        conversations[remote_jid][\"participants\"].add(key[\"participant\"])\r\n\r\n                    # Update contact name if needed (only for individual chats)\r\n                    if not conversations[remote_jid][\"is_group\"] and not row[\"from_me\"]:\r\n                        conversations[remote_jid][\"contact_name\"] = row[\"pushName\"]\r\n                    \r\n                    try:\r\n                        # Format timestamp\r\n                        timestamp = self.format_timestamp(row[\"messageTimestamp\"])\r\n                        if not timestamp:\r\n                            self.log(f\"Invalid timestamp: {row['messageTimestamp']}\")\r\n                            continue\r\n\r\n                        # Get sender name\r\n                        if conversations[remote_jid][\"is_group\"]:\r\n                            name = row[\"pushName\"] or \"Unknown\"\r\n                        else:\r\n                            name = \"You\" if row[\"from_me\"] else (row[\"pushName\"] or \"Unknown\")\r\n\r\n                        # Extract message text (already a dict from PostgreSQL)\r\n                        message = row[\"message\"]\r\n                        message_text = message.get(\"conversation\", \"\") if message else \"\"\r\n                        \r\n                        if not message_text:\r\n                            self.log(\"Empty message text, skipping\")\r\n                            continue\r\n                        \r\n                        # Format and add message\r\n                        formatted_message = f\"[{timestamp}] {name}: {message_text}\"\r\n                        conversations[remote_jid][\"messages\"].append(formatted_message)\r\n                        \r\n                    except Exception as e:\r\n                        self.log(f\"Error processing message: {str(e)}\")\r\n                        continue\r\n\r\n            # Create digest for each conversation\r\n            self.log(\"Creating final digests...\")\r\n            digests = []\r\n            for remote_jid, conv in conversations.items():\r\n                chat_history = \"\\n\".join(conv[\"messages\"])\r\n                \r\n                # Prepare conversation info\r\n                chat_info = {\r\n                    \"remote_jid\": remote_jid,\r\n                    \"message_count\": len(conv[\"messages\"]),\r\n                    \"chat_history\": chat_history\r\n                }\r\n\r\n                # Add group-specific or individual chat info\r\n                if conv[\"is_group\"]:\r\n                    chat_info.update({\r\n                        \"type\": \"group\",\r\n                        \"group_name\": conv[\"contact_name\"] or \"Unknown Group\",\r\n                        \"participant_count\": len(conv[\"participants\"]),\r\n                        \"participants\": list(conv[\"participants\"])\r\n                    })\r\n                else:\r\n                    chat_info.update({\r\n                        \"type\": \"individual\",\r\n                        \"contact_name\": conv[\"contact_name\"] or \"Unknown Contact\"\r\n                    })\r\n\r\n                digests.append(Data(data=chat_info))\r\n\r\n            self.log(f\"Successfully created {len(digests)} digests\")\r\n            return digests\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error generating digests: {str(e)}\")\r\n            raise ValueError(f\"Failed to generate digests: {str(e)}\") from e","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"connection_string":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"connection_string","value":"postgresql://evolution_user:Duassenha2024@192.168.112.131:5432/evolution_db","display_name":"Connection String","advanced":false,"dynamic":false,"info":"PostgreSQL connection string","title_case":false,"type":"str","_input_type":"StrInput"},"end_time":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"end_time","value":"2024-12-27 23:59:59","display_name":"End Time","advanced":false,"input_types":["Message"],"dynamic":false,"info":"End time (YYYY-MM-DD HH:MM:SS)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"include_groups":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"include_groups","value":false,"display_name":"Include Group Chats","advanced":false,"dynamic":false,"info":"Include group conversations in the output","title_case":false,"type":"bool","_input_type":"BoolInput"},"instance_id":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"ec7ffe43-823e-4535-aa57-1ac66eff4f7f","display_name":"Instance ID","advanced":false,"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"StrInput"},"remote_jid":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"remote_jid","value":"","display_name":"Remote JID Filter","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Filter by specific WhatsApp ID (optional)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"start_time":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"start_time","value":"2024-12-23 00:00:00","display_name":"Start Time","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Start time (YYYY-MM-DD HH:MM:SS)","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Generate daily digests of WhatsApp conversations for a given time period","icon":"message-square","base_classes":["Data"],"display_name":"Evolution Chat Digest","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"chat_digests","display_name":"Chat Digests","method":"generate_digests","value":"__UNDEFINED__","cache":true}],"field_order":["connection_string","instance_id","start_time","end_time","remote_jid","include_groups"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev22","official":false},"type":"CustomComponent","id":"CustomComponent-SbL1x"},"selected":false,"measured":{"width":320,"height":643},"dragging":false},{"id":"CustomComponent-Hwsp2","type":"genericNode","position":{"x":711.2823486969723,"y":1143.3201946971576},"data":{"node":{"template":{"_type":"Component","data":{"tool_mode":false,"trace_as_metadata":true,"list":false,"trace_as_input":true,"required":false,"placeholder":"","show":true,"name":"data","value":"","display_name":"Data","advanced":false,"input_types":["Data"],"dynamic":false,"info":"The initial list of Data objects to iterate over.","title_case":false,"type":"other","_input_type":"DataInput"},"loop":{"tool_mode":false,"trace_as_metadata":true,"list":false,"trace_as_input":true,"required":false,"placeholder":"","show":true,"name":"loop","value":"","display_name":"Loop Input","advanced":false,"input_types":["Data"],"dynamic":false,"info":"Data to aggregate during the iteration.","title_case":false,"type":"other","_input_type":"DataInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from langflow.custom import Component\nfrom langflow.io import DataInput, Output\nfrom langflow.schema import Data\n\n\nclass IteratorComponent(Component):\n    display_name = \"Loop\"\n    description = (\n        \"Iterates over a list of Data objects, outputting one item at a time and aggregating results from loop inputs.\"\n    )\n    icon = \"infinity\"\n\n    inputs = [\n        DataInput(name=\"data\", display_name=\"Data\", info=\"The initial list of Data objects to iterate over.\"),\n        DataInput(name=\"loop\", display_name=\"Loop Input\", info=\"Data to aggregate during the iteration.\"),\n    ]\n\n    outputs = [\n        Output(display_name=\"Item\", name=\"item\", method=\"item_output\"),\n        Output(display_name=\"Done\", name=\"done\", method=\"done_output\"),\n    ]\n\n    def initialize_data(self):\n        \"\"\"Initialize the data list, context index, and aggregated list.\"\"\"\n        if not self.ctx.get(f\"{self._id}_initialized\", False):\n            # Ensure data is a list of Data objects\n            if isinstance(self.data, Data):\n                data_list = [self.data]\n            elif isinstance(self.data, list):\n                data_list = self.data\n            else:\n                raise ValueError(\"The 'data' input must be a list of Data objects or a single Data object.\")\n\n            # Store the initial data and context variables\n            self.update_ctx(\n                {\n                    f\"{self._id}_data\": data_list,\n                    f\"{self._id}_index\": 0,\n                    f\"{self._id}_aggregated\": [],\n                    f\"{self._id}_initialized\": True,\n                }\n            )\n\n    def item_output(self) -> Data:\n        \"\"\"Output the next item in the list.\"\"\"\n        self.initialize_data()\n\n        # Get data list and current index\n        data_list = self.ctx.get(f\"{self._id}_data\", [])\n        current_index = self.ctx.get(f\"{self._id}_index\", 0)\n\n        if current_index < len(data_list):\n            # Output current item\n            current_item = data_list[current_index]\n            self.update_ctx({f\"{self._id}_index\": current_index + 1})\n            print(\"item_output:\", current_item)\n            return current_item\n        # No more items to output\n        self.stop(\"item\")\n        return None\n\n    def done_output(self) -> Data:\n        \"\"\"Return the aggregated list once all items are processed.\"\"\"\n        self.initialize_data()\n\n        # Get data list and aggregated list\n        data_list = self.ctx.get(f\"{self._id}_data\", [])\n        aggregated = self.ctx.get(f\"{self._id}_aggregated\", [])\n\n        # Check if loop input is provided\n        loop_input = self.loop\n        if loop_input:\n            # Append loop input to aggregated list\n            aggregated.append(loop_input)\n            self.update_ctx({f\"{self._id}_aggregated\": aggregated})\n\n        # Check if aggregation is complete\n        if len(aggregated) >= len(data_list):\n            print(\"done_output:\", aggregated)\n            return [data for data in aggregated]\n        # Not all items have been processed yet\n        self.stop(\"done\")\n        return None","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false}},"description":"Iterates over a list of Data objects, outputting one item at a time and aggregating results from loop inputs.","icon":"infinity","base_classes":["Data"],"display_name":"Loop","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"item","display_name":"Item","method":"item_output","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"done","display_name":"Done","method":"done_output","value":"__UNDEFINED__","cache":true}],"field_order":["data","loop"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14"},"type":"CustomComponent","id":"CustomComponent-Hwsp2"},"selected":false,"measured":{"width":320,"height":331},"dragging":false},{"id":"OpenAIModel-nunlt","type":"genericNode","position":{"x":1597.7441011619042,"y":567.788408911311},"data":{"node":{"template":{"_type":"Component","temperature":{"tool_mode":false,"min_label":"","max_label":"","min_label_icon":"","max_label_icon":"","slider_buttons":false,"slider_buttons_options":[],"slider_input":false,"range_spec":{"step_type":"float","min":0,"max":2,"step":0.01},"required":false,"placeholder":"","show":true,"name":"temperature","value":0.1,"display_name":"Temperature","advanced":false,"dynamic":false,"info":"","title_case":false,"type":"slider","_input_type":"SliderInput"},"api_key":{"load_from_db":false,"required":false,"placeholder":"","show":true,"name":"api_key","value":"","display_name":"OpenAI API Key","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The OpenAI API Key to use for the OpenAI model.","title_case":false,"password":true,"type":"str","_input_type":"SecretStrInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from langchain_openai import ChatOpenAI\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.base.models.openai_constants import OPENAI_MODEL_NAMES\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs import BoolInput, DictInput, DropdownInput, IntInput, SecretStrInput, SliderInput, StrInput\n\n\nclass OpenAIModelComponent(LCModelComponent):\n    display_name = \"OpenAI\"\n    description = \"Generates text using OpenAI LLMs.\"\n    icon = \"OpenAI\"\n    name = \"OpenAIModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            info=\"The maximum number of tokens to generate. Set to 0 for unlimited tokens.\",\n            range_spec=RangeSpec(min=0, max=128000),\n        ),\n        DictInput(\n            name=\"model_kwargs\",\n            display_name=\"Model Kwargs\",\n            advanced=True,\n            info=\"Additional keyword arguments to pass to the model.\",\n        ),\n        BoolInput(\n            name=\"json_mode\",\n            display_name=\"JSON Mode\",\n            advanced=True,\n            info=\"If True, it will output JSON regardless of passing a schema.\",\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            advanced=False,\n            options=OPENAI_MODEL_NAMES,\n            value=OPENAI_MODEL_NAMES[0],\n        ),\n        StrInput(\n            name=\"openai_api_base\",\n            display_name=\"OpenAI API Base\",\n            advanced=True,\n            info=\"The base URL of the OpenAI API. \"\n            \"Defaults to https://api.openai.com/v1. \"\n            \"You can change this to use other APIs like JinaChat, LocalAI and Prem.\",\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"OpenAI API Key\",\n            info=\"The OpenAI API Key to use for the OpenAI model.\",\n            advanced=False,\n            value=\"OPENAI_API_KEY\",\n        ),\n        SliderInput(\n            name=\"temperature\", display_name=\"Temperature\", value=0.1, range_spec=RangeSpec(min=0, max=2, step=0.01)\n        ),\n        IntInput(\n            name=\"seed\",\n            display_name=\"Seed\",\n            info=\"The seed controls the reproducibility of the job.\",\n            advanced=True,\n            value=1,\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        openai_api_key = self.api_key\n        temperature = self.temperature\n        model_name: str = self.model_name\n        max_tokens = self.max_tokens\n        model_kwargs = self.model_kwargs or {}\n        openai_api_base = self.openai_api_base or \"https://api.openai.com/v1\"\n        json_mode = self.json_mode\n        seed = self.seed\n\n        api_key = SecretStr(openai_api_key).get_secret_value() if openai_api_key else None\n        output = ChatOpenAI(\n            max_tokens=max_tokens or None,\n            model_kwargs=model_kwargs,\n            model=model_name,\n            base_url=openai_api_base,\n            api_key=api_key,\n            temperature=temperature if temperature is not None else 0.1,\n            seed=seed,\n        )\n        if json_mode:\n            output = output.bind(response_format={\"type\": \"json_object\"})\n\n        return output\n\n    def _get_exception_message(self, e: Exception):\n        \"\"\"Get a message from an OpenAI exception.\n\n        Args:\n            e (Exception): The exception to get the message from.\n\n        Returns:\n            str: The message from the exception.\n        \"\"\"\n        try:\n            from openai import BadRequestError\n        except ImportError:\n            return None\n        if isinstance(e, BadRequestError):\n            message = e.body.get(\"message\")\n            if message:\n                return message\n        return None\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"input_value":{"trace_as_input":true,"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"input_value","value":"","display_name":"Input","advanced":false,"input_types":["Message"],"dynamic":false,"info":"","title_case":false,"type":"str","_input_type":"MessageInput"},"json_mode":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"json_mode","value":false,"display_name":"JSON Mode","advanced":true,"dynamic":false,"info":"If True, it will output JSON regardless of passing a schema.","title_case":false,"type":"bool","_input_type":"BoolInput"},"max_tokens":{"tool_mode":false,"trace_as_metadata":true,"range_spec":{"step_type":"float","min":0,"max":128000,"step":0.1},"list":false,"required":false,"placeholder":"","show":true,"name":"max_tokens","value":"","display_name":"Max Tokens","advanced":true,"dynamic":false,"info":"The maximum number of tokens to generate. Set to 0 for unlimited tokens.","title_case":false,"type":"int","_input_type":"IntInput"},"model_kwargs":{"tool_mode":false,"trace_as_input":true,"list":false,"required":false,"placeholder":"","show":true,"name":"model_kwargs","value":{},"display_name":"Model Kwargs","advanced":true,"dynamic":false,"info":"Additional keyword arguments to pass to the model.","title_case":false,"type":"dict","_input_type":"DictInput"},"model_name":{"tool_mode":false,"trace_as_metadata":true,"options":["gpt-4o-mini","gpt-4o","gpt-4-turbo","gpt-4-turbo-preview","gpt-4","gpt-3.5-turbo","gpt-3.5-turbo-0125"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"model_name","value":"gpt-4o-mini","display_name":"Model Name","advanced":false,"dynamic":false,"info":"","title_case":false,"type":"str","_input_type":"DropdownInput"},"openai_api_base":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"openai_api_base","value":"","display_name":"OpenAI API Base","advanced":true,"dynamic":false,"info":"The base URL of the OpenAI API. Defaults to https://api.openai.com/v1. You can change this to use other APIs like JinaChat, LocalAI and Prem.","title_case":false,"type":"str","_input_type":"StrInput"},"seed":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"seed","value":1,"display_name":"Seed","advanced":true,"dynamic":false,"info":"The seed controls the reproducibility of the job.","title_case":false,"type":"int","_input_type":"IntInput"},"stream":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"stream","value":false,"display_name":"Stream","advanced":false,"dynamic":false,"info":"Stream the response from the model. Streaming works only in Chat.","title_case":false,"type":"bool","_input_type":"BoolInput"},"system_message":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"system_message","value":"","display_name":"System Message","advanced":false,"input_types":["Message"],"dynamic":false,"info":"System message to pass to the model.","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Generates text using OpenAI LLMs.","icon":"OpenAI","base_classes":["LanguageModel","Message"],"display_name":"OpenAI","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"text_output","display_name":"Text","method":"text_response","value":"__UNDEFINED__","cache":true,"required_inputs":[]},{"types":["LanguageModel"],"selected":"LanguageModel","name":"model_output","display_name":"Language Model","method":"build_model","value":"__UNDEFINED__","cache":true,"required_inputs":[]}],"field_order":["input_value","system_message","stream","max_tokens","model_kwargs","json_mode","model_name","openai_api_base","api_key","temperature","seed"],"beta":false,"legacy":false,"edited":false,"metadata":{},"tool_mode":false,"category":"models","key":"OpenAIModel","score":0.001,"lf_version":"1.1.1.dev14"},"type":"OpenAIModel","id":"OpenAIModel-nunlt"},"selected":false,"measured":{"width":320,"height":685},"dragging":false},{"id":"Prompt-Gzyay","type":"genericNode","position":{"x":1185.5373905493077,"y":515.5836306355457},"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from langflow.base.prompts.api_utils import process_prompt_template\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import DefaultPromptField\nfrom langflow.io import MessageTextInput, Output, PromptInput\nfrom langflow.schema.message import Message\nfrom langflow.template.utils import update_template_values\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Prompt\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    icon = \"prompts\"\n    trace_type = \"prompt\"\n    name = \"Prompt\"\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n        MessageTextInput(\n            name=\"tool_placeholder\",\n            display_name=\"Tool Placeholder\",\n            tool_mode=True,\n            advanced=True,\n            info=\"A placeholder input for tool mode.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt Message\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    async def build_prompt(self) -> Message:\n        prompt = Message.from_template(**self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        custom_fields = frontend_node[\"custom_fields\"]\n        frontend_node_template = frontend_node[\"template\"]\n        _ = process_prompt_template(\n            template=prompt_template,\n            name=\"template\",\n            custom_fields=custom_fields,\n            frontend_node_template=frontend_node_template,\n        )\n        return frontend_node\n\n    async def update_frontend_node(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        # Kept it duplicated for backwards compatibility\n        _ = process_prompt_template(\n            template=template,\n            name=\"template\",\n            custom_fields=frontend_node[\"custom_fields\"],\n            frontend_node_template=frontend_node[\"template\"],\n        )\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"template":{"tool_mode":false,"trace_as_input":true,"list":false,"required":false,"placeholder":"","show":true,"name":"template","value":"Você é “TDAH Buddy”. Diariamente, receberá meu histórico de conversas do WhatsApp, uma pessoa por vez. Seu objetivo é me ajudar a não perder nada importante de cada conversa individual. Para cada conversa (com determinada pessoa), você fará uma análise separada. Se não encontrar nada relevante (apenas conversas do tipo “Olá, tudo bem?” ou bate-papo trivial), então não retornará nada (resposta vazia).\n\nSeu trabalho é detectar:\n\n1. Tarefas ou ações que eu disse que faria ou que outras pessoas me pediram para fazer.\n2. Pendências em que outras pessoas precisam me responder ou eu preciso responder.\n3. Lembretes, compromissos, datas e horários (reuniões, viagens, entregas).\n4. Questões financeiras (gastos, valores, rateios, negociações etc.).\n5. Observações relevantes (reflexões emocionais, insights de relacionamento, menções a sonhos ou terapia etc.).\n6. Outros tópicos que eu possa querer acompanhar (por exemplo, links compartilhados, ideias de projetos).\n\nSe não houver nada relevante para aquela pessoa (só conversa fiada ou saudações), retorne uma saída completamente vazia (sem chaves ou conteúdo).\n\nFormato de saída em JSON respeitando a seguinte estrutura\n\nsumario_geral: \"texto\"\nitens_de_acao: []\nlembretes_e_pendencias: []\neventos_e_datas_importantes: []\nquestoes_financeiras: []\nobservacoes_relevantes_reflexoes_pessoais: []\noutros_topicos_importantes: []\n\nObservações importantes:\n- Se algum campo estiver vazio, use uma lista vazia ou string vazia.\n- Mantenha exatamente estes mesmos nomes de campos e na mesma ordem.\n- Se for tudo irrelevante, retorne []","display_name":"Template","advanced":false,"dynamic":false,"info":"","title_case":false,"type":"prompt","_input_type":"PromptInput"},"tool_placeholder":{"tool_mode":true,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"tool_placeholder","value":"","display_name":"Tool Placeholder","advanced":true,"input_types":["Message"],"dynamic":false,"info":"A placeholder input for tool mode.","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Create a prompt template with dynamic variables.","icon":"prompts","is_input":null,"is_output":null,"is_composition":null,"base_classes":["Message"],"name":"","display_name":"Prompt","documentation":"","custom_fields":{"template":[]},"output_types":[],"full_path":null,"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"prompt","hidden":null,"display_name":"Prompt Message","method":"build_prompt","value":"__UNDEFINED__","cache":true,"required_inputs":null}],"field_order":["template","tool_placeholder"],"beta":false,"legacy":false,"error":null,"edited":false,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14"},"type":"Prompt","id":"Prompt-Gzyay"},"selected":false,"measured":{"width":320,"height":259},"dragging":false},{"id":"MessagetoData-36ekz","type":"genericNode","position":{"x":2007.381226772165,"y":1088.291543323631},"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from loguru import logger\n\nfrom langflow.custom import Component\nfrom langflow.io import MessageInput, Output\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\n\n\nclass MessageToDataComponent(Component):\n    display_name = \"Message to Data\"\n    description = \"Convert a Message object to a Data object\"\n    icon = \"message-square-share\"\n    beta = True\n    name = \"MessagetoData\"\n\n    inputs = [\n        MessageInput(\n            name=\"message\",\n            display_name=\"Message\",\n            info=\"The Message object to convert to a Data object\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"convert_message_to_data\"),\n    ]\n\n    def convert_message_to_data(self) -> Data:\n        if isinstance(self.message, Message):\n            # Convert Message to Data\n            return Data(data=self.message.data)\n\n        msg = \"Error converting Message to Data: Input must be a Message object\"\n        logger.opt(exception=True).debug(msg)\n        self.status = msg\n        return Data(data={\"error\": msg})\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"message":{"trace_as_input":true,"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"message","value":"","display_name":"Message","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The Message object to convert to a Data object","title_case":false,"type":"str","_input_type":"MessageInput"}},"description":"Convert a Message object to a Data object","icon":"message-square-share","base_classes":["Data"],"display_name":"Message to Data","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"data","display_name":"Data","method":"convert_message_to_data","value":"__UNDEFINED__","cache":true}],"field_order":["message"],"beta":true,"legacy":false,"edited":false,"metadata":{},"tool_mode":false,"category":"processing","key":"MessagetoData","score":0.2798231101512543,"lf_version":"1.1.1.dev14"},"type":"MessagetoData","id":"MessagetoData-36ekz"},"selected":false,"measured":{"width":320,"height":233},"dragging":false},{"id":"ParseData-1xlsE","type":"genericNode","position":{"x":1197.393794467186,"y":887.2852912620643},"data":{"node":{"template":{"_type":"Component","data":{"tool_mode":false,"trace_as_metadata":true,"list":true,"trace_as_input":true,"required":false,"placeholder":"","show":true,"name":"data","value":"","display_name":"Data","advanced":false,"input_types":["Data"],"dynamic":false,"info":"The data to convert to text.","title_case":false,"type":"other","_input_type":"DataInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from typing import Optional, Tuple, List\r\nfrom langflow.custom import Component\r\nfrom langflow.helpers.data import data_to_text, data_to_text_list\r\nfrom langflow.io import DataInput, MultilineInput, Output, StrInput\r\nfrom langflow.schema import Data\r\nfrom langflow.schema.message import Message\r\n\r\nclass ParseDataComponent(Component):\r\n    display_name = \"Parse Data\"\r\n    description = \"Convert Data into plain text following a specified template.\"\r\n    icon = \"braces\"\r\n    name = \"ParseData\"\r\n\r\n    inputs = [\r\n        DataInput(\r\n            name=\"data\",\r\n            display_name=\"Data\",\r\n            info=\"The data to convert to text.\",\r\n            is_list=True,\r\n            required=False,\r\n        ),\r\n        MultilineInput(\r\n            name=\"template\",\r\n            display_name=\"Template\",\r\n            info=\"The template to use for formatting the data. \"\r\n            \"It can contain the keys {text}, {data} or any other key in the Data.\",\r\n            value=\"{text}\",\r\n            required=False,\r\n        ),\r\n        StrInput(\r\n            name=\"sep\",\r\n            display_name=\"Separator\",\r\n            advanced=True,\r\n            value=\"\\n\",\r\n            required=False,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            display_name=\"Text\",\r\n            name=\"text\",\r\n            info=\"Data as a single Message, with each input Data separated by Separator\",\r\n            method=\"parse_data\",\r\n        ),\r\n        Output(\r\n            display_name=\"Data List\",\r\n            name=\"data_list\",\r\n            info=\"Data as a list of new Data, each having `text` formatted by Template\",\r\n            method=\"parse_data_as_list\",\r\n        ),\r\n    ]\r\n\r\n    def _clean_args(self) -> Tuple[List[Data], str, str]:\r\n        \"\"\"Clean and validate input arguments with safe defaults.\"\"\"\r\n        try:\r\n            # Handle data input\r\n            data = getattr(self, 'data', None)\r\n            if data is None:\r\n                data = []\r\n            elif not isinstance(data, list):\r\n                data = [data]\r\n\r\n            # Handle template input\r\n            template = getattr(self, 'template', '{text}') or '{text}'\r\n\r\n            # Handle separator input\r\n            sep = getattr(self, 'sep', '\\n') or '\\n'\r\n\r\n            return data, template, sep\r\n        except Exception as e:\r\n            self.log(f\"Error in _clean_args: {str(e)}\")\r\n            return [], '{text}', '\\n'\r\n\r\n    def parse_data(self) -> Message:\r\n        \"\"\"Parse data into a single message.\"\"\"\r\n        try:\r\n            data, template, sep = self._clean_args()\r\n            if not data:\r\n                result_string = \"\"\r\n            else:\r\n                result_string = data_to_text(template, data, sep)\r\n            self.status = result_string\r\n            return Message(text=result_string)\r\n        except Exception as e:\r\n            self.log(f\"Error in parse_data: {str(e)}\")\r\n            return Message(text=\"\")\r\n\r\n    def parse_data_as_list(self) -> List[Data]:\r\n        \"\"\"Parse data into a list of Data objects.\"\"\"\r\n        try:\r\n            data, template, _ = self._clean_args()\r\n            if not data:\r\n                return []\r\n            \r\n            text_list, data_list = data_to_text_list(template, data)\r\n            for item, text in zip(data_list, text_list, strict=True):\r\n                item.set_text(text)\r\n            self.status = data_list\r\n            return data_list\r\n        except Exception as e:\r\n            self.log(f\"Error in parse_data_as_list: {str(e)}\")\r\n            return []","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"sep":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"sep","value":"\n","display_name":"Separator","advanced":true,"dynamic":false,"info":"","title_case":false,"type":"str","_input_type":"StrInput"},"template":{"tool_mode":false,"trace_as_input":true,"multiline":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"template","value":"{chat_history}","display_name":"Template","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The template to use for formatting the data. It can contain the keys {text}, {data} or any other key in the Data.","title_case":false,"type":"str","_input_type":"MultilineInput"}},"description":"Convert Data into plain text following a specified template.","icon":"braces","base_classes":["Data","Message"],"display_name":"Parse Data","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"text","display_name":"Text","method":"parse_data","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"data_list","display_name":"Data List","method":"parse_data_as_list","value":"__UNDEFINED__","cache":true}],"field_order":["data","template","sep"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14"},"type":"ParseData","id":"ParseData-1xlsE"},"selected":false,"measured":{"width":320,"height":349},"dragging":false}],"edges":[{"source":"Prompt-Gzyay","sourceHandle":"{œdataTypeœ:œPromptœ,œidœ:œPrompt-Gzyayœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}","target":"OpenAIModel-nunlt","targetHandle":"{œfieldNameœ:œsystem_messageœ,œidœ:œOpenAIModel-nunltœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"system_message","id":"OpenAIModel-nunlt","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"Prompt","id":"Prompt-Gzyay","name":"prompt","output_types":["Message"]}},"id":"reactflow__edge-Prompt-Gzyay{œdataTypeœ:œPromptœ,œidœ:œPrompt-Gzyayœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}-OpenAIModel-nunlt{œfieldNameœ:œsystem_messageœ,œidœ:œOpenAIModel-nunltœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","animated":false,"className":"","selected":false},{"source":"OpenAIModel-nunlt","sourceHandle":"{œdataTypeœ:œOpenAIModelœ,œidœ:œOpenAIModel-nunltœ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}","target":"MessagetoData-36ekz","targetHandle":"{œfieldNameœ:œmessageœ,œidœ:œMessagetoData-36ekzœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"message","id":"MessagetoData-36ekz","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"OpenAIModel","id":"OpenAIModel-nunlt","name":"text_output","output_types":["Message"]}},"id":"reactflow__edge-OpenAIModel-nunlt{œdataTypeœ:œOpenAIModelœ,œidœ:œOpenAIModel-nunltœ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}-MessagetoData-36ekz{œfieldNameœ:œmessageœ,œidœ:œMessagetoData-36ekzœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","animated":false,"className":"","selected":false},{"source":"MessagetoData-36ekz","sourceHandle":"{œdataTypeœ:œMessagetoDataœ,œidœ:œMessagetoData-36ekzœ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}","target":"CustomComponent-Hwsp2","targetHandle":"{œfieldNameœ:œloopœ,œidœ:œCustomComponent-Hwsp2œ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","data":{"targetHandle":{"fieldName":"loop","id":"CustomComponent-Hwsp2","inputTypes":["Data"],"type":"other"},"sourceHandle":{"dataType":"MessagetoData","id":"MessagetoData-36ekz","name":"data","output_types":["Data"]}},"id":"reactflow__edge-MessagetoData-36ekz{œdataTypeœ:œMessagetoDataœ,œidœ:œMessagetoData-36ekzœ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}-CustomComponent-Hwsp2{œfieldNameœ:œloopœ,œidœ:œCustomComponent-Hwsp2œ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","animated":false,"className":"","selected":false},{"source":"CustomComponent-Hwsp2","sourceHandle":"{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-Hwsp2œ,œnameœ:œitemœ,œoutput_typesœ:[œDataœ]}","target":"ParseData-1xlsE","targetHandle":"{œfieldNameœ:œdataœ,œidœ:œParseData-1xlsEœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","data":{"targetHandle":{"fieldName":"data","id":"ParseData-1xlsE","inputTypes":["Data"],"type":"other"},"sourceHandle":{"dataType":"CustomComponent","id":"CustomComponent-Hwsp2","name":"item","output_types":["Data"]}},"id":"reactflow__edge-CustomComponent-Hwsp2{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-Hwsp2œ,œnameœ:œitemœ,œoutput_typesœ:[œDataœ]}-ParseData-1xlsE{œfieldNameœ:œdataœ,œidœ:œParseData-1xlsEœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","animated":false,"className":"","selected":false},{"source":"ParseData-1xlsE","sourceHandle":"{œdataTypeœ:œParseDataœ,œidœ:œParseData-1xlsEœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}","target":"OpenAIModel-nunlt","targetHandle":"{œfieldNameœ:œinput_valueœ,œidœ:œOpenAIModel-nunltœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"input_value","id":"OpenAIModel-nunlt","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"ParseData","id":"ParseData-1xlsE","name":"text","output_types":["Message"]}},"id":"reactflow__edge-ParseData-1xlsE{œdataTypeœ:œParseDataœ,œidœ:œParseData-1xlsEœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-OpenAIModel-nunlt{œfieldNameœ:œinput_valueœ,œidœ:œOpenAIModel-nunltœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","animated":false,"className":"","selected":false}],"viewport":{"x":252.30095381047795,"y":-119.30693142373684,"zoom":0.5642193795063281}},"is_component":false,"updated_at":"2025-01-06T19:39:51+00:00","webhook":false,"endpoint_name":null,"tags":null,"locked":null,"id":"5935fc14-a74b-42a1-a8b8-85378a99c176","user_id":"556fed76-1562-4baf-8a2e-ef9be2d194e4","folder_id":"22c5349e-60ef-45a2-a8ec-0debcd24f6dd"},{"name":"whatsapp_router (prod)","description":"","icon":null,"icon_bg_color":null,"gradient":null,"data":{"nodes":[{"id":"Webhook-1NLyE","type":"genericNode","position":{"x":-1546.141030324046,"y":-680.1508315346873},"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nfrom langflow.custom import Component\r\nfrom langflow.io import MultilineInput, Output\r\nfrom langflow.schema import Data\r\nfrom langflow.schema.message import Message\r\n\r\nclass WebhookComponent(Component):\r\n    display_name = \"Webhook\"\r\n    description = \"Defines a webhook input for the flow.\"\r\n    name = \"Webhook\"\r\n    icon = \"webhook\"\r\n    inputs = [\r\n        MultilineInput(\r\n            name=\"data\",\r\n            display_name=\"Payload\",\r\n            info=\"Receives a payload from external systems via HTTP POST.\",\r\n        )\r\n    ]\r\n    outputs = [\r\n        Output(display_name=\"Raw Payload\", name=\"raw_payload\", method=\"forward_raw_payload\", type=\"Message\"),\r\n        Output(display_name=\"Data\", name=\"output_data\", method=\"build_data\"),\r\n    ]\r\n\r\n    def forward_raw_payload(self) -> Message:\r\n        \"\"\"Forward the raw payload as a Message type.\"\"\"\r\n        if not self.data:\r\n            return Message(text=\"\")\r\n        return Message(text=self.data)\r\n\r\n    def build_data(self) -> Data:\r\n        message: str | Data = \"\"\r\n        if not self.data:\r\n            self.status = \"No data provided.\"\r\n            return Data(data={})\r\n        try:\r\n            body = json.loads(self.data or \"{}\")\r\n        except json.JSONDecodeError:\r\n            body = {\"payload\": self.data}\r\n            message = f\"Invalid JSON payload. Please check the format.\\n\\n{self.data}\"\r\n        data = Data(data=body)\r\n        if not message:\r\n            message = data\r\n        self.status = message\r\n        return data\r\n\r\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"data":{"tool_mode":false,"trace_as_input":true,"multiline":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"data","value":"{\"event\":\"messages.upsert\",\"instance\":\"felipe8888\",\"data\":{\"key\":{\"remoteJid\":\"555197285829@s.whatsapp.net\",\"fromMe\":true,\"id\":\"51302C27484CC49CD68D78324BD72E3F\"},\"pushName\":\"Felipe Rosa\",\"status\":\"SERVER_ACK\",\"message\":{\"reactionMessage\":{\"key\":{\"remoteJid\":\"555197285829@s.whatsapp.net\",\"fromMe\":true,\"id\":\"5D4DEFDAD27FB6B8E4D689062E0EFB18\"},\"text\":\"🔇\",\"senderTimestampMs\":\"1735241066140\"}},\"messageType\":\"reactionMessage\",\"messageTimestamp\":1735241066,\"instanceId\":\"ec7ffe43-823e-4535-aa57-1ac66eff4f7f\",\"source\":\"android\"},\"destination\":\"http://192.168.112.129/api/v1/webhook/felipe-whats?api_key=sk-JXCm-YtyH8OwTzf5v_74EL799UQSXPs__a5jBptqmsc\",\"date_time\":\"2024-12-26T16:24:26.604Z\",\"sender\":\"5512982298888@s.whatsapp.net\",\"server_url\":\"http://evo.namastex.io\",\"apikey\":\"3CFB7C3D17A5-4DE7-BD57-1062D00B2FA3888\"}","display_name":"Payload","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Receives a payload from external systems via HTTP POST.","title_case":false,"type":"str","_input_type":"MultilineInput"}},"description":"Defines a webhook input for the flow.","icon":"webhook","base_classes":["Data","Message"],"display_name":"Webhook + RAW Payload","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"raw_payload","display_name":"Raw Payload","method":"forward_raw_payload","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"output_data","display_name":"Data","method":"build_data","value":"__UNDEFINED__","cache":true}],"field_order":["data"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14"},"type":"Webhook","id":"Webhook-1NLyE"},"selected":false,"width":320,"height":233,"positionAbsolute":{"x":-53.512037586403494,"y":171.84531224859728},"dragging":false,"measured":{"width":320,"height":233}},{"id":"CustomComponent-Wj3aX","type":"genericNode","position":{"x":-1076.9247076680595,"y":-994.6618479355103},"data":{"node":{"template":{"_type":"Component","data":{"tool_mode":false,"trace_as_metadata":true,"list":false,"trace_as_input":true,"required":true,"placeholder":"","show":true,"name":"data","value":"","display_name":"Message Data","advanced":false,"input_types":["Data"],"dynamic":false,"info":"Evolution API message data to parse","title_case":false,"type":"other","_input_type":"DataInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom datetime import datetime, timezone, timedelta\r\nfrom typing import List, Dict, Any, Callable\r\nfrom urllib.parse import urlparse, parse_qs, urlunparse\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    DataInput,\r\n    MessageTextInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\nfrom langflow.schema.message import Message\r\n\r\n\r\nclass EvolutionDataParserComponent(Component):\r\n    display_name = \"Evolution Data Parser\"\r\n    description = \"Parse Evolution API message data into structured format\"\r\n    icon = \"filter\"\r\n    name = \"evolution_data_parser\"\r\n\r\n    inputs = [\r\n        DataInput(\r\n            name=\"data\",\r\n            display_name=\"Message Data\",\r\n            info=\"Evolution API message data to parse\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"media_server_url\",\r\n            display_name=\"Media Server URL\",\r\n            info=\"Base URL for media server (e.g., https://media.server.com)\",\r\n            required=False,\r\n            value=\"http://minio:9000\"\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"parsed_data\",\r\n            display_name=\"Parsed Data\",\r\n            description=\"All parsed data in tabular format\",\r\n            method=\"parse_data\",\r\n            type=\"list[Data]\"\r\n        ),\r\n        Output(\r\n            name=\"timestamp\",\r\n            display_name=\"Message Timestamp\",\r\n            description=\"Message timestamp in GMT-3\",\r\n            method=\"get_timestamp\",\r\n        ),\r\n        Output(\r\n            name=\"message_type\",\r\n            display_name=\"Message Type\",\r\n            description=\"Type of the message (conversation, audioMessage, etc)\",\r\n            method=\"get_message_type\",\r\n        ),\r\n        Output(\r\n            name=\"push_name\",\r\n            display_name=\"Push Name\",\r\n            description=\"Sender's push name\",\r\n            method=\"get_push_name\",\r\n        ),\r\n        Output(\r\n            name=\"remote_jid\",\r\n            display_name=\"Remote JID\",\r\n            description=\"WhatsApp ID of the remote contact\",\r\n            method=\"get_remote_jid\",\r\n        ),\r\n        Output(\r\n            name=\"message_id\",\r\n            display_name=\"Message ID\",\r\n            description=\"Unique identifier of the message\",\r\n            method=\"get_message_id\",\r\n        ),\r\n        Output(\r\n            name=\"from_me\",\r\n            display_name=\"From Me\",\r\n            description=\"Whether the message was sent by the user\",\r\n            method=\"get_from_me\",\r\n        ),\r\n        Output(\r\n            name=\"message_content\",\r\n            display_name=\"Message Content\",\r\n            description=\"Content of the message (text or media URL)\",\r\n            method=\"get_message_content\",\r\n        ),\r\n        Output(\r\n            name=\"participant\",\r\n            display_name=\"Participant\",\r\n            description=\"Participant JID for group messages\",\r\n            method=\"get_participant\",\r\n        ),\r\n    ]\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        super().__init__(*args, **kwargs)\r\n        # Initialize message type parser mapping\r\n        self._message_parsers = {\r\n            \"conversation\": self._parse_conversation,\r\n            \"audioMessage\": self._parse_media_message,\r\n            \"imageMessage\": self._parse_media_message,\r\n            \"videoMessage\": self._parse_media_message,\r\n            \"stickerMessage\": self._parse_media_message,\r\n            \"documentMessage\": self._parse_media_message,\r\n            \"reactionMessage\": self._parse_reaction_message,\r\n            \"contactMessage\": self._parse_contact_message,\r\n            \"locationMessage\": self._parse_location_message,\r\n            \"editedMessage\": self._parse_edited_message,\r\n            \"viewOnceMessageV2\": self._parse_view_once_message,\r\n        }\r\n\r\n    def clean_media_url(self, url: str) -> str:\r\n        \"\"\"Clean media URL by removing query parameters\"\"\"\r\n        if not url:\r\n            return \"\"\r\n            \r\n        parsed = urlparse(url)\r\n        clean_url = urlunparse((\r\n            parsed.scheme,\r\n            parsed.netloc,\r\n            parsed.path,\r\n            '',  # params\r\n            '',  # query\r\n            ''   # fragment\r\n        ))\r\n        \r\n        # Replace minio URL if media server URL is provided\r\n        if self.media_server_url:\r\n            clean_url = clean_url.replace(\"http://minio:9000\", self.media_server_url.rstrip('/'))\r\n            \r\n        return clean_url\r\n\r\n    def _parse_conversation(self, message: Dict[str, Any]) -> str:\r\n        \"\"\"Parse regular conversation message\"\"\"\r\n        self.log(\"Parsing conversation message\")\r\n        content = message.get(\"conversation\", \"\")\r\n        self.log(f\"Extracted conversation content: {content}\")\r\n        return content\r\n\r\n    def _parse_media_message(self, message: Dict[str, Any]) -> str:\r\n        \"\"\"Parse media message (audio, image, video, sticker, document)\"\"\"\r\n        self.log(\"Parsing media message\")\r\n        media_url = message.get(\"mediaUrl\", \"\")\r\n        self.log(f\"Found raw media URL: {media_url}\")\r\n        cleaned_url = self.clean_media_url(media_url)\r\n        self.log(f\"Cleaned media URL: {cleaned_url}\")\r\n        return cleaned_url\r\n\r\n    def _parse_reaction_message(self, message: Dict[str, Any]) -> tuple[str, str]:\r\n        \"\"\"Parse reaction message, returns tuple of (emoji, reacted_message_id)\"\"\"\r\n        self.log(\"Parsing reaction message\")\r\n        reaction_msg = message.get(\"reactionMessage\", {})\r\n        \r\n        # Get reaction emoji and reacted message ID\r\n        text = reaction_msg.get(\"text\", \"\")\r\n        reacted_key = reaction_msg.get(\"key\", {})\r\n        reacted_msg_id = reacted_key.get(\"id\", \"\")\r\n        \r\n        self.log(f\"Extracted reaction emoji: {text}\")\r\n        return text, reacted_msg_id\r\n\r\n    def _parse_contact_message(self, message: Dict[str, Any]) -> str:\r\n        \"\"\"Parse contact message\"\"\"\r\n        self.log(\"Parsing contact message\")\r\n        contact_msg = message.get(\"contactMessage\", {})\r\n        display_name = contact_msg.get(\"displayName\", \"\")\r\n        vcard = contact_msg.get(\"vcard\", \"\")\r\n        \r\n        # Extract phone number from vcard if present\r\n        phone = \"\"\r\n        if \"TEL;\" in vcard:\r\n            try:\r\n                phone = vcard.split(\"TEL;\")[1].split(\":\")[1].split(\"\\n\")[0]\r\n            except:\r\n                pass\r\n                \r\n        content = f\"Contact: {display_name}\"\r\n        if phone:\r\n            content += f\" ({phone})\"\r\n            \r\n        self.log(f\"Extracted contact content: {content}\")\r\n        return content\r\n\r\n    def _parse_location_message(self, message: Dict[str, Any]) -> str:\r\n        \"\"\"Parse location message\"\"\"\r\n        self.log(\"Parsing location message\")\r\n        location_msg = message.get(\"locationMessage\", {})\r\n        \r\n        # Extract available location data\r\n        latitude = location_msg.get(\"degreesLatitude\", \"\")\r\n        longitude = location_msg.get(\"degreesLongitude\", \"\")\r\n        name = location_msg.get(\"name\", \"\")\r\n        address = location_msg.get(\"address\", \"\")\r\n        \r\n        content_parts = []\r\n        if latitude and longitude:\r\n            content_parts.append(f\"Location: {latitude},{longitude}\")\r\n        if name:\r\n            content_parts.append(f\"Name: {name}\")\r\n        if address:\r\n            content_parts.append(f\"Address: {address}\")\r\n            \r\n        content = \" | \".join(content_parts) if content_parts else \"Location shared\"\r\n        \r\n        self.log(f\"Extracted location content: {content}\")\r\n        return content\r\n\r\n    def _parse_edited_message(self, message: Dict[str, Any]) -> str:\r\n        \"\"\"Parse edited message\"\"\"\r\n        self.log(\"Parsing edited message\")\r\n        edited_msg = message.get(\"editedMessage\", {})\r\n        if not edited_msg:\r\n            return \"\"\r\n            \r\n        # Try to get the edited text content\r\n        edited_content = edited_msg.get(\"message\", {}).get(\"conversation\", \"\")\r\n        if edited_content:\r\n            return f\"Edited to: {edited_content}\"\r\n            \r\n        return \"Message was edited\"\r\n\r\n    def _parse_view_once_message(self, message: Dict[str, Any]) -> str:\r\n        \"\"\"Parse view once message - return generic message for privacy\"\"\"\r\n        self.log(\"Parsing view once message\")\r\n        return \"View once media message\"\r\n\r\n    def parse_message_content(self, message: dict, message_type: str) -> tuple[str, str]:\r\n        \"\"\"Extract message content based on message type using appropriate parser\"\"\"\r\n        self.log(f\"Parsing message content for type: {message_type}\")\r\n        \r\n        if not message:\r\n            self.log(\"No message content found\")\r\n            return \"\", \"\"\r\n            \r\n        # Get appropriate parser for message type\r\n        parser = self._message_parsers.get(message_type)\r\n        if not parser:\r\n            self.log(f\"Unhandled message type: {message_type}\")\r\n            return \"\", \"\"\r\n            \r\n        try:\r\n            if message_type == \"reactionMessage\":\r\n                return parser(message)  # Returns tuple of (content, reacted_msg_id)\r\n            else:\r\n                return parser(message), \"\"  # Other parsers return just content\r\n        except Exception as e:\r\n            self.log(f\"Error parsing {message_type}: {str(e)}\")\r\n            return \"\", \"\"\r\n\r\n    def convert_timestamp(self, timestamp: int) -> str:\r\n        \"\"\"Convert Unix timestamp to GMT-3 datetime string\"\"\"\r\n        if not timestamp:\r\n            return \"\"\r\n            \r\n        # Convert to datetime in UTC\r\n        dt_utc = datetime.fromtimestamp(timestamp, timezone.utc)\r\n        \r\n        # Convert to GMT-3\r\n        gmt3 = timezone(timedelta(hours=-3))\r\n        dt_gmt3 = dt_utc.astimezone(gmt3)\r\n        \r\n        # Format datetime\r\n        return dt_gmt3.strftime(\"%Y-%m-%d %H:%M:%S GMT-3\")\r\n\r\n    def parse_data(self) -> List[Data]:\r\n        \"\"\"Parse Evolution API message data into structured format\"\"\"\r\n        try:\r\n            # Get input data\r\n            if not hasattr(self.data, 'data'):\r\n                raise ValueError(\"Input data missing 'data' field\")\r\n            \r\n            root_data = self.data.data\r\n            self.log(f\"Got root data structure\")\r\n            \r\n            # The actual message data is in the nested 'data' field\r\n            if 'data' not in root_data:\r\n                raise ValueError(\"Missing nested 'data' field in input\")\r\n                \r\n            input_data = root_data['data']\r\n            self.log(f\"Extracted message data: {json.dumps(input_data, indent=2)}\")\r\n\r\n            # Extract key fields\r\n            message_timestamp = input_data.get(\"messageTimestamp\", 0)\r\n            self.log(f\"Extracted timestamp: {message_timestamp}\")\r\n            \r\n            message_type = input_data.get(\"messageType\", \"\")\r\n            self.log(f\"Extracted message type: {message_type}\")\r\n            \r\n            push_name = input_data.get(\"pushName\", \"\")\r\n            self.log(f\"Extracted push name: {push_name}\")\r\n            \r\n            key_data = input_data.get(\"key\", {})\r\n            remote_jid = key_data.get(\"remoteJid\", \"\")\r\n            message_id = key_data.get(\"id\", \"\")\r\n            participant = key_data.get(\"participant\", \"\")  # New: get participant for group messages\r\n            from_me = str(key_data.get(\"fromMe\", False)).lower()\r\n            \r\n            self.log(f\"Extracted remote JID: {remote_jid}\")\r\n            self.log(f\"Extracted message ID: {message_id}\")\r\n            self.log(f\"Extracted participant: {participant}\")\r\n            self.log(f\"Extracted fromMe: {from_me}\")\r\n            \r\n            self.log(\"Extracting message content...\")\r\n            message_content, reacted_msg_id = self.parse_message_content(\r\n                input_data.get(\"message\", {}),\r\n                message_type\r\n            )\r\n            self.log(f\"Extracted message content: {message_content}\")\r\n            \r\n            # Use reacted message ID instead of reaction ID for reaction messages\r\n            if message_type == \"reactionMessage\" and reacted_msg_id:\r\n                message_id = reacted_msg_id\r\n\r\n            # Create parsed data object and store it\r\n            self._parsed_data = {\r\n                \"timestamp\": self.convert_timestamp(message_timestamp),\r\n                \"messageType\": message_type,\r\n                \"pushName\": push_name,\r\n                \"remoteJid\": remote_jid,\r\n                \"messageId\": message_id,\r\n                \"fromMe\": from_me,\r\n                \"message\": message_content,\r\n                \"participant\": participant\r\n            }\r\n\r\n            return [Data(data=self._parsed_data)]\r\n\r\n        except Exception as e:\r\n            error_msg = f\"Error parsing data: {str(e)}\"\r\n            self.log(error_msg)\r\n            \r\n            # Initialize empty data on error\r\n            self._parsed_data = {\r\n                \"timestamp\": \"\",\r\n                \"messageType\": \"\",\r\n                \"pushName\": \"\",\r\n                \"remoteJid\": \"\",\r\n                \"messageId\": \"\",\r\n                \"fromMe\": \"false\",\r\n                \"message\": \"\",\r\n                \"participant\": \"\"\r\n            }\r\n            return [Data(data=self._parsed_data)]\r\n            \r\n    def get_timestamp(self) -> Message:\r\n        \"\"\"Get the message timestamp.\"\"\"\r\n        return Message(text=self._parsed_data.get(\"timestamp\", \"\"))\r\n        \r\n    def get_message_type(self) -> Message:\r\n        \"\"\"Get the message type.\"\"\"\r\n        return Message(text=self._parsed_data.get(\"messageType\", \"\"))\r\n        \r\n    def get_push_name(self) -> Message:\r\n        \"\"\"Get the sender's push name.\"\"\"\r\n        return Message(text=self._parsed_data.get(\"pushName\", \"\"))\r\n        \r\n    def get_remote_jid(self) -> Message:\r\n        \"\"\"Get the remote JID.\"\"\"\r\n        return Message(text=self._parsed_data.get(\"remoteJid\", \"\"))\r\n\r\n    def get_message_id(self) -> Message:\r\n        \"\"\"Get the message ID.\"\"\"\r\n        return Message(text=self._parsed_data.get(\"messageId\", \"\"))\r\n\r\n    def get_from_me(self) -> Message:\r\n        \"\"\"Get whether the message was sent by the user.\"\"\"\r\n        return Message(text=self._parsed_data.get(\"fromMe\", \"false\"))\r\n        \r\n    def get_message_content(self) -> Message:\r\n        \"\"\"Get the message content.\"\"\"\r\n        return Message(text=self._parsed_data.get(\"message\", \"\"))\r\n        \r\n    def get_participant(self) -> Message:\r\n        \"\"\"Get the participant JID for group messages.\"\"\"\r\n        return Message(text=self._parsed_data.get(\"participant\", \"\"))","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"media_server_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"media_server_url","value":"http://192.168.112.131:9000","display_name":"Media Server URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Base URL for media server (e.g., https://media.server.com)","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Parse Evolution API message data into structured format","icon":"filter","base_classes":["Data","Message"],"display_name":"Evolution Data Parser","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"parsed_data","display_name":"Parsed Data","method":"parse_data","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"timestamp","display_name":"Message Timestamp","method":"get_timestamp","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"message_type","display_name":"Message Type","method":"get_message_type","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"push_name","display_name":"Push Name","method":"get_push_name","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"remote_jid","display_name":"Remote JID","method":"get_remote_jid","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"message_id","display_name":"Message ID","method":"get_message_id","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"from_me","display_name":"From Me","method":"get_from_me","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"message_content","display_name":"Message Content","method":"get_message_content","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"participant","display_name":"Participant","method":"get_participant","value":"__UNDEFINED__","cache":true}],"field_order":["data","media_server_url"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14"},"type":"CustomComponent","id":"CustomComponent-Wj3aX"},"selected":false,"measured":{"width":320,"height":685},"dragging":false},{"id":"ChatOutput-TZgz9","type":"genericNode","position":{"x":-1078.228114881773,"y":-249.25760428641868},"data":{"node":{"template":{"_type":"Component","background_color":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"background_color","value":"","display_name":"Background Color","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The background color of the icon.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"chat_icon":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"chat_icon","value":"","display_name":"Icon","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The icon of the message.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.io import DropdownInput, MessageInput, MessageTextInput, Output\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        MessageInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Message to be passed as output.\",\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            source_dict[\"source\"] = source\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n        background_color = self.background_color\n        text_color = self.text_color\n        if self.chat_icon:\n            icon = self.chat_icon\n        message = self.input_value if isinstance(self.input_value, Message) else Message(text=self.input_value)\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n        message.properties.icon = icon\n        message.properties.background_color = background_color\n        message.properties.text_color = text_color\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = await self.send_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"data_template":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"data_template","value":"{text}","display_name":"Data Template","advanced":true,"input_types":["Message"],"dynamic":false,"info":"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"input_value":{"trace_as_input":true,"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"input_value","value":"","display_name":"Text","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Message to be passed as output.","title_case":false,"type":"str","_input_type":"MessageInput"},"sender":{"tool_mode":false,"trace_as_metadata":true,"options":["Machine","User"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"sender","value":"Machine","display_name":"Sender Type","advanced":true,"dynamic":false,"info":"Type of sender.","title_case":false,"type":"str","_input_type":"DropdownInput"},"sender_name":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"sender_name","value":"raw_payload","display_name":"Sender Name","advanced":true,"input_types":["Message"],"dynamic":false,"info":"Name of the sender.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"session_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"session_id","value":"raw_payloads","display_name":"Session ID","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The session ID of the chat. If empty, the current session ID parameter will be used.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"should_store_message":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"should_store_message","value":true,"display_name":"Store Messages","advanced":true,"dynamic":false,"info":"Store the message in the history.","title_case":false,"type":"bool","_input_type":"BoolInput"},"text_color":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"text_color","value":"","display_name":"Text Color","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The text color of the name","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Display a chat message in the Playground.","icon":"MessagesSquare","base_classes":["Message"],"display_name":"Chat Output","documentation":"","minimized":true,"custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"message","display_name":"Message","method":"message_response","value":"__UNDEFINED__","cache":true}],"field_order":["input_value","should_store_message","sender","sender_name","session_id","data_template","background_color","chat_icon","text_color"],"beta":false,"legacy":false,"edited":false,"metadata":{},"tool_mode":false},"type":"ChatOutput","id":"ChatOutput-TZgz9"},"selected":false,"measured":{"width":320,"height":233},"dragging":false},{"id":"CustomComponent-wwYDP","type":"genericNode","position":{"x":-286.5226868911064,"y":-911.1170305444607},"data":{"node":{"template":{"_type":"Component","data":{"tool_mode":false,"trace_as_metadata":true,"list":false,"trace_as_input":true,"required":true,"placeholder":"","show":true,"name":"data","value":"","display_name":"Data","advanced":false,"input_types":["Data"],"dynamic":false,"info":"The data to be sent as JSON in the request body","title_case":false,"type":"other","_input_type":"DataInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Dict, Any\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    DataInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\nclass WebhookPostComponent(Component):\r\n    display_name = \"Webhook POST\"\r\n    description = \"Sends a POST request to a specified URL with JSON data\"\r\n    icon = \"webhook\"\r\n    name = \"webhook_post\"\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"url\",\r\n            display_name=\"URL\",\r\n            info=\"The URL to send the POST request to\",\r\n            required=True,\r\n        ),\r\n        DataInput(\r\n            name=\"data\",\r\n            display_name=\"Data\",\r\n            info=\"The data to be sent as JSON in the request body\",\r\n            required=True,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"response\",\r\n            display_name=\"Response\",\r\n            method=\"send_webhook\",\r\n        ),\r\n    ]\r\n\r\n    def send_webhook(self) -> Data:\r\n        \"\"\"\r\n        Send a POST request to the specified URL with JSON data.\r\n        \"\"\"\r\n        try:\r\n            # Log the URL (excluding any sensitive parts)\r\n            safe_url = self.url.split(\"?\")[0]  # Remove query parameters if any\r\n            self.log(f\"Preparing to send POST request to: {safe_url}\")\r\n            \r\n            # Convert data to JSON\r\n            try:\r\n                # Handle Data object\r\n                if isinstance(self.data, Data):\r\n                    payload = self.data.data\r\n                elif isinstance(self.data, str):\r\n                    # If data is a string, try to parse it as JSON\r\n                    payload = json.loads(self.data)\r\n                else:\r\n                    # If data is already a dict/list, use it directly\r\n                    payload = self.data\r\n                    \r\n                self.log(\"Data successfully converted to JSON format\")\r\n            except json.JSONDecodeError as e:\r\n                self.log(f\"Error converting data to JSON: {str(e)}\")\r\n                return Data(data={\r\n                    \"error\": \"Invalid JSON data\",\r\n                    \"details\": str(e),\r\n                    \"status\": \"ERROR\"\r\n                })\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"Content-Type\": \"application/json\"\r\n            }\r\n            \r\n            # Log the request details (excluding sensitive data)\r\n            self.log(\"Sending POST request with JSON payload\")\r\n            \r\n            # Send the POST request\r\n            response = requests.post(\r\n                self.url,\r\n                json=payload,\r\n                headers=headers\r\n            )\r\n            \r\n            self.log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Try to parse response as JSON\r\n            try:\r\n                response_data = response.json()\r\n                response_type = \"json\"\r\n            except json.JSONDecodeError:\r\n                response_data = response.text\r\n                response_type = \"text\"\r\n            \r\n            # Check if request was successful\r\n            response.raise_for_status()\r\n            \r\n            # Process response into consistent format\r\n            processed_response = {\r\n                \"status\": \"SUCCESS\",\r\n                \"status_code\": response.status_code,\r\n                \"response_type\": response_type,\r\n                \"response_data\": response_data,\r\n                \"headers\": dict(response.headers)\r\n            }\r\n            \r\n            self.log(\"Request completed successfully\")\r\n            \r\n            return Data(data=processed_response)\r\n\r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"Request failed: {str(e)}\"\r\n            self.log(f\"Error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\",\r\n                \"status_code\": getattr(e.response, 'status_code', None) if hasattr(e, 'response') else None\r\n            })\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"url","value":"http://192.168.112.121/api/v1/webhook/wa-audio-transcription?api_key=sk-pcx1zXiRmSw_a0hPpr0gGU7IYPyH5FQzwIfhGO0TJP8","display_name":"URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The URL to send the POST request to","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Sends a POST request to a specified URL with JSON data","icon":"webhook","base_classes":["Data"],"display_name":"Webhook POST","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"response","display_name":"Response","method":"send_webhook","value":"__UNDEFINED__","cache":true}],"field_order":["url","data"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14","official":false},"type":"CustomComponent","id":"CustomComponent-wwYDP"},"selected":false,"measured":{"width":320,"height":301},"dragging":false},{"id":"ChatOutput-2UIv3","type":"genericNode","position":{"x":441.0443316405356,"y":-878.4218997509354},"data":{"node":{"template":{"_type":"Component","background_color":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"background_color","value":"","display_name":"Background Color","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The background color of the icon.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"chat_icon":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"chat_icon","value":"","display_name":"Icon","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The icon of the message.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.io import DropdownInput, MessageInput, MessageTextInput, Output\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        MessageInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Message to be passed as output.\",\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            source_dict[\"source\"] = source\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n        background_color = self.background_color\n        text_color = self.text_color\n        if self.chat_icon:\n            icon = self.chat_icon\n        message = self.input_value if isinstance(self.input_value, Message) else Message(text=self.input_value)\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n        message.properties.icon = icon\n        message.properties.background_color = background_color\n        message.properties.text_color = text_color\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = await self.send_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"data_template":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"data_template","value":"{text}","display_name":"Data Template","advanced":true,"input_types":["Message"],"dynamic":false,"info":"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"input_value":{"trace_as_input":true,"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"input_value","value":"","display_name":"Text","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Message to be passed as output.","title_case":false,"type":"str","_input_type":"MessageInput"},"sender":{"tool_mode":false,"trace_as_metadata":true,"options":["Machine","User"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"sender","value":"Machine","display_name":"Sender Type","advanced":true,"dynamic":false,"info":"Type of sender.","title_case":false,"type":"str","_input_type":"DropdownInput"},"sender_name":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"sender_name","value":"webhook_result","display_name":"Sender Name","advanced":true,"input_types":["Message"],"dynamic":false,"info":"Name of the sender.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"session_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"session_id","value":"webhook_result","display_name":"Session ID","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The session ID of the chat. If empty, the current session ID parameter will be used.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"should_store_message":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"should_store_message","value":true,"display_name":"Store Messages","advanced":true,"dynamic":false,"info":"Store the message in the history.","title_case":false,"type":"bool","_input_type":"BoolInput"},"text_color":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"text_color","value":"","display_name":"Text Color","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The text color of the name","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Display a chat message in the Playground.","icon":"MessagesSquare","base_classes":["Message"],"display_name":"Chat Output","documentation":"","minimized":true,"custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"message","display_name":"Message","method":"message_response","value":"__UNDEFINED__","cache":true}],"field_order":["input_value","should_store_message","sender","sender_name","session_id","data_template","background_color","chat_icon","text_color"],"beta":false,"legacy":false,"edited":false,"metadata":{},"tool_mode":false},"type":"ChatOutput","id":"ChatOutput-2UIv3"},"selected":false,"measured":{"width":320,"height":233},"dragging":false},{"id":"ParseData-dKjFC","type":"genericNode","position":{"x":81.3478049049366,"y":-919.6443444219195},"data":{"node":{"template":{"_type":"Component","data":{"tool_mode":false,"trace_as_metadata":true,"list":true,"trace_as_input":true,"required":false,"placeholder":"","show":true,"name":"data","value":"","display_name":"Data","advanced":false,"input_types":["Data"],"dynamic":false,"info":"The data to convert to text.","title_case":false,"type":"other","_input_type":"DataInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from langflow.custom import Component\nfrom langflow.helpers.data import data_to_text, data_to_text_list\nfrom langflow.io import DataInput, MultilineInput, Output, StrInput\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\n\n\nclass ParseDataComponent(Component):\n    display_name = \"Parse Data\"\n    description = \"Convert Data into plain text following a specified template.\"\n    icon = \"braces\"\n    name = \"ParseData\"\n\n    inputs = [\n        DataInput(name=\"data\", display_name=\"Data\", info=\"The data to convert to text.\", is_list=True),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. \"\n            \"It can contain the keys {text}, {data} or any other key in the Data.\",\n            value=\"{text}\",\n        ),\n        StrInput(name=\"sep\", display_name=\"Separator\", advanced=True, value=\"\\n\"),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Text\",\n            name=\"text\",\n            info=\"Data as a single Message, with each input Data separated by Separator\",\n            method=\"parse_data\",\n        ),\n        Output(\n            display_name=\"Data List\",\n            name=\"data_list\",\n            info=\"Data as a list of new Data, each having `text` formatted by Template\",\n            method=\"parse_data_as_list\",\n        ),\n    ]\n\n    def _clean_args(self) -> tuple[list[Data], str, str]:\n        data = self.data if isinstance(self.data, list) else [self.data]\n        template = self.template\n        sep = self.sep\n        return data, template, sep\n\n    def parse_data(self) -> Message:\n        data, template, sep = self._clean_args()\n        result_string = data_to_text(template, data, sep)\n        self.status = result_string\n        return Message(text=result_string)\n\n    def parse_data_as_list(self) -> list[Data]:\n        data, template, _ = self._clean_args()\n        text_list, data_list = data_to_text_list(template, data)\n        for item, text in zip(data_list, text_list, strict=True):\n            item.set_text(text)\n        self.status = data_list\n        return data_list\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"sep":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"sep","value":"\n","display_name":"Separator","advanced":true,"dynamic":false,"info":"","title_case":false,"type":"str","_input_type":"StrInput"},"template":{"tool_mode":false,"trace_as_input":true,"multiline":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"template","value":"{status} - {response_data}","display_name":"Template","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The template to use for formatting the data. It can contain the keys {text}, {data} or any other key in the Data.","title_case":false,"type":"str","_input_type":"MultilineInput"}},"description":"Convert Data into plain text following a specified template.","icon":"braces","base_classes":["Data","Message"],"display_name":"Parse Data","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"text","display_name":"Text","method":"parse_data","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"data_list","display_name":"Data List","method":"parse_data_as_list","value":"__UNDEFINED__","cache":true}],"field_order":["data","template","sep"],"beta":false,"legacy":false,"edited":false,"metadata":{},"tool_mode":false,"category":"processing","key":"ParseData","score":0.007568328950209746,"lf_version":"1.1.1.dev14"},"type":"ParseData","id":"ParseData-dKjFC"},"selected":false,"measured":{"width":320,"height":349},"dragging":false},{"id":"CustomComponent-xHIbo","type":"genericNode","position":{"x":-682.3308840408122,"y":-927.7746154127577},"data":{"node":{"template":{"_type":"Component","data":{"tool_mode":false,"trace_as_metadata":true,"list":false,"trace_as_input":true,"required":false,"placeholder":"","show":true,"name":"data","value":"","display_name":"Data Input","advanced":false,"input_types":["Data"],"dynamic":false,"info":"The input data to be routed based on message type.","title_case":false,"type":"other","_input_type":"DataInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from langflow.custom import Component\r\nfrom langflow.io import (\r\n    DataInput,\r\n    MessageTextInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\nclass EvolutionRouterComponent(Component):\r\n    display_name = \"Evolution Router\"\r\n    description = \"Routes data to different outputs based on message type.\"\r\n    icon = \"git-branch\"\r\n    name = \"EvolutionRouter\"\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        super().__init__(*args, **kwargs)\r\n        self.__data_processed = False\r\n\r\n    inputs = [\r\n        DataInput(\r\n            name=\"data\",\r\n            display_name=\"Data Input\",\r\n            info=\"The input data to be routed based on message type.\",\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(display_name=\"Audio Message\", name=\"audioMessage\", method=\"handle_audio\"),\r\n        Output(display_name=\"Conversation\", name=\"conversation\", method=\"handle_conversation\"),\r\n        Output(display_name=\"Reaction\", name=\"reaction\", method=\"handle_reaction\"),\r\n    ]\r\n\r\n    def _pre_run_setup(self):\r\n        self.__data_processed = False\r\n        self.log(f\"Starting Evolution Router\")\r\n        self.log(f\"Input data type: {type(self.data)}\")\r\n        self.log(f\"Input data content: {self.data}\")\r\n\r\n    def get_message_type(self) -> str:\r\n        \"\"\"Extract message type from the Data object.\"\"\"\r\n        try:\r\n            message_data = self.data[0]\r\n            message_type = message_data.data.get('messageType', '')\r\n            self.log(f\"Message type detected: {message_type}\")\r\n            return message_type.lower()\r\n        except (IndexError, AttributeError) as e:\r\n            self.log(f\"Error getting message type: {e}\")\r\n            return \"\"\r\n\r\n    def handle_audio(self) -> Data:\r\n        \"\"\"Handle audio message type.\"\"\"\r\n        message_type = self.get_message_type()\r\n        \r\n        if message_type == \"audiomessage\":\r\n            self.log(\"Routing to audio output\")\r\n            self.status = self.data[0]\r\n            self.stop(\"conversation\")\r\n            self.stop(\"reaction\")\r\n            return self.data[0]\r\n            \r\n        self.stop(\"audioMessage\")\r\n        return Data()\r\n\r\n    def handle_conversation(self) -> Data:\r\n        \"\"\"Handle conversation (text) message type.\"\"\"\r\n        message_type = self.get_message_type()\r\n        \r\n        if message_type == \"conversation\":\r\n            self.log(\"Routing to conversation output\")\r\n            self.status = self.data[0]\r\n            self.stop(\"audioMessage\")\r\n            self.stop(\"reaction\")\r\n            return self.data[0]\r\n            \r\n        self.stop(\"conversation\")\r\n        return Data()\r\n\r\n    def handle_reaction(self) -> Data:\r\n        \"\"\"Handle reaction message type.\"\"\"\r\n        message_type = self.get_message_type()\r\n        \r\n        if message_type == \"reactionmessage\":\r\n            self.log(\"Routing to reaction output\")\r\n            self.status = self.data[0]\r\n            self.stop(\"audioMessage\")\r\n            self.stop(\"conversation\")\r\n            return self.data[0]\r\n            \r\n        self.stop(\"reaction\")\r\n        return Data()","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false}},"description":"Routes data to different outputs based on message type.","icon":"git-branch","base_classes":["Data"],"display_name":"Evolution Router","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"audioMessage","display_name":"Audio Message","method":"handle_audio","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"conversation","display_name":"Conversation","method":"handle_conversation","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"reaction","display_name":"Reaction","method":"handle_reaction","value":"__UNDEFINED__","cache":true}],"field_order":["data"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14"},"type":"CustomComponent","id":"CustomComponent-xHIbo"},"selected":false,"measured":{"width":320,"height":311},"dragging":false}],"edges":[{"source":"Webhook-1NLyE","sourceHandle":"{œdataTypeœ:œWebhookœ,œidœ:œWebhook-1NLyEœ,œnameœ:œoutput_dataœ,œoutput_typesœ:[œDataœ]}","target":"CustomComponent-Wj3aX","targetHandle":"{œfieldNameœ:œdataœ,œidœ:œCustomComponent-Wj3aXœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","data":{"targetHandle":{"fieldName":"data","id":"CustomComponent-Wj3aX","inputTypes":["Data"],"type":"other"},"sourceHandle":{"dataType":"Webhook","id":"Webhook-1NLyE","name":"output_data","output_types":["Data"]}},"id":"reactflow__edge-Webhook-1NLyE{œdataTypeœ:œWebhookœ,œidœ:œWebhook-1NLyEœ,œnameœ:œoutput_dataœ,œoutput_typesœ:[œDataœ]}-CustomComponent-Wj3aX{œfieldNameœ:œdataœ,œidœ:œCustomComponent-Wj3aXœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","animated":false,"className":"","selected":false},{"source":"CustomComponent-wwYDP","sourceHandle":"{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-wwYDPœ,œnameœ:œresponseœ,œoutput_typesœ:[œDataœ]}","target":"ParseData-dKjFC","targetHandle":"{œfieldNameœ:œdataœ,œidœ:œParseData-dKjFCœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","data":{"targetHandle":{"fieldName":"data","id":"ParseData-dKjFC","inputTypes":["Data"],"type":"other"},"sourceHandle":{"dataType":"CustomComponent","id":"CustomComponent-wwYDP","name":"response","output_types":["Data"]}},"id":"reactflow__edge-CustomComponent-wwYDP{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-wwYDPœ,œnameœ:œresponseœ,œoutput_typesœ:[œDataœ]}-ParseData-dKjFC{œfieldNameœ:œdataœ,œidœ:œParseData-dKjFCœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","animated":false,"className":"","selected":false},{"source":"ParseData-dKjFC","sourceHandle":"{œdataTypeœ:œParseDataœ,œidœ:œParseData-dKjFCœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}","target":"ChatOutput-2UIv3","targetHandle":"{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-2UIv3œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"input_value","id":"ChatOutput-2UIv3","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"ParseData","id":"ParseData-dKjFC","name":"text","output_types":["Message"]}},"id":"reactflow__edge-ParseData-dKjFC{œdataTypeœ:œParseDataœ,œidœ:œParseData-dKjFCœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-2UIv3{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-2UIv3œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","animated":false,"className":""},{"source":"Webhook-1NLyE","sourceHandle":"{œdataTypeœ:œWebhookœ,œidœ:œWebhook-1NLyEœ,œnameœ:œraw_payloadœ,œoutput_typesœ:[œMessageœ]}","target":"ChatOutput-TZgz9","targetHandle":"{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-TZgz9œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"input_value","id":"ChatOutput-TZgz9","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"Webhook","id":"Webhook-1NLyE","name":"raw_payload","output_types":["Message"]}},"id":"reactflow__edge-Webhook-1NLyE{œdataTypeœ:œWebhookœ,œidœ:œWebhook-1NLyEœ,œnameœ:œraw_payloadœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-TZgz9{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-TZgz9œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","className":"","animated":false},{"source":"CustomComponent-xHIbo","sourceHandle":"{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-xHIboœ,œnameœ:œreactionœ,œoutput_typesœ:[œDataœ]}","target":"CustomComponent-wwYDP","targetHandle":"{œfieldNameœ:œdataœ,œidœ:œCustomComponent-wwYDPœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","data":{"targetHandle":{"fieldName":"data","id":"CustomComponent-wwYDP","inputTypes":["Data"],"type":"other"},"sourceHandle":{"dataType":"CustomComponent","id":"CustomComponent-xHIbo","name":"reaction","output_types":["Data"]}},"id":"reactflow__edge-CustomComponent-xHIbo{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-xHIboœ,œnameœ:œreactionœ,œoutput_typesœ:[œDataœ]}-CustomComponent-wwYDP{œfieldNameœ:œdataœ,œidœ:œCustomComponent-wwYDPœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","animated":false,"className":"","selected":false},{"source":"CustomComponent-Wj3aX","sourceHandle":"{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-Wj3aXœ,œnameœ:œparsed_dataœ,œoutput_typesœ:[œDataœ]}","target":"CustomComponent-xHIbo","targetHandle":"{œfieldNameœ:œdataœ,œidœ:œCustomComponent-xHIboœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","data":{"targetHandle":{"fieldName":"data","id":"CustomComponent-xHIbo","inputTypes":["Data"],"type":"other"},"sourceHandle":{"dataType":"CustomComponent","id":"CustomComponent-Wj3aX","name":"parsed_data","output_types":["Data"]}},"id":"reactflow__edge-CustomComponent-Wj3aX{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-Wj3aXœ,œnameœ:œparsed_dataœ,œoutput_typesœ:[œDataœ]}-CustomComponent-xHIbo{œfieldNameœ:œdataœ,œidœ:œCustomComponent-xHIboœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","className":""}],"viewport":{"x":1073.665748883147,"y":768.7755723429198,"zoom":0.6462025615659996}},"is_component":false,"updated_at":"2025-01-06T18:26:42+00:00","webhook":true,"endpoint_name":"felipe-whats","tags":null,"locked":null,"id":"eea656ab-9a29-4d52-b92c-71f196a193df","user_id":"556fed76-1562-4baf-8a2e-ef9be2d194e4","folder_id":"22c5349e-60ef-45a2-a8ec-0debcd24f6dd"},{"name":"Webhook POST","description":"Sends a POST request to a specified URL with JSON data","icon":null,"icon_bg_color":null,"gradient":null,"data":{"edges":[],"nodes":[{"data":{"node":{"template":{"_type":"Component","data":{"tool_mode":false,"trace_as_metadata":true,"list":false,"trace_as_input":true,"required":true,"placeholder":"","show":true,"name":"data","value":"","display_name":"Data","advanced":false,"input_types":["Data"],"dynamic":false,"info":"The data to be sent as JSON in the request body","title_case":false,"type":"other","_input_type":"DataInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Dict, Any\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    DataInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\nclass WebhookPostComponent(Component):\r\n    display_name = \"Webhook POST\"\r\n    description = \"Sends a POST request to a specified URL with JSON data\"\r\n    icon = \"webhook\"\r\n    name = \"webhook_post\"\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"url\",\r\n            display_name=\"URL\",\r\n            info=\"The URL to send the POST request to\",\r\n            required=True,\r\n        ),\r\n        DataInput(\r\n            name=\"data\",\r\n            display_name=\"Data\",\r\n            info=\"The data to be sent as JSON in the request body\",\r\n            required=True,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"response\",\r\n            display_name=\"Response\",\r\n            method=\"send_webhook\",\r\n        ),\r\n    ]\r\n\r\n    def send_webhook(self) -> Data:\r\n        \"\"\"\r\n        Send a POST request to the specified URL with JSON data.\r\n        \"\"\"\r\n        try:\r\n            # Log the URL (excluding any sensitive parts)\r\n            safe_url = self.url.split(\"?\")[0]  # Remove query parameters if any\r\n            self.log(f\"Preparing to send POST request to: {safe_url}\")\r\n            \r\n            # Convert data to JSON\r\n            try:\r\n                # Handle Data object\r\n                if isinstance(self.data, Data):\r\n                    payload = self.data.data\r\n                elif isinstance(self.data, str):\r\n                    # If data is a string, try to parse it as JSON\r\n                    payload = json.loads(self.data)\r\n                else:\r\n                    # If data is already a dict/list, use it directly\r\n                    payload = self.data\r\n                    \r\n                self.log(\"Data successfully converted to JSON format\")\r\n            except json.JSONDecodeError as e:\r\n                self.log(f\"Error converting data to JSON: {str(e)}\")\r\n                return Data(data={\r\n                    \"error\": \"Invalid JSON data\",\r\n                    \"details\": str(e),\r\n                    \"status\": \"ERROR\"\r\n                })\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"Content-Type\": \"application/json\"\r\n            }\r\n            \r\n            # Log the request details (excluding sensitive data)\r\n            self.log(\"Sending POST request with JSON payload\")\r\n            \r\n            # Send the POST request\r\n            response = requests.post(\r\n                self.url,\r\n                json=payload,\r\n                headers=headers\r\n            )\r\n            \r\n            self.log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Try to parse response as JSON\r\n            try:\r\n                response_data = response.json()\r\n                response_type = \"json\"\r\n            except json.JSONDecodeError:\r\n                response_data = response.text\r\n                response_type = \"text\"\r\n            \r\n            # Check if request was successful\r\n            response.raise_for_status()\r\n            \r\n            # Process response into consistent format\r\n            processed_response = {\r\n                \"status\": \"SUCCESS\",\r\n                \"status_code\": response.status_code,\r\n                \"response_type\": response_type,\r\n                \"response_data\": response_data,\r\n                \"headers\": dict(response.headers)\r\n            }\r\n            \r\n            self.log(\"Request completed successfully\")\r\n            \r\n            return Data(data=processed_response)\r\n\r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"Request failed: {str(e)}\"\r\n            self.log(f\"Error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\",\r\n                \"status_code\": getattr(e.response, 'status_code', None) if hasattr(e, 'response') else None\r\n            })\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"url","value":"http://192.168.112.129/api/v1/webhook/auto_transcription?api_key=sk-JXCm-YtyH8OwTzf5v_74EL799UQSXPs__a5jBptqmsc","display_name":"URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The URL to send the POST request to","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Sends a POST request to a specified URL with JSON data","icon":"webhook","base_classes":["Data"],"display_name":"Webhook POST","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"response","display_name":"Response","method":"send_webhook","value":"__UNDEFINED__","cache":true}],"field_order":["url","data"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14","official":false,"category":"saved_components","key":"CustomComponent (2QWFQ)","score":0.007568328950209746},"type":"CustomComponent","id":"CustomComponent-EnaG2"},"id":"CustomComponent-EnaG2","position":{"x":0,"y":0},"type":"genericNode"}],"viewport":{"x":1,"y":1,"zoom":1}},"is_component":true,"updated_at":"2025-01-06T17:56:24+00:00","webhook":false,"endpoint_name":null,"tags":null,"locked":false,"id":"3529586f-101a-4966-bb0d-4fcc37fa7042","user_id":"556fed76-1562-4baf-8a2e-ef9be2d194e4","folder_id":"22c5349e-60ef-45a2-a8ec-0debcd24f6dd"},{"name":"webhook test","description":"Convert a Message object to a Data object","icon":null,"icon_bg_color":null,"gradient":null,"data":{"edges":[],"nodes":[{"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from loguru import logger\n\nfrom langflow.custom import Component\nfrom langflow.io import MessageInput, Output\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\n\n\nclass MessageToDataComponent(Component):\n    display_name = \"Message to Data\"\n    description = \"Convert a Message object to a Data object\"\n    icon = \"message-square-share\"\n    beta = True\n    name = \"MessagetoData\"\n\n    inputs = [\n        MessageInput(\n            name=\"message\",\n            display_name=\"Message\",\n            info=\"The Message object to convert to a Data object\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"data\", method=\"convert_message_to_data\"),\n    ]\n\n    def convert_message_to_data(self) -> Data:\n        if isinstance(self.message, Message):\n            # Convert Message to Data\n            return Data(data=self.message.data)\n\n        msg = \"Error converting Message to Data: Input must be a Message object\"\n        logger.opt(exception=True).debug(msg)\n        self.status = msg\n        return Data(data={\"error\": msg})\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"message":{"trace_as_input":true,"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"message","value":"{trigger:auto_transcription}","display_name":"Message","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The Message object to convert to a Data object","title_case":false,"type":"str","_input_type":"MessageInput"}},"description":"Convert a Message object to a Data object","icon":"message-square-share","base_classes":["Data"],"display_name":"webhook test","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"data","display_name":"Data","method":"convert_message_to_data","value":"__UNDEFINED__","cache":true}],"field_order":["message"],"beta":true,"legacy":false,"edited":false,"metadata":{},"tool_mode":false,"category":"processing","key":"MessagetoData","score":0.008222426499470714,"lf_version":"1.1.1.dev14","official":false},"type":"MessagetoData","id":"MessagetoData-CYSXF"},"id":"MessagetoData-CYSXF","position":{"x":0,"y":0},"type":"genericNode"}],"viewport":{"x":1,"y":1,"zoom":1}},"is_component":true,"updated_at":"2025-01-06T17:56:24+00:00","webhook":false,"endpoint_name":null,"tags":null,"locked":false,"id":"66a6f456-d665-4526-baaa-307cecd51a7a","user_id":"556fed76-1562-4baf-8a2e-ef9be2d194e4","folder_id":"22c5349e-60ef-45a2-a8ec-0debcd24f6dd"},{"name":"Evolution Components v0.1","description":"Generate, Innovate, Communicate.","icon":null,"icon_bg_color":null,"gradient":null,"data":{"nodes":[{"id":"CustomComponent-6Ztzt","type":"genericNode","position":{"x":-731.2019298272717,"y":-171.54208638728213},"data":{"node":{"template":{"_type":"Component","api_key":{"load_from_db":false,"required":true,"placeholder":"","show":true,"name":"api_key","value":null,"display_name":"API Key","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API key for authentication","title_case":false,"password":true,"type":"str","_input_type":"SecretStrInput"},"base_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"base_url","value":"http://evo.namastex.io:8080","display_name":"API Base URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API base URL (e.g., http://example.com:8080)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Dict, Any\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    SecretStrInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\nclass FindMessagesComponent(Component):\r\n    display_name = \"Evolution Find Messages\"\r\n    description = \"Search for messages in Evolution API using various criteria\"\r\n    icon = \"messages-square\"\r\n    name = \"find_messages\"\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"base_url\",\r\n            display_name=\"API Base URL\",\r\n            info=\"Evolution API base URL (e.g., http://example.com:8080)\",\r\n            required=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"api_key\",\r\n            display_name=\"API Key\",\r\n            info=\"Evolution API key for authentication\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"remote_jid\",\r\n            display_name=\"Remote JID\",\r\n            info=\"WhatsApp ID to search messages from (e.g., 5551999999999@s.whatsapp.net)\",\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"info\",\r\n            display_name=\"Info\",\r\n            method=\"get_info\",\r\n        ),\r\n        Output(\r\n            name=\"messages\",\r\n            display_name=\"Messages\",\r\n            method=\"get_messages\",\r\n        ),\r\n    ]\r\n\r\n    def build_query(self) -> Dict[str, Any]:\r\n        \"\"\"Build the query parameters for the API request.\"\"\"\r\n        self.log(f\"Building query for remote_jid: {self.remote_jid}\")\r\n\r\n        query = {\"where\": {}}\r\n\r\n        if self.remote_jid:\r\n            query[\"where\"][\"key\"] = {\"remoteJid\": self.remote_jid}\r\n\r\n        self.log(f\"Final query built: {json.dumps(query, indent=2)}\")\r\n        return query\r\n\r\n    def find_messages(self) -> Data:\r\n        \"\"\"\r\n        Fetch messages from Evolution API based on search criteria.\r\n        \"\"\"\r\n        try:\r\n            # Ensure base URL format\r\n            base_url = self.base_url.rstrip('/')\r\n            self.log(f\"Using base URL: {base_url}\")\r\n            \r\n            # Build API endpoint URL\r\n            url = f\"{base_url}/chat/findMessages/{self.instance_id}\"\r\n            self.log(f\"Full API endpoint URL: {url}\")\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n                \"Content-Type\": \"application/json\"\r\n            }\r\n            self.log(\"Headers prepared (apikey hidden)\")\r\n            self.log(headers)\r\n\r\n            # Build query\r\n            query = self.build_query()\r\n            self.log(f\"Using query parameters: {json.dumps(query, indent=2)}\")\r\n\r\n            # Make API request\r\n            self.log(\"Making API request...\")\r\n            response = requests.post(url, headers=headers, json=query)\r\n            \r\n            self.log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Check for successful response\r\n            response.raise_for_status()\r\n            \r\n            # Parse response\r\n            data = response.json()\r\n            self.log(f\"Successfully parsed JSON response\")\r\n            \r\n            return Data(data=data)\r\n\r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"API request failed: {str(e)}\"\r\n            self.log(f\"Request error: {error_msg}\")\r\n            return Data(data={})\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Unexpected error: {error_msg}\")\r\n            return Data(data={})\r\n\r\n    def get_info(self) -> Data:\r\n        \"\"\"Extract and return the info from the API response.\"\"\"\r\n        data = self.find_messages().data\r\n        info = {\r\n            \"total\": data.get(\"messages\", {}).get(\"total\"),\r\n            \"pages\": data.get(\"messages\", {}).get(\"pages\"),\r\n            \"currentPage\": data.get(\"messages\", {}).get(\"currentPage\"),\r\n        }\r\n        self.log(f\"Extracted info: {json.dumps(info, indent=2)}\")\r\n        return Data(data=info)\r\n\r\n    def get_messages(self) -> list[Data]:\r\n        \"\"\"Extract and return the messages from the API response.\"\"\"\r\n        data = self.find_messages().data\r\n        messages = data.get(\"messages\", {}).get(\"records\", [])\r\n        self.log(f\"Extracted messages: {len(messages)} found\")\r\n        \r\n        # Process each message to ensure proper data structure\r\n        processed_messages = []\r\n        for msg in messages:\r\n            processed_msg = Data(data={\r\n                \"id\": msg.get(\"id\"),\r\n                \"key\": msg.get(\"key\", {}),\r\n                \"message\": msg.get(\"message\", {}),\r\n                \"messageTimestamp\": msg.get(\"messageTimestamp\"),\r\n                \"status\": msg.get(\"status\"),\r\n                \"MessageUpdate\": msg.get(\"MessageUpdate\", [])\r\n            })\r\n            processed_messages.append(processed_msg)\r\n            \r\n        return processed_messages","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"instance_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"felipe8888","display_name":"Instance ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"MessageTextInput"},"remote_jid":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"remote_jid","value":"5527997482360@s.whatsapp.net","display_name":"Remote JID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"WhatsApp ID to search messages from (e.g., 5551999999999@s.whatsapp.net)","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Search for messages in Evolution API using various criteria","icon":"messages-square","base_classes":["Data"],"display_name":"Evolution Find Messages","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"info","display_name":"Info","method":"get_info","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"messages","display_name":"Messages","method":"get_messages","value":"__UNDEFINED__","cache":true}],"field_order":["base_url","api_key","instance_id","remote_jid"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14"},"type":"CustomComponent","id":"CustomComponent-6Ztzt"},"selected":false,"width":320,"height":559,"positionAbsolute":{"x":-498.35462940862254,"y":-25.69267843274372},"dragging":false,"measured":{"width":320,"height":559}},{"id":"CustomComponent-d7fhr","type":"genericNode","position":{"x":147.08429931000097,"y":-58.87454834507242},"data":{"node":{"template":{"_type":"Component","api_key":{"load_from_db":false,"required":true,"placeholder":"","show":true,"name":"api_key","value":null,"display_name":"API Key","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API key for authentication","title_case":false,"password":true,"type":"str","_input_type":"SecretStrInput"},"base_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"base_url","value":"http://evo.namastex.io:8080","display_name":"API Base URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API base URL (e.g., http://example.com:8080)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Dict, Any, List\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    SecretStrInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass FindChatsComponent(Component):\r\n    display_name = \"Evolution Find Chats\"\r\n    description = \"Fetch chats from Evolution API\"\r\n    icon = \"messages-square\"\r\n    name = \"find_chats\"\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"base_url\",\r\n            display_name=\"API Base URL\",\r\n            info=\"Evolution API base URL (e.g., http://example.com:8080)\",\r\n            required=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"api_key\",\r\n            display_name=\"API Key\",\r\n            info=\"Evolution API key for authentication\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"chats\",\r\n            display_name=\"Chats\",\r\n            method=\"get_chats\",\r\n        ),\r\n    ]\r\n\r\n    def find_chats(self) -> Data:\r\n        \"\"\"\r\n        Fetch chats from Evolution API.\r\n        \"\"\"\r\n        try:\r\n            # Ensure base URL format\r\n            base_url = self.base_url.rstrip('/')\r\n            self.log(f\"Using base URL: {base_url}\")\r\n            \r\n            # Build API endpoint URL\r\n            url = f\"{base_url}/chat/findChats/{self.instance_id}\"\r\n            self.log(f\"Full API endpoint URL: {url}\")\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n            }\r\n            self.log(\"Headers prepared (apikey hidden)\")\r\n\r\n            # Empty payload as per API specification\r\n            payload = {}\r\n            \r\n            # Log the complete request\r\n            request_info = {\r\n                \"url\": url,\r\n                \"headers\": {\r\n                    \"apikey\": \"***hidden***\"\r\n                },\r\n                \"payload\": payload\r\n            }\r\n            self.log(f\"Making request: {json.dumps(request_info, indent=2)}\")\r\n\r\n            # Make API request\r\n            response = requests.post(url, headers=headers, json=payload)\r\n            \r\n            self.log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Check for successful response\r\n            response.raise_for_status()\r\n            \r\n            # Parse response and wrap in a dictionary\r\n            data = response.json()\r\n            if isinstance(data, list):\r\n                wrapped_data = {\"chats\": data}\r\n            else:\r\n                wrapped_data = {\"chats\": []}\r\n                \r\n            self.log(f\"Successfully parsed JSON response with {len(wrapped_data['chats'])} chats\")\r\n            \r\n            return Data(data=wrapped_data)\r\n\r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"API request failed: {str(e)}\"\r\n            self.log(f\"Request error: {error_msg}\")\r\n            return Data(data={\"chats\": []})\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Unexpected error: {error_msg}\")\r\n            return Data(data={\"chats\": []})\r\n\r\n    def process_message(self, message: Dict[str, Any]) -> Dict[str, Any]:\r\n        \"\"\"Process a message object to ensure consistent structure.\"\"\"\r\n        if not message:\r\n            return {}\r\n            \r\n        return {\r\n            \"id\": message.get(\"id\"),\r\n            \"key\": message.get(\"key\", {}),\r\n            \"pushName\": message.get(\"pushName\", \"\"),\r\n            \"participant\": message.get(\"participant\"),\r\n            \"messageType\": message.get(\"messageType\"),\r\n            \"message\": message.get(\"message\", {}),\r\n            \"contextInfo\": message.get(\"contextInfo\"),\r\n            \"source\": message.get(\"source\"),\r\n            \"messageTimestamp\": message.get(\"messageTimestamp\"),\r\n            \"instanceId\": message.get(\"instanceId\"),\r\n            \"sessionId\": message.get(\"sessionId\"),\r\n            \"status\": message.get(\"status\")\r\n        }\r\n\r\n    def process_chat(self, chat: Dict[str, Any]) -> Dict[str, Any]:\r\n        \"\"\"Process a single chat object to ensure consistent structure.\"\"\"\r\n        if not chat:\r\n            return {}\r\n            \r\n        processed = {\r\n            \"id\": chat.get(\"id\"),\r\n            \"remoteJid\": chat.get(\"remoteJid\"),\r\n            \"name\": chat.get(\"name\", \"\"),\r\n            \"labels\": chat.get(\"labels\"),\r\n            \"createdAt\": chat.get(\"createdAt\"),\r\n            \"updatedAt\": chat.get(\"updatedAt\"),\r\n            \"pushName\": chat.get(\"pushName\", \"\"),\r\n            \"profilePicUrl\": chat.get(\"profilePicUrl\"),\r\n            \"unreadMessages\": chat.get(\"unreadMessages\", 0),\r\n        }\r\n        \r\n        # Process lastMessage if present\r\n        if last_message := chat.get(\"lastMessage\"):\r\n            processed[\"lastMessage\"] = self.process_message(last_message)\r\n            \r\n        return processed\r\n\r\n    def get_chats(self) -> List[Data]:\r\n        \"\"\"Extract and return the chats from the API response.\"\"\"\r\n        response_data = self.find_chats().data\r\n        chats = response_data.get(\"chats\", [])\r\n        \r\n        self.log(f\"Processing {len(chats)} chats\")\r\n        \r\n        processed_chats = []\r\n        for chat in chats:\r\n            processed_chat = self.process_chat(chat)\r\n            if processed_chat:  # Only add non-empty chats\r\n                processed_chats.append(Data(data=processed_chat))\r\n            \r\n        self.log(f\"Successfully processed {len(processed_chats)} chats\")\r\n        return processed_chats","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"instance_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"felipe8888","display_name":"Instance ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Fetch chats from Evolution API","icon":"messages-square","base_classes":["Data"],"display_name":"Evolution Find Chats","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"chats","display_name":"Chats","method":"get_chats","value":"__UNDEFINED__","cache":true}],"field_order":["base_url","api_key","instance_id"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1"},"type":"CustomComponent","id":"CustomComponent-d7fhr"},"selected":false,"width":320,"height":405,"dragging":false,"positionAbsolute":{"x":-898.3001251179528,"y":88.80053250623665},"measured":{"width":320,"height":405}},{"id":"CustomComponent-lJZ1c","type":"genericNode","position":{"x":-2684.6279630094477,"y":-542.7914223597772},"data":{"node":{"template":{"_type":"Component","api_key":{"load_from_db":false,"required":true,"placeholder":"","show":true,"name":"api_key","value":null,"display_name":"API Key","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API key for authentication","title_case":false,"password":true,"type":"str","_input_type":"SecretStrInput"},"base_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"base_url","value":"","display_name":"API Base URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API base URL (e.g., http://example.com:8080)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Dict, Any\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    SecretStrInput,\r\n    IntInput,\r\n    BoolInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass SendTextMessageComponent(Component):\r\n    display_name = \"Evolution Send Text Message\"\r\n    description = \"Send a text message using Evolution API\"\r\n    icon = \"message-square\"\r\n    name = \"send_text_message\"\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"base_url\",\r\n            display_name=\"API Base URL\",\r\n            info=\"Evolution API base URL (e.g., http://example.com:8080)\",\r\n            required=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"api_key\",\r\n            display_name=\"API Key\",\r\n            info=\"Evolution API key for authentication\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"number\",\r\n            display_name=\"Recipient Number\",\r\n            info=\"WhatsApp ID of the recipient (e.g., 5511999999999@s.whatsapp.net)\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"text\",\r\n            display_name=\"Message Text\",\r\n            info=\"The text message to send\",\r\n            required=True,\r\n        ),\r\n        # Advanced options\r\n        MessageTextInput(\r\n            name=\"quoted_message_id\",\r\n            display_name=\"Quoted Message ID\",\r\n            info=\"ID of the message to quote (optional)\",\r\n            advanced=True,\r\n            required=False,\r\n        ),\r\n        IntInput(\r\n            name=\"delay\",\r\n            display_name=\"Delay\",\r\n            info=\"Optional delay in milliseconds\",\r\n            advanced=True,\r\n        ),\r\n        BoolInput(\r\n            name=\"mentions_everyone\",\r\n            display_name=\"Mention Everyone\",\r\n            info=\"Whether to mention all participants\",\r\n            advanced=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"mentioned\",\r\n            display_name=\"Mentioned Numbers\",\r\n            info=\"List of WhatsApp IDs to mention (comma-separated)\",\r\n            advanced=True,\r\n            is_list=True,\r\n        ),\r\n        BoolInput(\r\n            name=\"link_preview\",\r\n            display_name=\"Link Preview\",\r\n            info=\"Whether to show link previews in the message\",\r\n            advanced=True,\r\n        ),\r\n        BoolInput(\r\n            name=\"show_typing\",\r\n            display_name=\"Show Typing\",\r\n            info=\"Show typing indicator before sending message\",\r\n            advanced=True,\r\n        ),\r\n        IntInput(\r\n            name=\"typing_delay\",\r\n            display_name=\"Typing Delay\",\r\n            info=\"How long to show typing indicator (in milliseconds)\",\r\n            advanced=True,\r\n            value=3000,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"message\",\r\n            display_name=\"Message\",\r\n            method=\"send_message\",\r\n        ),\r\n    ]\r\n\r\n    def build_payload(self) -> Dict[str, Any]:\r\n        \"\"\"Build the request payload.\"\"\"\r\n        payload = {\r\n            \"number\": self.number,\r\n            \"text\": self.text\r\n        }\r\n        \r\n        # Add optional fields if provided\r\n        if hasattr(self, 'delay') and self.delay:\r\n            payload[\"delay\"] = self.delay\r\n            \r\n        if hasattr(self, 'mentions_everyone'):\r\n            payload[\"mentionsEveryOne\"] = self.mentions_everyone\r\n            \r\n        if hasattr(self, 'mentioned') and self.mentioned:\r\n            payload[\"mentioned\"] = self.mentioned\r\n\r\n        if hasattr(self, 'link_preview'):\r\n            payload[\"linkPreview\"] = self.link_preview\r\n\r\n        # Add quoted message if ID is provided\r\n        if hasattr(self, 'quoted_message_id') and self.quoted_message_id:\r\n            payload[\"quoted\"] = {\r\n                \"key\": {\r\n                    \"id\": self.quoted_message_id\r\n                }\r\n            }\r\n        \r\n        # Log payload (excluding sensitive data)\r\n        safe_payload = {**payload}\r\n        safe_payload[\"number\"] = \"***hidden***\"\r\n        self.log(f\"Built payload: {json.dumps(safe_payload, indent=2)}\")\r\n        \r\n        return payload\r\n\r\n    def send_presence(self) -> None:\r\n        \"\"\"Send typing presence indicator.\"\"\"\r\n        try:\r\n            base_url = self.base_url.rstrip('/')\r\n            url = f\"{base_url}/chat/sendPresence/{self.instance_id}\"\r\n            \r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n                \"Content-Type\": \"application/json\"\r\n            }\r\n            \r\n            payload = {\r\n                \"number\": self.number,\r\n                \"delay\": self.typing_delay,\r\n                \"presence\": \"composing\"\r\n            }\r\n            \r\n            self.log(\"Sending typing presence indicator...\")\r\n            response = requests.post(url, headers=headers, json=payload)\r\n            response.raise_for_status()\r\n            self.log(\"Typing indicator sent successfully\")\r\n            \r\n        except Exception as e:\r\n            self.log(f\"Error sending typing presence: {str(e)}\")\r\n\r\n    def send_message(self) -> Data:\r\n        \"\"\"\r\n        Send a text message via Evolution API.\r\n        \"\"\"\r\n        try:\r\n            # Ensure base URL format\r\n            base_url = self.base_url.rstrip('/')\r\n            self.log(f\"Using base URL: {base_url}\")\r\n            \r\n            # Send typing presence if enabled\r\n            if hasattr(self, 'show_typing') and self.show_typing:\r\n                self.send_presence()\r\n            \r\n            # Build API endpoint URL\r\n            url = f\"{base_url}/message/sendText/{self.instance_id}\"\r\n            self.log(f\"Full API endpoint URL: {url}\")\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n                \"Content-Type\": \"application/json\"\r\n            }\r\n            self.log(\"Headers prepared (apikey hidden)\")\r\n\r\n            # Build payload\r\n            payload = self.build_payload()\r\n            \r\n            # Log the complete request (excluding sensitive data)\r\n            request_info = {\r\n                \"url\": url,\r\n                \"headers\": {\r\n                    \"Content-Type\": \"application/json\",\r\n                    \"apikey\": \"***hidden***\"\r\n                },\r\n                \"payload\": {\r\n                    \"number\": \"***hidden***\",\r\n                    \"text\": payload[\"text\"]\r\n                }\r\n            }\r\n            self.log(f\"Making request: {json.dumps(request_info, indent=2)}\")\r\n\r\n            # Make API request\r\n            response = requests.post(\r\n                url, \r\n                headers=headers, \r\n                data=json.dumps(payload)\r\n            )\r\n            \r\n            self.log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Check for successful response\r\n            response.raise_for_status()\r\n            \r\n            # Parse response\r\n            data = response.json()\r\n            \r\n            # Process response into consistent format\r\n            processed_response = {\r\n                \"key\": data.get(\"key\", {}),\r\n                \"pushName\": data.get(\"pushName\", \"\"),\r\n                \"status\": data.get(\"status\"),\r\n                \"message\": data.get(\"message\", {}),\r\n                \"contextInfo\": data.get(\"contextInfo\"),\r\n                \"messageType\": data.get(\"messageType\"),\r\n                \"messageTimestamp\": data.get(\"messageTimestamp\"),\r\n                \"instanceId\": data.get(\"instanceId\"),\r\n                \"source\": data.get(\"source\")\r\n            }\r\n            \r\n            self.log(\"Message sent successfully\")\r\n            self.log(f\"Message status: {processed_response.get('status')}\")\r\n            \r\n            return Data(data=processed_response)\r\n\r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"API request failed: {str(e)}\"\r\n            self.log(f\"Request error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Unexpected error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"delay":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"delay","value":"","display_name":"Delay","advanced":false,"dynamic":false,"info":"Optional delay in milliseconds","title_case":false,"type":"int","_input_type":"IntInput"},"instance_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"felipe8888","display_name":"Instance ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"MessageTextInput"},"link_preview":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"link_preview","value":false,"display_name":"Link Preview","advanced":false,"dynamic":false,"info":"Whether to show link previews in the message","title_case":false,"type":"bool","_input_type":"BoolInput"},"mentioned":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":true,"required":false,"placeholder":"","show":true,"name":"mentioned","value":"","display_name":"Mentioned Numbers","advanced":false,"input_types":["Message"],"dynamic":false,"info":"List of WhatsApp IDs to mention (comma-separated)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"mentions_everyone":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"mentions_everyone","value":false,"display_name":"Mention Everyone","advanced":false,"dynamic":false,"info":"Whether to mention all participants","title_case":false,"type":"bool","_input_type":"BoolInput"},"number":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"number","value":"5511986780008@s.whatsapp.net","display_name":"Recipient Number","advanced":false,"input_types":["Message"],"dynamic":false,"info":"WhatsApp ID of the recipient (e.g., 5511999999999@s.whatsapp.net)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"quoted_message_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"quoted_message_id","value":"","display_name":"Quoted Message ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"ID of the message to quote (optional)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"show_typing":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"show_typing","value":true,"display_name":"Show Typing","advanced":false,"dynamic":false,"info":"Show typing indicator before sending message","title_case":false,"type":"bool","_input_type":"BoolInput"},"text":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"text","value":"https://doc.evolution-api.com/v2/api-reference/chat-controller/send-presence","display_name":"Message Text","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The text message to send","title_case":false,"type":"str","_input_type":"MessageTextInput"},"typing_delay":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"typing_delay","value":3000,"display_name":"Typing Delay","advanced":false,"dynamic":false,"info":"How long to show typing indicator (in milliseconds)","title_case":false,"type":"int","_input_type":"IntInput"}},"description":"Send a text message using Evolution API","icon":"message-square","base_classes":["Data"],"display_name":"Evolution Send Text Message","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"message","display_name":"Message","method":"send_message","value":"__UNDEFINED__","cache":true}],"field_order":["base_url","api_key","instance_id","number","text","quoted_message_id","delay","mentions_everyone","mentioned","link_preview","show_typing","typing_delay"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1"},"type":"CustomComponent","id":"CustomComponent-lJZ1c"},"selected":false,"width":320,"height":577,"dragging":false,"positionAbsolute":{"x":-1291.0866790143245,"y":-17.807467747247514},"measured":{"width":320,"height":577}},{"id":"CustomComponent-pk1eW","type":"genericNode","position":{"x":-293.03307721417366,"y":-101.8824232946523},"data":{"node":{"template":{"_type":"Component","api_key":{"load_from_db":false,"required":true,"placeholder":"","show":true,"name":"api_key","value":null,"display_name":"API Key","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API key for authentication","title_case":false,"password":true,"type":"str","_input_type":"SecretStrInput"},"base_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"base_url","value":"","display_name":"API Base URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API base URL (e.g., http://example.com:8080)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Optional, Dict, Any, List\r\nfrom datetime import datetime\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    SecretStrInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\nclass FindContactsComponent(Component):\r\n    display_name = \"Evolution Find Contacts\"\r\n    description = \"Search for contacts in Evolution API with optional filtering\"\r\n    icon = \"users\"\r\n    name = \"find_contacts\"\r\n    logs = []  # Class variable for logs\r\n\r\n    def __init__(self, **kwargs):\r\n        super().__init__(**kwargs)\r\n\r\n    def custom_log(self, message: str):\r\n        \"\"\"Custom logging function that both prints and stores logs\"\"\"\r\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\r\n        log_entry = f\"[{timestamp}] {message}\"\r\n        self.logs.append(log_entry)\r\n        self.log(message)\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"base_url\",\r\n            display_name=\"API Base URL\",\r\n            info=\"Evolution API base URL (e.g., http://example.com:8080)\",\r\n            required=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"api_key\",\r\n            display_name=\"API Key\",\r\n            info=\"Evolution API key for authentication\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"remote_jid\",\r\n            display_name=\"Remote JID\",\r\n            info=\"WhatsApp ID to search contacts (e.g., 5551999999999@s.whatsapp.net). Leave empty to get all contacts\",\r\n            required=False,\r\n            advanced=True,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"result\",\r\n            display_name=\"Result\",\r\n            info=\"Retrieved contacts data\",\r\n            type=Data,\r\n            method=\"find_contacts\",\r\n        ),\r\n    ]\r\n\r\n    def build_query(self) -> Dict[str, Any]:\r\n        \"\"\"Build the query parameters for the API request.\"\"\"\r\n        self.custom_log(\"Building query parameters\")\r\n        \r\n        query = {}\r\n        if self.remote_jid:\r\n            query[\"where\"] = {\r\n                \"remoteJid\": self.remote_jid\r\n            }\r\n            self.custom_log(f\"Filtering by remoteJid: {self.remote_jid}\")\r\n        else:\r\n            self.custom_log(\"No remoteJid filter specified, will return all contacts\")\r\n\r\n        self.custom_log(f\"Final query built: {json.dumps(query, indent=2)}\")\r\n        return query\r\n\r\n    def find_contacts(self) -> Data:\r\n        \"\"\"\r\n        Fetch contacts from Evolution API based on search criteria.\r\n        \"\"\"\r\n        try:\r\n            # Clear previous logs\r\n            self.logs = []\r\n            \r\n            # Ensure base URL format\r\n            base_url = self.base_url.rstrip('/')\r\n            self.custom_log(f\"Using base URL: {base_url}\")\r\n            \r\n            # Build API endpoint URL\r\n            url = f\"{base_url}/chat/findContacts/{self.instance_id}\"\r\n            self.custom_log(f\"Full API endpoint URL: {url}\")\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n                \"Content-Type\": \"application/json\"\r\n            }\r\n            self.custom_log(\"Headers prepared (apikey hidden)\")\r\n\r\n            # Build query\r\n            query = self.build_query()\r\n            self.custom_log(f\"Using query parameters: {json.dumps(query, indent=2)}\")\r\n\r\n            # Make API request\r\n            self.custom_log(\"Making API request...\")\r\n            response = requests.post(url, headers=headers, json=query)\r\n            self.custom_log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Check for successful response\r\n            response.raise_for_status()\r\n            \r\n            # Parse response\r\n            contacts = response.json()\r\n            self.custom_log(f\"Successfully parsed JSON response\")\r\n            self.custom_log(f\"Found {len(contacts)} contacts\")\r\n\r\n            # Compile full log trace\r\n            full_trace = \"\\n\".join(self.logs)\r\n            self.custom_log(\"=== Full Execution Log Trace ===\\n\" + full_trace)\r\n\r\n            # Return the raw contacts list wrapped in Data\r\n            return Data(data=contacts[0] if contacts else {})\r\n\r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"API request failed: {str(e)}\"\r\n            self.custom_log(f\"Request error: {error_msg}\")\r\n            \r\n            # Compile full log trace\r\n            full_trace = \"\\n\".join(self.logs)\r\n            self.custom_log(\"=== Full Execution Log Trace ===\\n\" + full_trace)\r\n            \r\n            return Data(data={})\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.custom_log(f\"Unexpected error: {error_msg}\")\r\n            \r\n            # Compile full log trace\r\n            full_trace = \"\\n\".join(self.logs)\r\n            self.custom_log(\"=== Full Execution Log Trace ===\\n\" + full_trace)\r\n            \r\n            return Data(data={})","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"instance_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"felipe8888","display_name":"Instance ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"MessageTextInput"},"remote_jid":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"remote_jid","value":"5511986780008@s.whatsapp.net","display_name":"Remote JID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"WhatsApp ID to search contacts (e.g., 5551999999999@s.whatsapp.net). Leave empty to get all contacts","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Search for contacts in Evolution API with optional filtering","icon":"users","base_classes":["Data"],"display_name":"Evolution Find Contacts","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"result","display_name":"Result","method":"find_contacts","value":"__UNDEFINED__","cache":true}],"field_order":["base_url","api_key","instance_id","remote_jid"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1"},"type":"CustomComponent","id":"CustomComponent-pk1eW"},"selected":false,"width":320,"height":511,"positionAbsolute":{"x":-70.42082296777289,"y":54.202030832134426},"dragging":false,"measured":{"width":320,"height":511}},{"id":"note-ivvZ3","type":"noteNode","position":{"x":-3811.596920181883,"y":-330.8006685858849},"data":{"node":{"description":"INTEGRACAO OK, MAS DANDO PENDING.","display_name":"","documentation":"","template":{}},"type":"note","id":"note-ivvZ3"},"measured":{"width":324,"height":352},"selected":false,"dragging":false,"width":324,"height":352,"resizing":false},{"id":"CustomComponent-NqNlm","type":"genericNode","position":{"x":-3807.3740884128947,"y":-214.25120397287623},"data":{"node":{"template":{"_type":"Component","all_contacts":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":true,"placeholder":"","show":true,"name":"all_contacts","value":false,"display_name":"Send to All Contacts","advanced":false,"dynamic":false,"info":"Set to true to send to all contacts, false to specify statusJidList","title_case":false,"type":"bool","_input_type":"BoolInput"},"api_key":{"load_from_db":false,"required":true,"placeholder":"","show":true,"name":"api_key","value":null,"display_name":"API Key","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API key for authentication","title_case":false,"password":true,"type":"str","_input_type":"SecretStrInput"},"background_color":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"background_color","value":"#111111","display_name":"Background Color","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Background hex color (e.g., #000000). Used only for text.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"base_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"base_url","value":"","display_name":"API Base URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API base URL (e.g., https://evolution-api.namastex.ai)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"caption":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"caption","value":"teste2","display_name":"Caption","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Text caption for image status (optional). Ignored if not image.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Dict, Any, Optional, List\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    SecretStrInput,\r\n    Output,\r\n    DropdownInput,\r\n    BoolInput\r\n)\r\nfrom langflow.schema import Data\r\n\r\nclass SendStatusComponent(Component):\r\n    display_name = \"Evolution Send Status\"\r\n    description = \"Send a status message using Evolution API\"\r\n    icon = \"message-circle\"\r\n    name = \"send_status\"\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"base_url\",\r\n            display_name=\"API Base URL\",\r\n            info=\"Evolution API base URL (e.g., https://evolution-api.namastex.ai)\",\r\n            value=\"https://evolution-api.namastex.ai\",\r\n            required=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"api_key\",\r\n            display_name=\"API Key\",\r\n            info=\"Evolution API key for authentication\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"type\",\r\n            display_name=\"Status Type\",\r\n            info=\"Type of status to send (text, image, or audio)\",\r\n            options=[\"text\", \"image\", \"audio\"],\r\n            value=\"text\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"content\",\r\n            display_name=\"Content\",\r\n            info=\"For text: message text. For image/audio: URL of the file.\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"caption\",\r\n            display_name=\"Caption\",\r\n            info=\"Text caption for image status (optional). Ignored if not image.\",\r\n            required=False,\r\n            advanced=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"background_color\",\r\n            display_name=\"Background Color\",\r\n            info=\"Background hex color (e.g., #000000). Used only for text.\",\r\n            required=False,\r\n            advanced=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"font\",\r\n            display_name=\"Font\",\r\n            info=\"Font style for text status (1 to 5). Used only for text.\",\r\n            options=[\"1\", \"2\", \"3\", \"4\", \"5\"],\r\n            value=\"1\",\r\n            required=False,\r\n            advanced=True,\r\n        ),\r\n        BoolInput(\r\n            name=\"all_contacts\",\r\n            display_name=\"Send to All Contacts\",\r\n            info=\"Set to true to send to all contacts, false to specify statusJidList\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"status_jid_list\",\r\n            display_name=\"Status JID List\",\r\n            info=\"List of WhatsApp IDs to send status to (comma-separated if multiple)\",\r\n            required=False,\r\n            is_list=True,\r\n            advanced=True,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"message\",\r\n            display_name=\"Message\",\r\n            method=\"send_status\",\r\n        ),\r\n    ]\r\n\r\n    def build_payload(self) -> Dict[str, Any]:\r\n        \"\"\"Build the request payload for the Evolution API.\"\"\"\r\n        payload: Dict[str, Any] = {\r\n            \"type\": self.type,\r\n            \"content\": self.content,\r\n            \"allContacts\": self.all_contacts\r\n        }\r\n\r\n        # Conditionally add fields based on type\r\n        # Caption is generally for images, but the original snippet used it with text as well.\r\n        # We'll leave it optional and let the API handle it.\r\n        if self.caption and self.caption.strip():\r\n            payload[\"caption\"] = self.caption.strip()\r\n\r\n        # For text statuses, backgroundColor and font can be used\r\n        if self.type == \"text\":\r\n            if self.background_color and self.background_color.strip():\r\n                payload[\"backgroundColor\"] = self.background_color.strip()\r\n            if self.font:\r\n                try:\r\n                    font_int = int(self.font)\r\n                    payload[\"font\"] = font_int\r\n                except ValueError:\r\n                    # If conversion fails, just don't set the font\r\n                    self.log(\"Invalid font value, skipping font.\")\r\n        \r\n        # If not sending to all contacts, we must specify statusJidList\r\n        # Make sure it's a list of strings. If empty, it might cause a 400 error.\r\n        if not self.all_contacts:\r\n            jid_list = []\r\n            if self.status_jid_list:\r\n                # self.status_jid_list is already a list (due to is_list=True)\r\n                # We'll strip each entry\r\n                for jid in self.status_jid_list:\r\n                    stripped_jid = jid.strip()\r\n                    if stripped_jid:\r\n                        jid_list.append(stripped_jid)\r\n            \r\n            if not jid_list:\r\n                # If user hasn't provided any JID but allContacts=False\r\n                # It's likely to cause an error. Let's return an error early.\r\n                raise ValueError(\"No JIDs provided, but allContacts=False. Please provide at least one status JID.\")\r\n            \r\n            payload[\"statusJidList\"] = jid_list\r\n\r\n        # Log a safe version of the payload\r\n        safe_payload = {**payload}\r\n        if \"statusJidList\" in safe_payload:\r\n            safe_payload[\"statusJidList\"] = [\"***hidden***\"]\r\n        self.log(f\"Built payload: {json.dumps(safe_payload, indent=2)}\")\r\n\r\n        return payload\r\n\r\n    def send_status(self) -> Data:\r\n        \"\"\"\r\n        Send a status message via Evolution API.\r\n        \"\"\"\r\n        try:\r\n            url = f\"{self.base_url}/message/sendStatus/{self.instance_id}\"\r\n            self.log(f\"Full API endpoint URL: {url}\")\r\n\r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n                \"Content-Type\": \"application/json\"\r\n            }\r\n            self.log(\"Headers prepared (apikey hidden)\")\r\n\r\n            # Build payload\r\n            payload = self.build_payload()\r\n\r\n            # Log the request (excluding sensitive data)\r\n            request_info = {\r\n                \"url\": url,\r\n                \"headers\": {\r\n                    \"Content-Type\": \"application/json\",\r\n                    \"apikey\": \"***hidden***\"\r\n                },\r\n                \"payload\": payload.copy()\r\n            }\r\n            if \"statusJidList\" in request_info[\"payload\"]:\r\n                request_info[\"payload\"][\"statusJidList\"] = [\"***hidden***\"]\r\n            self.log(f\"Making request: {json.dumps(request_info, indent=2)}\")\r\n\r\n            # Make API request\r\n            response = requests.post(url, headers=headers, data=json.dumps(payload))\r\n            self.log(f\"Response status code: {response.status_code}\")\r\n\r\n            # Check for HTTP errors\r\n            response.raise_for_status()\r\n\r\n            data = response.json()\r\n\r\n            processed_response = {\r\n                \"key\": data.get(\"key\", {}),\r\n                \"pushName\": data.get(\"pushName\", \"\"),\r\n                \"status\": data.get(\"status\"),\r\n                \"message\": data.get(\"message\", {}),\r\n                \"contextInfo\": data.get(\"contextInfo\"),\r\n                \"messageType\": data.get(\"messageType\"),\r\n                \"messageTimestamp\": data.get(\"messageTimestamp\"),\r\n                \"instanceId\": data.get(\"instanceId\"),\r\n                \"source\": data.get(\"source\")\r\n            }\r\n\r\n            self.log(\"Status sent successfully.\")\r\n            self.log(f\"Message status: {processed_response.get('status')}\")\r\n\r\n            return Data(data=processed_response)\r\n\r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"API request failed: {str(e)}\"\r\n            self.log(f\"Request error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })\r\n        except ValueError as e:\r\n            # Handle known logical errors (like missing JIDs)\r\n            error_msg = f\"Input error: {str(e)}\"\r\n            self.log(error_msg)\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Unexpected error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })\r\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"content":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"content","value":"https://upload.wikimedia.org/wikiversity/en/f/f6/Happy-place.jpg","display_name":"Content","advanced":false,"input_types":["Message"],"dynamic":false,"info":"For text: message text. For image/audio: URL of the file.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"font":{"tool_mode":false,"trace_as_metadata":true,"options":["1","2","3","4","5"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"font","value":"1","display_name":"Font","advanced":false,"dynamic":false,"info":"Font style for text status (1 to 5). Used only for text.","title_case":false,"type":"str","_input_type":"DropdownInput"},"instance_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"felipe8888","display_name":"Instance ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"MessageTextInput"},"status_jid_list":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":true,"required":false,"placeholder":"","show":true,"name":"status_jid_list","value":["5511986780008@s.whatsapp.net"],"display_name":"Status JID List","advanced":false,"input_types":["Message"],"dynamic":false,"info":"List of WhatsApp IDs to send status to (comma-separated if multiple)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"type":{"tool_mode":false,"trace_as_metadata":true,"options":["text","image","audio"],"combobox":false,"required":true,"placeholder":"","show":true,"name":"type","value":"image","display_name":"Status Type","advanced":false,"dynamic":false,"info":"Type of status to send (text, image, or audio)","title_case":false,"type":"str","_input_type":"DropdownInput"}},"description":"Send a status message using Evolution API","icon":"message-circle","base_classes":["Data"],"display_name":"Evolution Send Status","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"message","display_name":"Message","method":"send_status","value":"__UNDEFINED__","cache":true}],"field_order":["base_url","api_key","instance_id","type","content","caption","background_color","font","all_contacts","status_jid_list"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1"},"type":"CustomComponent","id":"CustomComponent-NqNlm"},"selected":false,"measured":{"width":320,"height":965},"dragging":false},{"id":"CustomComponent-P2XtV","type":"genericNode","position":{"x":-2311.8817714519046,"y":-459.210975436518},"data":{"node":{"template":{"_type":"Component","api_key":{"load_from_db":false,"required":true,"placeholder":"","show":true,"name":"api_key","value":null,"display_name":"API Key","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API key for authentication","title_case":false,"password":true,"type":"str","_input_type":"SecretStrInput"},"base_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"base_url","value":"","display_name":"API Base URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API base URL (e.g., http://example.com:8080)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"caption":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"caption","value":"olha isso","display_name":"Caption","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Optional caption for the media","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Dict, Any, Optional\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    SecretStrInput,\r\n    DropdownInput,\r\n    IntInput,\r\n    BoolInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass SendMediaMessageComponent(Component):\r\n    display_name = \"Evolution Send Media\"\r\n    description = \"Send a media message (image, video, document) using Evolution API\"\r\n    icon = \"image\"\r\n    name = \"send_media_message\"\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"quoted_message_id\",\r\n            display_name=\"Quoted Message ID\",\r\n            info=\"ID of the message to quote (optional)\",\r\n            advanced=True,\r\n            required=False,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"base_url\",\r\n            display_name=\"API Base URL\",\r\n            info=\"Evolution API base URL (e.g., http://example.com:8080)\",\r\n            required=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"api_key\",\r\n            display_name=\"API Key\",\r\n            info=\"Evolution API key for authentication\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"number\",\r\n            display_name=\"Recipient Number\",\r\n            info=\"WhatsApp ID of the recipient (e.g., 5511999999999@s.whatsapp.net)\",\r\n            required=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"mediatype\",\r\n            display_name=\"Media Type\",\r\n            info=\"Type of media to send\",\r\n            options=[\"image\", \"video\", \"document\"],\r\n            value=\"image\",\r\n        ),\r\n        MessageTextInput(\r\n            name=\"media\",\r\n            display_name=\"Media URL/Base64\",\r\n            info=\"URL or base64 encoded media content\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"mimetype\",\r\n            display_name=\"MIME Type\",\r\n            info=\"MIME type of the media (e.g., image/png, video/mp4)\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"caption\",\r\n            display_name=\"Caption\",\r\n            info=\"Optional caption for the media\",\r\n            required=False,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"file_name\",\r\n            display_name=\"File Name\",\r\n            info=\"Name of the file\",\r\n            required=True,\r\n        ),\r\n        # Advanced options\r\n        IntInput(\r\n            name=\"delay\",\r\n            display_name=\"Delay\",\r\n            info=\"Optional delay in milliseconds\",\r\n            advanced=True,\r\n        ),\r\n        BoolInput(\r\n            name=\"mentions_everyone\",\r\n            display_name=\"Mention Everyone\",\r\n            info=\"Whether to mention all participants\",\r\n            advanced=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"mentioned\",\r\n            display_name=\"Mentioned Numbers\",\r\n            info=\"List of WhatsApp IDs to mention (comma-separated)\",\r\n            advanced=True,\r\n            is_list=True,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"message\",\r\n            display_name=\"Message\",\r\n            method=\"send_media\",\r\n        ),\r\n    ]\r\n\r\n    def build_payload(self) -> Dict[str, Any]:\r\n        \"\"\"Build the request payload.\"\"\"\r\n        payload = {\r\n            \"number\": self.number,\r\n            \"mediatype\": self.mediatype,\r\n            \"mimetype\": self.mimetype,\r\n            \"media\": self.media,\r\n            \"fileName\": self.file_name,\r\n        }\r\n        \r\n        # Add optional fields if provided\r\n        if hasattr(self, 'caption') and self.caption:\r\n            payload[\"caption\"] = self.caption\r\n            \r\n        if hasattr(self, 'delay') and self.delay:\r\n            payload[\"delay\"] = self.delay\r\n            \r\n        if hasattr(self, 'mentions_everyone'):\r\n            payload[\"mentionsEveryOne\"] = self.mentions_everyone\r\n            \r\n        if hasattr(self, 'mentioned') and self.mentioned:\r\n            payload[\"mentioned\"] = self.mentioned\r\n\r\n        # Add quoted message if ID is provided\r\n        if hasattr(self, 'quoted_message_id') and self.quoted_message_id:\r\n            payload[\"quoted\"] = {\r\n                \"key\": {\r\n                    \"id\": self.quoted_message_id\r\n                }\r\n            }\r\n        \r\n        # Log payload (excluding sensitive data)\r\n        safe_payload = {**payload}\r\n        safe_payload[\"number\"] = \"***hidden***\"\r\n        self.log(f\"Built payload: {json.dumps(safe_payload, indent=2)}\")\r\n        \r\n        return payload\r\n\r\n    def send_media(self) -> Data:\r\n        \"\"\"\r\n        Send a media message via Evolution API.\r\n        \"\"\"\r\n        try:\r\n            # Ensure base URL format\r\n            base_url = self.base_url.rstrip('/')\r\n            self.log(f\"Using base URL: {base_url}\")\r\n            \r\n            # Build API endpoint URL\r\n            url = f\"{base_url}/message/sendMedia/{self.instance_id}\"\r\n            self.log(f\"Full API endpoint URL: {url}\")\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n                \"Content-Type\": \"application/json\"\r\n            }\r\n            self.log(\"Headers prepared (apikey hidden)\")\r\n\r\n            # Build payload\r\n            payload = self.build_payload()\r\n            \r\n            # Log the complete request (excluding sensitive data)\r\n            request_info = {\r\n                \"url\": url,\r\n                \"headers\": {\r\n                    \"Content-Type\": \"application/json\",\r\n                    \"apikey\": \"***hidden***\"\r\n                },\r\n                \"payload\": {\r\n                    \"number\": \"***hidden***\",\r\n                    \"mediatype\": payload[\"mediatype\"],\r\n                    \"mimetype\": payload[\"mimetype\"],\r\n                    \"fileName\": payload[\"fileName\"],\r\n                }\r\n            }\r\n            self.log(f\"Making request: {json.dumps(request_info, indent=2)}\")\r\n\r\n            # Make API request\r\n            response = requests.post(\r\n                url, \r\n                headers=headers, \r\n                json=payload\r\n            )\r\n            \r\n            self.log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Check for successful response\r\n            response.raise_for_status()\r\n            \r\n            # Parse response\r\n            data = response.json()\r\n            \r\n            # Process response into consistent format\r\n            processed_response = {\r\n                \"key\": data.get(\"key\", {}),\r\n                \"pushName\": data.get(\"pushName\", \"\"),\r\n                \"status\": data.get(\"status\"),\r\n                \"message\": data.get(\"message\", {}),\r\n                \"contextInfo\": data.get(\"contextInfo\"),\r\n                \"messageType\": data.get(\"messageType\"),\r\n                \"messageTimestamp\": data.get(\"messageTimestamp\"),\r\n                \"instanceId\": data.get(\"instanceId\"),\r\n                \"source\": data.get(\"source\")\r\n            }\r\n            \r\n            self.log(\"Media message sent successfully\")\r\n            self.log(f\"Message status: {processed_response.get('status')}\")\r\n            \r\n            return Data(data=processed_response)\r\n\r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"API request failed: {str(e)}\"\r\n            self.log(f\"Request error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Unexpected error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"delay":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"delay","value":"","display_name":"Delay","advanced":true,"dynamic":false,"info":"Optional delay in milliseconds","title_case":false,"type":"int","_input_type":"IntInput"},"file_name":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"file_name","value":"image.png","display_name":"File Name","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Name of the file","title_case":false,"type":"str","_input_type":"MessageTextInput"},"instance_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"felipe8888","display_name":"Instance ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"MessageTextInput"},"media":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"media","value":"https://upload.wikimedia.org/wikiversity/en/f/f6/Happy-place.jpg","display_name":"Media URL/Base64","advanced":false,"input_types":["Message"],"dynamic":false,"info":"URL or base64 encoded media content","title_case":false,"type":"str","_input_type":"MessageTextInput"},"mediatype":{"tool_mode":false,"trace_as_metadata":true,"options":["image","video","document"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"mediatype","value":"image","display_name":"Media Type","advanced":false,"dynamic":false,"info":"Type of media to send","title_case":false,"type":"str","_input_type":"DropdownInput"},"mentioned":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":true,"required":false,"placeholder":"","show":true,"name":"mentioned","value":"","display_name":"Mentioned Numbers","advanced":true,"input_types":["Message"],"dynamic":false,"info":"List of WhatsApp IDs to mention (comma-separated)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"mentions_everyone":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"mentions_everyone","value":false,"display_name":"Mention Everyone","advanced":true,"dynamic":false,"info":"Whether to mention all participants","title_case":false,"type":"bool","_input_type":"BoolInput"},"mimetype":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"mimetype","value":"image/png","display_name":"MIME Type","advanced":false,"input_types":["Message"],"dynamic":false,"info":"MIME type of the media (e.g., image/png, video/mp4)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"number":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"number","value":"5511986780008@s.whatsapp.net","display_name":"Recipient Number","advanced":false,"input_types":["Message"],"dynamic":false,"info":"WhatsApp ID of the recipient (e.g., 5511999999999@s.whatsapp.net)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"quoted_message_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"quoted_message_id","value":"3FA7AC88D2BC43904345","display_name":"Quoted Message ID","advanced":true,"input_types":["Message"],"dynamic":false,"info":"ID of the message to quote (optional)","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Send a media message (image, video, document) using Evolution API","icon":"image","base_classes":["Data"],"display_name":"Evolution Send Media","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"message","display_name":"Message","method":"send_media","value":"__UNDEFINED__","cache":true}],"field_order":["quoted_message_id","base_url","api_key","instance_id","number","mediatype","media","mimetype","caption","file_name","delay","mentions_everyone","mentioned"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1"},"type":"CustomComponent","id":"CustomComponent-P2XtV"},"selected":false,"measured":{"width":320,"height":939},"dragging":false},{"id":"CustomComponent-7eHds","type":"genericNode","position":{"x":-1945.533162670405,"y":-454.38621731371325},"data":{"node":{"template":{"_type":"Component","api_key":{"load_from_db":false,"required":true,"placeholder":"","show":true,"name":"api_key","value":null,"display_name":"API Key","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API key for authentication","title_case":false,"password":true,"type":"str","_input_type":"SecretStrInput"},"audio":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"audio","value":"https://tuningmania.com.br/autosom/mp3/left%20and%20right%20channel%20verification.mp3","display_name":"Audio URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"URL of the audio file to send","title_case":false,"type":"str","_input_type":"MessageTextInput"},"base_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"base_url","value":"","display_name":"API Base URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API base URL (e.g., http://example.com:8080)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Dict, Any\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    SecretStrInput,\r\n    IntInput,\r\n    BoolInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass SendAudioMessageComponent(Component):\r\n    display_name = \"Evolution Send Audio Message\"\r\n    description = \"Send an audio message using Evolution API with recording simulation\"\r\n    icon = \"mic\"\r\n    name = \"send_audio_message\"\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"base_url\",\r\n            display_name=\"API Base URL\",\r\n            info=\"Evolution API base URL (e.g., http://example.com:8080)\",\r\n            required=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"api_key\",\r\n            display_name=\"API Key\",\r\n            info=\"Evolution API key for authentication\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"number\",\r\n            display_name=\"Recipient Number\",\r\n            info=\"WhatsApp ID of the recipient (e.g., 5511999999999@s.whatsapp.net)\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"audio\",\r\n            display_name=\"Audio URL\",\r\n            info=\"URL of the audio file to send\",\r\n            required=True,\r\n        ),\r\n        # Advanced options\r\n        BoolInput(\r\n            name=\"show_recording\",\r\n            display_name=\"Show Recording\",\r\n            info=\"Show recording indicator before sending audio\",\r\n            advanced=True,\r\n        ),\r\n        IntInput(\r\n            name=\"recording_delay\",\r\n            display_name=\"Recording Delay\",\r\n            info=\"How long to show recording indicator (in milliseconds)\",\r\n            advanced=True,\r\n            value=3000,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"message\",\r\n            display_name=\"Message\",\r\n            method=\"send_audio\",\r\n        ),\r\n    ]\r\n\r\n    def send_presence(self) -> None:\r\n        \"\"\"Send recording presence indicator.\"\"\"\r\n        try:\r\n            base_url = self.base_url.rstrip('/')\r\n            url = f\"{base_url}/chat/sendPresence/{self.instance_id}\"\r\n            \r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n                \"Content-Type\": \"application/json\"\r\n            }\r\n            \r\n            payload = {\r\n                \"number\": self.number,\r\n                \"delay\": self.recording_delay,\r\n                \"presence\": \"recording\"\r\n            }\r\n            \r\n            self.log(\"Sending recording presence indicator...\")\r\n            response = requests.post(url, headers=headers, json=payload)\r\n            response.raise_for_status()\r\n            self.log(\"Recording indicator sent successfully\")\r\n            \r\n        except Exception as e:\r\n            self.log(f\"Error sending recording presence: {str(e)}\")\r\n\r\n    def build_payload(self) -> Dict[str, Any]:\r\n        \"\"\"Build the request payload.\"\"\"\r\n        payload = {\r\n            \"number\": self.number,\r\n            \"audio\": self.audio\r\n        }\r\n        \r\n        # Log payload (excluding sensitive data)\r\n        safe_payload = {**payload}\r\n        safe_payload[\"number\"] = \"***hidden***\"\r\n        self.log(f\"Built payload: {json.dumps(safe_payload, indent=2)}\")\r\n        \r\n        return payload\r\n\r\n    def send_audio(self) -> Data:\r\n        \"\"\"\r\n        Send an audio message via Evolution API.\r\n        \"\"\"\r\n        try:\r\n            # Ensure base URL format\r\n            base_url = self.base_url.rstrip('/')\r\n            self.log(f\"Using base URL: {base_url}\")\r\n            \r\n            # Send recording presence if enabled\r\n            if hasattr(self, 'show_recording') and self.show_recording:\r\n                self.send_presence()\r\n            \r\n            # Build API endpoint URL\r\n            url = f\"{base_url}/message/sendWhatsAppAudio/{self.instance_id}\"\r\n            self.log(f\"Full API endpoint URL: {url}\")\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n                \"Content-Type\": \"application/json\"\r\n            }\r\n            self.log(\"Headers prepared (apikey hidden)\")\r\n\r\n            # Build payload\r\n            payload = self.build_payload()\r\n            \r\n            # Log the complete request (excluding sensitive data)\r\n            request_info = {\r\n                \"url\": url,\r\n                \"headers\": {\r\n                    \"Content-Type\": \"application/json\",\r\n                    \"apikey\": \"***hidden***\"\r\n                },\r\n                \"payload\": {\r\n                    \"number\": \"***hidden***\",\r\n                    \"audio\": payload[\"audio\"]\r\n                }\r\n            }\r\n            self.log(f\"Making request: {json.dumps(request_info, indent=2)}\")\r\n\r\n            # Make API request\r\n            response = requests.post(\r\n                url, \r\n                headers=headers, \r\n                data=json.dumps(payload)\r\n            )\r\n            \r\n            self.log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Check for successful response\r\n            response.raise_for_status()\r\n            \r\n            # Parse response\r\n            data = response.json()\r\n            \r\n            # Process response into consistent format\r\n            processed_response = {\r\n                \"key\": data.get(\"key\", {}),\r\n                \"pushName\": data.get(\"pushName\", \"\"),\r\n                \"status\": data.get(\"status\"),\r\n                \"message\": data.get(\"message\", {}),\r\n                \"contextInfo\": data.get(\"contextInfo\"),\r\n                \"messageType\": data.get(\"messageType\"),\r\n                \"messageTimestamp\": data.get(\"messageTimestamp\"),\r\n                \"instanceId\": data.get(\"instanceId\"),\r\n                \"source\": data.get(\"source\")\r\n            }\r\n            \r\n            self.log(\"Audio message sent successfully\")\r\n            self.log(f\"Message status: {processed_response.get('status')}\")\r\n            \r\n            return Data(data=processed_response)\r\n\r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"API request failed: {str(e)}\"\r\n            self.log(f\"Request error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Unexpected error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"instance_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"felipe8888","display_name":"Instance ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"MessageTextInput"},"number":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"number","value":"5511986780008@s.whatsapp.net","display_name":"Recipient Number","advanced":false,"input_types":["Message"],"dynamic":false,"info":"WhatsApp ID of the recipient (e.g., 5511999999999@s.whatsapp.net)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"recording_delay":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"recording_delay","value":3000,"display_name":"Recording Delay","advanced":false,"dynamic":false,"info":"How long to show recording indicator (in milliseconds)","title_case":false,"type":"int","_input_type":"IntInput"},"show_recording":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"show_recording","value":true,"display_name":"Show Recording","advanced":false,"dynamic":false,"info":"Show recording indicator before sending audio","title_case":false,"type":"bool","_input_type":"BoolInput"}},"description":"Send an audio message using Evolution API with recording simulation","icon":"mic","base_classes":["Data"],"display_name":"Evolution Send Audio Message","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"message","display_name":"Message","method":"send_audio","value":"__UNDEFINED__","cache":true}],"field_order":["base_url","api_key","instance_id","number","audio","show_recording","recording_delay"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1"},"type":"CustomComponent","id":"CustomComponent-7eHds"},"selected":false,"measured":{"width":320,"height":728},"dragging":false},{"id":"CustomComponent-J0x3i","type":"genericNode","position":{"x":-1563.0191190394874,"y":-425.14831532890116},"data":{"node":{"template":{"_type":"Component","api_key":{"load_from_db":false,"required":true,"placeholder":"","show":true,"name":"api_key","value":null,"display_name":"API Key","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API key for authentication","title_case":false,"password":true,"type":"str","_input_type":"SecretStrInput"},"base_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"base_url","value":"","display_name":"API Base URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API base URL (e.g., http://example.com:8080)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Dict, Any\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    SecretStrInput,\r\n    IntInput,\r\n    BoolInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass SendStickerComponent(Component):\r\n    display_name = \"Evolution Send Sticker\"\r\n    description = \"Send a sticker message using Evolution API\"\r\n    icon = \"sticker\"\r\n    name = \"send_sticker\"\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"base_url\",\r\n            display_name=\"API Base URL\",\r\n            info=\"Evolution API base URL (e.g., http://example.com:8080)\",\r\n            required=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"api_key\",\r\n            display_name=\"API Key\",\r\n            info=\"Evolution API key for authentication\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"number\",\r\n            display_name=\"Recipient Number\",\r\n            info=\"WhatsApp ID of the recipient (e.g., 5511999999999@s.whatsapp.net)\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"sticker\",\r\n            display_name=\"Sticker URL\",\r\n            info=\"URL or base64 of the sticker to send\",\r\n            required=True,\r\n        ),\r\n        # Advanced options\r\n        MessageTextInput(\r\n            name=\"quoted_message_id\",\r\n            display_name=\"Quoted Message ID\",\r\n            info=\"ID of the message to quote (optional)\",\r\n            advanced=True,\r\n            required=False,\r\n        ),\r\n        IntInput(\r\n            name=\"delay\",\r\n            display_name=\"Delay\",\r\n            info=\"Optional delay in milliseconds\",\r\n            advanced=True,\r\n        ),\r\n        BoolInput(\r\n            name=\"mentions_everyone\",\r\n            display_name=\"Mention Everyone\",\r\n            info=\"Whether to mention all participants\",\r\n            advanced=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"mentioned\",\r\n            display_name=\"Mentioned Numbers\",\r\n            info=\"List of WhatsApp IDs to mention (comma-separated)\",\r\n            advanced=True,\r\n            is_list=True,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"message\",\r\n            display_name=\"Message\",\r\n            method=\"send_sticker\",\r\n        ),\r\n    ]\r\n\r\n    def build_payload(self) -> Dict[str, Any]:\r\n        \"\"\"Build the request payload.\"\"\"\r\n        payload = {\r\n            \"number\": self.number,\r\n            \"sticker\": self.sticker\r\n        }\r\n        \r\n        # Add optional fields if provided\r\n        if hasattr(self, 'delay') and self.delay:\r\n            payload[\"delay\"] = self.delay\r\n            \r\n        if hasattr(self, 'mentions_everyone'):\r\n            payload[\"mentionsEveryOne\"] = self.mentions_everyone\r\n            \r\n        if hasattr(self, 'mentioned') and self.mentioned:\r\n            payload[\"mentioned\"] = self.mentioned\r\n\r\n        # Add quoted message if ID is provided\r\n        if hasattr(self, 'quoted_message_id') and self.quoted_message_id:\r\n            payload[\"quoted\"] = {\r\n                \"key\": {\r\n                    \"id\": self.quoted_message_id\r\n                }\r\n            }\r\n        \r\n        # Log payload (excluding sensitive data)\r\n        safe_payload = {**payload}\r\n        safe_payload[\"number\"] = \"***hidden***\"\r\n        self.log(f\"Built payload: {json.dumps(safe_payload, indent=2)}\")\r\n        \r\n        return payload\r\n\r\n    def send_sticker(self) -> Data:\r\n        \"\"\"\r\n        Send a sticker via Evolution API.\r\n        \"\"\"\r\n        try:\r\n            # Ensure base URL format\r\n            base_url = self.base_url.rstrip('/')\r\n            self.log(f\"Using base URL: {base_url}\")\r\n            \r\n            # Build API endpoint URL\r\n            url = f\"{base_url}/message/sendSticker/{self.instance_id}\"\r\n            self.log(f\"Full API endpoint URL: {url}\")\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n                \"Content-Type\": \"application/json\"\r\n            }\r\n            self.log(\"Headers prepared (apikey hidden)\")\r\n\r\n            # Build payload\r\n            payload = self.build_payload()\r\n            \r\n            # Log the complete request (excluding sensitive data)\r\n            request_info = {\r\n                \"url\": url,\r\n                \"headers\": {\r\n                    \"Content-Type\": \"application/json\",\r\n                    \"apikey\": \"***hidden***\"\r\n                },\r\n                \"payload\": {\r\n                    \"number\": \"***hidden***\",\r\n                    \"sticker\": payload[\"sticker\"]\r\n                }\r\n            }\r\n            self.log(f\"Making request: {json.dumps(request_info, indent=2)}\")\r\n\r\n            # Make API request\r\n            response = requests.post(\r\n                url, \r\n                headers=headers, \r\n                data=json.dumps(payload)\r\n            )\r\n            \r\n            self.log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Check for successful response\r\n            response.raise_for_status()\r\n            \r\n            # Parse response\r\n            data = response.json()\r\n            \r\n            # Process response into consistent format\r\n            processed_response = {\r\n                \"key\": data.get(\"key\", {}),\r\n                \"pushName\": data.get(\"pushName\", \"\"),\r\n                \"status\": data.get(\"status\"),\r\n                \"message\": data.get(\"message\", {}),\r\n                \"contextInfo\": data.get(\"contextInfo\"),\r\n                \"messageType\": data.get(\"messageType\"),\r\n                \"messageTimestamp\": data.get(\"messageTimestamp\"),\r\n                \"instanceId\": data.get(\"instanceId\"),\r\n                \"source\": data.get(\"source\")\r\n            }\r\n            \r\n            self.log(\"Sticker sent successfully\")\r\n            self.log(f\"Message status: {processed_response.get('status')}\")\r\n            \r\n            return Data(data=processed_response)\r\n\r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"API request failed: {str(e)}\"\r\n            self.log(f\"Request error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Unexpected error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"delay":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"delay","value":"","display_name":"Delay","advanced":false,"dynamic":false,"info":"Optional delay in milliseconds","title_case":false,"type":"int","_input_type":"IntInput"},"instance_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"felipe8888","display_name":"Instance ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"MessageTextInput"},"mentioned":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":true,"required":false,"placeholder":"","show":true,"name":"mentioned","value":"","display_name":"Mentioned Numbers","advanced":true,"input_types":["Message"],"dynamic":false,"info":"List of WhatsApp IDs to mention (comma-separated)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"mentions_everyone":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"mentions_everyone","value":false,"display_name":"Mention Everyone","advanced":false,"dynamic":false,"info":"Whether to mention all participants","title_case":false,"type":"bool","_input_type":"BoolInput"},"number":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"number","value":"5511986780008@s.whatsapp.net","display_name":"Recipient Number","advanced":false,"input_types":["Message"],"dynamic":false,"info":"WhatsApp ID of the recipient (e.g., 5511999999999@s.whatsapp.net)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"quoted_message_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"quoted_message_id","value":"","display_name":"Quoted Message ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"ID of the message to quote (optional)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"sticker":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"sticker","value":"https://upload.wikimedia.org/wikiversity/en/f/f6/Happy-place.jpg","display_name":"Sticker URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"URL or base64 of the sticker to send","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Send a sticker message using Evolution API","icon":"sticker","base_classes":["Data"],"display_name":"Evolution Send Sticker","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"message","display_name":"Message","method":"send_sticker","value":"__UNDEFINED__","cache":true}],"field_order":["base_url","api_key","instance_id","number","sticker","quoted_message_id","delay","mentions_everyone","mentioned"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1"},"type":"CustomComponent","id":"CustomComponent-J0x3i"},"selected":false,"measured":{"width":320,"height":794},"dragging":false},{"id":"CustomComponent-oASu1","type":"genericNode","position":{"x":-1161.7582449238382,"y":-366.8917970376212},"data":{"node":{"template":{"_type":"Component","address":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"address","value":"French Polynesian","display_name":"Address","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Address of the location","title_case":false,"type":"str","_input_type":"MessageTextInput"},"api_key":{"load_from_db":false,"required":true,"placeholder":"","show":true,"name":"api_key","value":null,"display_name":"API Key","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API key for authentication","title_case":false,"password":true,"type":"str","_input_type":"SecretStrInput"},"base_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"base_url","value":"","display_name":"API Base URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API base URL (e.g., http://example.com:8080)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Dict, Any\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    SecretStrInput,\r\n    IntInput,\r\n    BoolInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass SendLocationComponent(Component):\r\n    display_name = \"Send WhatsApp Location\"\r\n    description = \"Send a WhatsApp location message with name and address using Evolution API\"\r\n    icon = \"map-pin\"\r\n    name = \"evolution_send_location\"\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"base_url\",\r\n            display_name=\"API Base URL\", \r\n            info=\"Evolution API base URL (e.g., http://example.com:8080)\",\r\n            required=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"api_key\",\r\n            display_name=\"API Key\",\r\n            info=\"Evolution API key for authentication\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"number\",\r\n            display_name=\"Recipient Number\",\r\n            info=\"WhatsApp ID of the recipient (e.g., 5511999999999@s.whatsapp.net)\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"location_name\",\r\n            display_name=\"Location Name\",\r\n            info=\"Name of the location\",\r\n            required=False,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"address\",\r\n            display_name=\"Address\",\r\n            info=\"Address of the location\",\r\n            required=False,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"latitude\",\r\n            display_name=\"Latitude\",\r\n            info=\"Latitude coordinate (e.g., -16.505538233564373)\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"longitude\",\r\n            display_name=\"Longitude\",\r\n            info=\"Longitude coordinate (e.g., -151.7422770494996)\",\r\n            required=True,\r\n        ),\r\n        # Advanced options\r\n        MessageTextInput(\r\n            name=\"quoted_message_id\",\r\n            display_name=\"Quoted Message ID\",\r\n            info=\"ID of the message to quote (optional)\",\r\n            advanced=True,\r\n            required=False,\r\n        ),\r\n        IntInput(\r\n            name=\"delay\",\r\n            display_name=\"Delay\",\r\n            info=\"Optional delay in milliseconds\",\r\n            advanced=True,\r\n        ),\r\n        BoolInput(\r\n            name=\"mentions_everyone\",\r\n            display_name=\"Mention Everyone\",\r\n            info=\"Whether to mention all participants\",\r\n            advanced=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"mentioned\",\r\n            display_name=\"Mentioned Numbers\",\r\n            info=\"List of WhatsApp IDs to mention (comma-separated)\",\r\n            advanced=True,\r\n            is_list=True,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"message\",\r\n            display_name=\"Message\",\r\n            method=\"sendLocation\",\r\n        ),\r\n    ]\r\n\r\n    def build_payload(self) -> Dict[str, Any]:\r\n        \"\"\"Build the request payload.\"\"\"\r\n        # Convert latitude and longitude to float\r\n        try:\r\n            latitude = float(self.latitude)\r\n            longitude = float(self.longitude)\r\n        except ValueError as e:\r\n            raise ValueError(\"Latitude and longitude must be valid numbers\") from e\r\n        \r\n        payload = {\r\n            \"number\": self.number,\r\n            \"latitude\": latitude,\r\n            \"longitude\": longitude\r\n        }\r\n        \r\n        # Add optional fields if provided\r\n        if hasattr(self, 'location_name') and self.location_name:\r\n            payload[\"name\"] = self.location_name\r\n            \r\n        if hasattr(self, 'address') and self.address:\r\n            payload[\"address\"] = self.address\r\n            \r\n        if hasattr(self, 'delay') and self.delay:\r\n            payload[\"delay\"] = self.delay\r\n            \r\n        if hasattr(self, 'mentions_everyone'):\r\n            payload[\"mentionsEveryOne\"] = self.mentions_everyone\r\n            \r\n        if hasattr(self, 'mentioned') and self.mentioned:\r\n            payload[\"mentioned\"] = self.mentioned\r\n\r\n        # Add quoted message if ID is provided\r\n        if hasattr(self, 'quoted_message_id') and self.quoted_message_id:\r\n            payload[\"quoted\"] = {\r\n                \"key\": {\r\n                    \"id\": self.quoted_message_id\r\n                }\r\n            }\r\n        \r\n        # Log payload (excluding sensitive data)\r\n        safe_payload = {**payload}\r\n        safe_payload[\"number\"] = \"***hidden***\"\r\n        self.log(f\"Built payload: {json.dumps(safe_payload, indent=2)}\")\r\n        \r\n        return payload\r\n\r\n    def sendLocation(self) -> Data:\r\n        \"\"\"\r\n        Send a location message via Evolution API.\r\n        \"\"\"\r\n        try:\r\n            # Ensure base URL format\r\n            base_url = self.base_url.rstrip('/')\r\n            self.log(f\"Using base URL: {base_url}\")\r\n            \r\n            # Build API endpoint URL\r\n            url = f\"{base_url}/message/sendLocation/{self.instance_id}\"\r\n            self.log(f\"Full API endpoint URL: {url}\")\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n                \"Content-Type\": \"application/json\"\r\n            }\r\n            self.log(\"Headers prepared (apikey hidden)\")\r\n\r\n            # Build payload\r\n            payload = self.build_payload()\r\n            \r\n            # Log the complete request (excluding sensitive data)\r\n            request_info = {\r\n                \"url\": url,\r\n                \"headers\": {\r\n                    \"Content-Type\": \"application/json\",\r\n                    \"apikey\": \"***hidden***\"\r\n                },\r\n                \"payload\": {\r\n                    \"number\": \"***hidden***\",\r\n                    \"latitude\": payload[\"latitude\"],\r\n                    \"longitude\": payload[\"longitude\"],\r\n                    \"name\": payload.get(\"name\", \"\"),\r\n                    \"address\": payload.get(\"address\", \"\")\r\n                }\r\n            }\r\n            self.log(f\"Making request: {json.dumps(request_info, indent=2)}\")\r\n\r\n            # Make API request\r\n            response = requests.post(\r\n                url, \r\n                headers=headers, \r\n                json=payload  # Changed from data=json.dumps(payload)\r\n            )\r\n            \r\n            self.log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Check for successful response\r\n            response.raise_for_status()\r\n            \r\n            # Parse response\r\n            data = response.json()\r\n            \r\n            # Return the API response directly without processing\r\n            self.log(f\"Raw API response: {json.dumps(data, indent=2)}\")\r\n            return Data(data=data)\r\n            \r\n            location_name = payload.get(\"name\", \"unnamed location\")\r\n            self.log(f\"Location '{location_name}' message sent successfully\")\r\n            self.log(f\"Message status: {processed_response.get('status')}\")\r\n            \r\n            return Data(data=processed_response)\r\n\r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"API request failed: {str(e)}\"\r\n            self.log(f\"Request error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Unexpected error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"delay":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"delay","value":"","display_name":"Delay","advanced":true,"dynamic":false,"info":"Optional delay in milliseconds","title_case":false,"type":"int","_input_type":"IntInput"},"instance_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"felipe8888","display_name":"Instance ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"MessageTextInput"},"latitude":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"latitude","value":"-16.505538233564373","display_name":"Latitude","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Latitude coordinate (e.g., -16.505538233564373)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"location_name":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"location_name","value":"felipe","display_name":"Location Name","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Name of the location","title_case":false,"type":"str","_input_type":"MessageTextInput"},"longitude":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"longitude","value":"-151.7422770494996","display_name":"Longitude","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Longitude coordinate (e.g., -151.7422770494996)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"mentioned":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":true,"required":false,"placeholder":"","show":true,"name":"mentioned","value":"","display_name":"Mentioned Numbers","advanced":true,"input_types":["Message"],"dynamic":false,"info":"List of WhatsApp IDs to mention (comma-separated)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"mentions_everyone":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"mentions_everyone","value":false,"display_name":"Mention Everyone","advanced":true,"dynamic":false,"info":"Whether to mention all participants","title_case":false,"type":"bool","_input_type":"BoolInput"},"number":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"number","value":"5511986780008@s.whatsapp.net","display_name":"Recipient Number","advanced":false,"input_types":["Message"],"dynamic":false,"info":"WhatsApp ID of the recipient (e.g., 5511999999999@s.whatsapp.net)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"quoted_message_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"quoted_message_id","value":"","display_name":"Quoted Message ID","advanced":true,"input_types":["Message"],"dynamic":false,"info":"ID of the message to quote (optional)","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Send a WhatsApp location message with name and address using Evolution API","icon":"map-pin","base_classes":["Data"],"display_name":"Send WhatsApp Location","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"message","display_name":"Message","method":"sendLocation","value":"__UNDEFINED__","cache":true}],"field_order":["base_url","api_key","instance_id","number","location_name","address","latitude","longitude","quoted_message_id","delay","mentions_everyone","mentioned"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1"},"type":"CustomComponent","id":"CustomComponent-oASu1"},"selected":false,"measured":{"width":320,"height":854},"dragging":false},{"id":"CustomComponent-SE3RE","type":"genericNode","position":{"x":-3059.6377994907484,"y":-185.6383343808547},"data":{"node":{"template":{"_type":"Component","api_key":{"load_from_db":false,"required":true,"placeholder":"","show":true,"name":"api_key","value":null,"display_name":"API Key","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API key for authentication","title_case":false,"password":true,"type":"str","_input_type":"SecretStrInput"},"base_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"base_url","value":"","display_name":"API Base URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API base URL (e.g., http://example.com:8080)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nimport re\r\nfrom typing import Dict, Any, Tuple\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    SecretStrInput,\r\n    TableInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass SendContactComponent(Component):\r\n    display_name = \"Evolution Send Contact\"\r\n    description = \"Send one or more contact cards using Evolution API\"\r\n    icon = \"contact\"\r\n    name = \"send_contact\"\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"base_url\",\r\n            display_name=\"API Base URL\",\r\n            info=\"Evolution API base URL (e.g., http://example.com:8080)\",\r\n            required=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"api_key\",\r\n            display_name=\"API Key\",\r\n            info=\"Evolution API key for authentication\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\", \r\n            info=\"Evolution API instance identifier\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"number\",\r\n            display_name=\"Recipient Number\",\r\n            info=\"WhatsApp ID of the recipient (e.g., 5511999999999@s.whatsapp.net)\",\r\n            required=True,\r\n        ),\r\n        TableInput(\r\n            name=\"contacts\",\r\n            display_name=\"Contacts\",\r\n            info=\"List of contacts to send. Phone numbers can be in any format (e.g. +5511999999999, 5511999999999, +55 11 99999-9999)\",\r\n            required=True,\r\n            table_schema=[\r\n                {\r\n                    \"name\": \"fullName\", \r\n                    \"display_name\": \"Full Name\",\r\n                    \"type\": \"str\",\r\n                    \"description\": \"Contact's full name\",\r\n                    \"required\": True,\r\n                },\r\n                {\r\n                    \"name\": \"phone\",\r\n                    \"display_name\": \"Phone\",\r\n                    \"type\": \"str\", \r\n                    \"description\": \"Contact's phone number (will be automatically formatted)\",\r\n                    \"required\": True,\r\n                },\r\n                {\r\n                    \"name\": \"organization\",\r\n                    \"display_name\": \"Organization\",\r\n                    \"type\": \"str\",\r\n                    \"description\": \"Contact's organization/company name\",\r\n                    \"required\": False,\r\n                },\r\n                {\r\n                    \"name\": \"email\",\r\n                    \"display_name\": \"Email\",\r\n                    \"type\": \"str\",\r\n                    \"description\": \"Contact's email address\",\r\n                    \"required\": False,\r\n                },\r\n                {\r\n                    \"name\": \"url\",\r\n                    \"display_name\": \"URL\",\r\n                    \"type\": \"str\",\r\n                    \"description\": \"Contact's website or URL\",\r\n                    \"required\": False,\r\n                }\r\n            ],\r\n            value=[{\r\n                \"fullName\": \"Contact Name\",\r\n                \"phone\": \"+5511999999999\",\r\n                \"organization\": \"Company Name\",\r\n                \"email\": \"email\",\r\n                \"url\": \"url page\"\r\n            }],\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"message\",\r\n            display_name=\"Message\",\r\n            method=\"send_contact\",\r\n        ),\r\n    ]\r\n\r\n    def format_phone_numbers(self, phone: str) -> Tuple[str, str]:\r\n        \"\"\"\r\n        Format phone number into wuid and phoneNumber formats.\r\n        Handles any input format and extracts numbers.\r\n        \r\n        Args:\r\n            phone (str): Phone number in any format\r\n            \r\n        Returns:\r\n            Tuple[str, str]: (wuid, phoneNumber)\r\n        \"\"\"\r\n        # Aggressively remove everything except numbers\r\n        numbers_only = ''.join(filter(str.isdigit, str(phone)))\r\n        \r\n        # Handle different number lengths\r\n        if len(numbers_only) <= 9:  # Just the number without area code or country code\r\n            numbers_only = \"5511\" + numbers_only.zfill(9)\r\n        elif len(numbers_only) == 10 or len(numbers_only) == 11:  # Has area code but no country code\r\n            numbers_only = \"55\" + numbers_only\r\n        elif len(numbers_only) > 13:  # Too long, trim from left to get last 13 digits\r\n            numbers_only = numbers_only[-13:]\r\n        \r\n        # Ensure we have exactly 13 digits (55 + DDD + 9XXXXXXXX)\r\n        if len(numbers_only) < 13:\r\n            numbers_only = numbers_only.zfill(13)\r\n            \r\n        # Format for wuid (just numbers)\r\n        wuid = numbers_only\r\n        \r\n        # Format for phoneNumber (pretty format with country code, area code and number groups)\r\n        formatted = (f\"+{numbers_only[:2]} {numbers_only[2:4]} \"\r\n                    f\"{numbers_only[4:5]} {numbers_only[5:9]}-{numbers_only[9:]}\")\r\n        \r\n        self.log(f\"Formatted number from input: {phone} -> wuid: {wuid}, formatted: {formatted}\")\r\n            \r\n        return wuid, formatted\r\n\r\n    def build_payload(self) -> Dict[str, Any]:\r\n        \"\"\"Build the request payload.\"\"\"\r\n        contact_list = []\r\n        for contact in self.contacts:\r\n            phone = contact.get(\"phone\", \"\")\r\n            wuid, formatted_phone = self.format_phone_numbers(phone)\r\n            \r\n            contact_data = {\r\n                \"fullName\": contact.get(\"fullName\"),\r\n                \"wuid\": wuid,\r\n                \"phoneNumber\": formatted_phone,\r\n                \"organization\": contact.get(\"organization\", \"\"),\r\n                \"email\": contact.get(\"email\", \"\"),\r\n                \"url\": contact.get(\"url\", \"\")\r\n            }\r\n            contact_list.append(contact_data)\r\n        \r\n        payload = {\r\n            \"number\": self.number,\r\n            \"contact\": contact_list\r\n        }\r\n        \r\n        # Log payload (excluding sensitive data)\r\n        safe_payload = {**payload}\r\n        safe_payload[\"number\"] = \"***hidden***\"\r\n        self.log(f\"Built payload: {json.dumps(safe_payload, indent=2)}\")\r\n        \r\n        return payload\r\n\r\n    def send_contact(self) -> Data:\r\n        \"\"\"\r\n        Send contact card(s) via Evolution API.\r\n        \"\"\"\r\n        try:\r\n            # Ensure base URL format\r\n            base_url = self.base_url.rstrip('/')\r\n            self.log(f\"Using base URL: {base_url}\")\r\n            \r\n            # Build API endpoint URL\r\n            url = f\"{base_url}/message/sendContact/{self.instance_id}\"\r\n            self.log(f\"Full API endpoint URL: {url}\")\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n                \"Content-Type\": \"application/json\"\r\n            }\r\n            self.log(\"Headers prepared (apikey hidden)\")\r\n\r\n            # Build payload\r\n            payload = self.build_payload()\r\n            \r\n            # Log the complete request (excluding sensitive data)\r\n            request_info = {\r\n                \"url\": url,\r\n                \"headers\": {\r\n                    \"Content-Type\": \"application/json\",\r\n                    \"apikey\": \"***hidden***\"\r\n                },\r\n                \"payload\": {\r\n                    \"number\": \"***hidden***\",\r\n                    \"contact\": [{\"fullName\": c.get(\"fullName\")} for c in payload[\"contact\"]]\r\n                }\r\n            }\r\n            self.log(f\"Making request: {json.dumps(request_info, indent=2)}\")\r\n\r\n            # Make API request\r\n            response = requests.post(\r\n                url, \r\n                headers=headers, \r\n                json=payload\r\n            )\r\n            \r\n            self.log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Check for successful response\r\n            response.raise_for_status()\r\n            \r\n            # Parse response\r\n            data = response.json()\r\n            \r\n            # Process response into consistent format\r\n            processed_response = {\r\n                \"key\": data.get(\"key\", {}),\r\n                \"pushName\": data.get(\"pushName\", \"\"),\r\n                \"status\": data.get(\"status\"),\r\n                \"message\": data.get(\"message\", {}),\r\n                \"contextInfo\": data.get(\"contextInfo\"),\r\n                \"messageType\": data.get(\"messageType\"),\r\n                \"messageTimestamp\": data.get(\"messageTimestamp\"),\r\n                \"instanceId\": data.get(\"instanceId\"),\r\n                \"source\": data.get(\"source\")\r\n            }\r\n            \r\n            self.log(\"Contact card(s) sent successfully\")\r\n            self.log(f\"Message status: {processed_response.get('status')}\")\r\n            \r\n            return Data(data=processed_response)\r\n\r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"API request failed: {str(e)}\"\r\n            self.log(f\"Request error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Unexpected error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"contacts":{"tool_mode":false,"is_list":true,"table_schema":{"columns":[{"name":"fullName","display_name":"Full Name","sortable":true,"filterable":true,"type":"text","description":"Contact's full name","disable_edit":false,"edit_mode":"modal","formatter":"text"},{"name":"phone","display_name":"Phone","sortable":true,"filterable":true,"type":"text","description":"Contact's phone number (will be automatically formatted)","disable_edit":false,"edit_mode":"modal","formatter":"text"},{"name":"organization","display_name":"Organization","sortable":true,"filterable":true,"type":"text","description":"Contact's organization/company name","disable_edit":false,"edit_mode":"modal","formatter":"text"},{"name":"email","display_name":"Email","sortable":true,"filterable":true,"type":"text","description":"Contact's email address","disable_edit":false,"edit_mode":"modal","formatter":"text"},{"name":"url","display_name":"URL","sortable":true,"filterable":true,"type":"text","description":"Contact's website or URL","disable_edit":false,"edit_mode":"modal","formatter":"text"}]},"trigger_text":"Open table","trigger_icon":"Table","trace_as_metadata":true,"required":true,"placeholder":"","show":true,"name":"contacts","value":[{"fullName":"tio felep\n","wuid":"551199999999","phoneNumber":"+55332232232","organization":"rolagrossacorporation","email":"email@you.com","url":"hehe","phone":"1198678-0008"}],"display_name":"Contacts","advanced":false,"dynamic":false,"info":"List of contacts to send. Phone numbers can be in any format (e.g. +5511999999999, 5511999999999, +55 11 99999-9999)","title_case":false,"type":"table","_input_type":"TableInput","load_from_db":false},"instance_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"felipe8888","display_name":"Instance ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"MessageTextInput"},"number":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"number","value":"5511986780008@s.whatsapp.net","display_name":"Recipient Number","advanced":false,"input_types":["Message"],"dynamic":false,"info":"WhatsApp ID of the recipient (e.g., 5511999999999@s.whatsapp.net)","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Send one or more contact cards using Evolution API","icon":"contact","base_classes":["Data"],"display_name":"Evolution Send Contact","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"message","display_name":"Message","method":"send_contact","value":"__UNDEFINED__","cache":true}],"field_order":["base_url","api_key","instance_id","number","contacts"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1"},"type":"CustomComponent","id":"CustomComponent-SE3RE"},"selected":false,"measured":{"width":320,"height":598},"dragging":false},{"id":"CustomComponent-wLHbG","type":"genericNode","position":{"x":-1776.8869586394396,"y":638.5665162350999},"data":{"node":{"template":{"_type":"Component","api_key":{"load_from_db":false,"required":true,"placeholder":"","show":true,"name":"api_key","value":null,"display_name":"API Key","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API key for authentication","title_case":false,"password":true,"type":"str","_input_type":"SecretStrInput"},"base_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"base_url","value":"","display_name":"API Base URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API base URL (e.g., http://example.com:8080)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Dict, Any\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    SecretStrInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass SendReactionComponent(Component):\r\n    display_name = \"Evolution Send Reaction\"\r\n    description = \"Send a reaction emoji to a specific message using Evolution API\"\r\n    icon = \"smile\"\r\n    name = \"send_reaction\"\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"base_url\",\r\n            display_name=\"API Base URL\",\r\n            info=\"Evolution API base URL (e.g., http://example.com:8080)\",\r\n            required=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"api_key\",\r\n            display_name=\"API Key\",\r\n            info=\"Evolution API key for authentication\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"remote_jid\",\r\n            display_name=\"Chat ID\",\r\n            info=\"WhatsApp chat ID (e.g., 5511999999999@s.whatsapp.net)\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"message_id\",\r\n            display_name=\"Message ID\",\r\n            info=\"ID of the message to react to\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"reaction\",\r\n            display_name=\"Reaction Emoji\",\r\n            info=\"Emoji to use as reaction (e.g., 👍, ❤️, 🔥)\",\r\n            required=True,\r\n            tool_mode=True,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"message\",\r\n            display_name=\"Message\",\r\n            method=\"send_reaction\",\r\n        ),\r\n    ]\r\n\r\n    def build_raw_payload(self) -> str:\r\n        \"\"\"\r\n        Build the request payload as a raw JSON string to avoid any escaping.\r\n        \"\"\"\r\n        # Construct JSON manually to avoid any escaping\r\n        payload = f'''{{\r\n    \"key\": {{\r\n        \"remoteJid\": \"{self.remote_jid}\",\r\n        \"fromMe\": true,\r\n        \"id\": \"{self.message_id}\"\r\n    }},\r\n    \"reaction\": \"{self.reaction}\"\r\n}}'''\r\n        \r\n        # Log payload (excluding sensitive data)\r\n        safe_payload = payload.replace(self.remote_jid, \"***hidden***\")\r\n        self.log(f\"Built payload: {safe_payload}\")\r\n        \r\n        return payload\r\n\r\n    def send_reaction(self) -> Data:\r\n        \"\"\"\r\n        Send a reaction to a message via Evolution API.\r\n        \"\"\"\r\n        try:\r\n            # Ensure base URL format\r\n            base_url = self.base_url.rstrip('/')\r\n            self.log(f\"Using base URL: {base_url}\")\r\n            \r\n            # Build API endpoint URL\r\n            url = f\"{base_url}/message/sendReaction/{self.instance_id}\"\r\n            self.log(f\"Full API endpoint URL: {url}\")\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n                \"Content-Type\": \"application/json\"\r\n            }\r\n            self.log(\"Headers prepared (apikey hidden)\")\r\n\r\n            # Build raw payload\r\n            payload = self.build_raw_payload()\r\n            \r\n            # Log the complete request (excluding sensitive data)\r\n            self.log(f\"Making request to: {url}\")\r\n            self.log(\"Headers: Content-Type: application/json, apikey: ***hidden***\")\r\n\r\n            # Make API request with raw payload\r\n            response = requests.post(\r\n                url, \r\n                headers=headers, \r\n                data=payload.encode('utf-8')\r\n            )\r\n            \r\n            self.log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Check for successful response\r\n            response.raise_for_status()\r\n            \r\n            # Parse response\r\n            data = response.json()\r\n            \r\n            # Process response into consistent format\r\n            processed_response = {\r\n                \"key\": data.get(\"key\", {}),\r\n                \"pushName\": data.get(\"pushName\", \"\"),\r\n                \"status\": data.get(\"status\"),\r\n                \"message\": data.get(\"message\", {}),\r\n                \"contextInfo\": data.get(\"contextInfo\"),\r\n                \"messageType\": data.get(\"messageType\"),\r\n                \"messageTimestamp\": data.get(\"messageTimestamp\"),\r\n                \"instanceId\": data.get(\"instanceId\"),\r\n                \"source\": data.get(\"source\")\r\n            }\r\n            \r\n            self.log(\"Reaction sent successfully\")\r\n            self.log(f\"Message status: {processed_response.get('status')}\")\r\n            \r\n            return Data(data=processed_response)\r\n\r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"API request failed: {str(e)}\"\r\n            self.log(f\"Request error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Unexpected error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"instance_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"felipe8888","display_name":"Instance ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"MessageTextInput"},"message_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"message_id","value":"3FD14CEFF7EF90F157FF","display_name":"Message ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"ID of the message to react to","title_case":false,"type":"str","_input_type":"MessageTextInput"},"reaction":{"tool_mode":true,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"reaction","value":"","display_name":"Reaction Emoji","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Emoji to use as reaction (e.g., 👍, ❤️, 🔥)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"remote_jid":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"remote_jid","value":"5511986780008@s.whatsapp.net","display_name":"Chat ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"WhatsApp chat ID (e.g., 5511999999999@s.whatsapp.net)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"tools_metadata":{"tool_mode":false,"is_list":true,"table_schema":{"columns":[{"name":"name","display_name":"Tool Name","sortable":false,"filterable":false,"type":"text","description":"Specify the name of the tool.","disable_edit":false,"edit_mode":"inline","formatter":"text"},{"name":"description","display_name":"Tool Description","sortable":false,"filterable":false,"type":"text","description":"Describe the purpose of the tool.","disable_edit":false,"edit_mode":"inline","formatter":"text"},{"name":"tags","display_name":"Tool Identifiers","sortable":false,"filterable":false,"type":"text","description":"These are the default identifiers for the tools and cannot be changed. Tool Name and Tool Description are the only editable fields.","disable_edit":true,"edit_mode":"inline","formatter":"text"}]},"trigger_text":"Open toolset","trigger_icon":"Hammer","table_options":{"block_add":true,"block_delete":true,"block_edit":true,"block_sort":true,"block_filter":true,"block_hide":true,"block_select":true,"hide_options":true,"field_parsers":{"name":"snake_case"}},"trace_as_metadata":true,"required":false,"placeholder":"","show":true,"name":"tools_metadata","value":[{"name":"send_reaction-send_reaction","description":"send_reaction(api_key: Message, base_url: Message, instance_id: Message, message_id: Message, reaction: Message, remote_jid: Message) - Send a reaction emoji to a specific message using Evolution API","tags":["send_reaction-send_reaction"]}],"display_name":"Toolset configuration","advanced":false,"dynamic":false,"info":"Use the table to configure the tools.","real_time_refresh":true,"title_case":false,"type":"table","_input_type":"TableInput"}},"description":"Send a reaction emoji to a specific message using Evolution API","icon":"smile","base_classes":["Data"],"display_name":"Evolution Send Reaction","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Tool"],"selected":"Tool","name":"component_as_tool","hidden":null,"display_name":"Toolset","method":"to_toolkit","value":"__UNDEFINED__","cache":true,"required_inputs":null}],"field_order":["base_url","api_key","instance_id","remote_jid","message_id","reaction"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":true,"lf_version":"1.1.1"},"type":"CustomComponent","id":"CustomComponent-wLHbG"},"selected":false,"measured":{"width":320,"height":770},"dragging":false},{"id":"CustomComponent-grJsd","type":"genericNode","position":{"x":-2390.6205540939013,"y":734.7600542900697},"data":{"node":{"template":{"_type":"Component","api_key":{"load_from_db":false,"required":true,"placeholder":"","show":true,"name":"api_key","value":null,"display_name":"API Key","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API key for authentication","title_case":false,"password":true,"type":"str","_input_type":"SecretStrInput"},"base_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"base_url","value":"","display_name":"API Base URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API base URL (e.g., http://example.com:8080)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Dict, Any\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    SecretStrInput,\r\n    TableInput,\r\n    IntInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass SendPollComponent(Component):\r\n    display_name = \"Evolution Send Poll\"\r\n    description = \"Create and send a poll message using Evolution API\"\r\n    icon = \"bar-chart-2\"\r\n    name = \"send_poll\"\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"base_url\",\r\n            display_name=\"API Base URL\",\r\n            info=\"Evolution API base URL (e.g., http://example.com:8080)\",\r\n            required=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"api_key\",\r\n            display_name=\"API Key\",\r\n            info=\"Evolution API key for authentication\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"number\",\r\n            display_name=\"Recipient Number\",\r\n            info=\"WhatsApp ID of the recipient (e.g., 5511999999999@s.whatsapp.net)\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"name\",\r\n            display_name=\"Poll Question\",\r\n            info=\"The main text/question of the poll\",\r\n            required=True,\r\n        ),\r\n        IntInput(\r\n            name=\"selectable_count\",\r\n            display_name=\"Max Selectable Options\",\r\n            info=\"Maximum number of options a user can select\",\r\n            required=True,\r\n        ),\r\n        TableInput(\r\n            name=\"poll_options\",\r\n            display_name=\"Poll Options\",\r\n            info=\"List of options/choices for the poll\",\r\n            required=True,\r\n            table_schema=[\r\n                {\r\n                    \"name\": \"option\",\r\n                    \"display_name\": \"Option\",\r\n                    \"type\": \"str\",\r\n                    \"description\": \"Text for this poll option\",\r\n                    \"required\": True,\r\n                }\r\n            ],\r\n            value=[{\"option\": \"Option 1\"}],\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"message\",\r\n            display_name=\"Message\",\r\n            method=\"send_poll\",\r\n        ),\r\n    ]\r\n\r\n    def build_raw_payload(self) -> str:\r\n        \"\"\"\r\n        Build the request payload as a raw JSON string.\r\n        \"\"\"\r\n        # Extract options from table input\r\n        values = [opt[\"option\"] for opt in self.poll_options]\r\n        \r\n        # Construct JSON manually\r\n        payload = f'''{{\r\n    \"number\": \"{self.number}\",\r\n    \"name\": \"{self.name}\",\r\n    \"selectableCount\": {self.selectable_count},\r\n    \"values\": {json.dumps(values, ensure_ascii=False)}\r\n}}'''\r\n        \r\n        # Log payload (excluding sensitive data)\r\n        safe_payload = payload.replace(self.number, \"***hidden***\")\r\n        self.log(f\"Built payload: {safe_payload}\")\r\n        \r\n        return payload\r\n\r\n    def send_poll(self) -> Data:\r\n        \"\"\"\r\n        Send a poll message via Evolution API.\r\n        \"\"\"\r\n        try:\r\n            # Ensure base URL format\r\n            base_url = self.base_url.rstrip('/')\r\n            self.log(f\"Using base URL: {base_url}\")\r\n            \r\n            # Build API endpoint URL\r\n            url = f\"{base_url}/message/sendPoll/{self.instance_id}\"\r\n            self.log(f\"Full API endpoint URL: {url}\")\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n                \"Content-Type\": \"application/json\"\r\n            }\r\n            self.log(\"Headers prepared (apikey hidden)\")\r\n\r\n            # Build payload\r\n            payload = self.build_raw_payload()\r\n            \r\n            # Log request details\r\n            self.log(f\"Making request to: {url}\")\r\n            self.log(\"Headers: Content-Type: application/json, apikey: ***hidden***\")\r\n\r\n            # Make API request\r\n            response = requests.post(\r\n                url, \r\n                headers=headers, \r\n                data=payload.encode('utf-8')\r\n            )\r\n            \r\n            self.log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Check for successful response\r\n            response.raise_for_status()\r\n            \r\n            # Parse response\r\n            data = response.json()\r\n            \r\n            # Process response into consistent format\r\n            processed_response = {\r\n                \"key\": data.get(\"key\", {}),\r\n                \"pushName\": data.get(\"pushName\", \"\"),\r\n                \"status\": data.get(\"status\"),\r\n                \"message\": data.get(\"message\", {}),\r\n                \"contextInfo\": data.get(\"contextInfo\"),\r\n                \"messageType\": data.get(\"messageType\"),\r\n                \"messageTimestamp\": data.get(\"messageTimestamp\"),\r\n                \"instanceId\": data.get(\"instanceId\"),\r\n                \"source\": data.get(\"source\")\r\n            }\r\n            \r\n            self.log(\"Poll sent successfully\")\r\n            self.log(f\"Message status: {processed_response.get('status')}\")\r\n            \r\n            return Data(data=processed_response)\r\n\r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"API request failed: {str(e)}\"\r\n            self.log(f\"Request error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Unexpected error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"instance_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"felipe8888","display_name":"Instance ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"MessageTextInput"},"name":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"name","value":"3FD14CEFF7EF90F157FF","display_name":"Poll Question","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The main text/question of the poll","title_case":false,"type":"str","_input_type":"MessageTextInput"},"number":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"number","value":"5511986780008@s.whatsapp.net","display_name":"Recipient Number","advanced":false,"input_types":["Message"],"dynamic":false,"info":"WhatsApp ID of the recipient (e.g., 5511999999999@s.whatsapp.net)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"poll_options":{"tool_mode":false,"is_list":true,"table_schema":{"columns":[{"name":"option","display_name":"Option","sortable":true,"filterable":true,"type":"text","description":"Text for this poll option","disable_edit":false,"edit_mode":"modal","formatter":"text"}]},"trigger_text":"Open table","trigger_icon":"Table","trace_as_metadata":true,"required":true,"placeholder":"","show":true,"name":"poll_options","value":[{"option":"rola 1"},{"option":"grossa"},{"option":"3"},{"option":"5"},{"option":"7"}],"display_name":"Poll Options","advanced":false,"dynamic":false,"info":"List of options/choices for the poll","title_case":false,"type":"table","_input_type":"TableInput"},"selectable_count":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":true,"placeholder":"","show":true,"name":"selectable_count","value":2,"display_name":"Max Selectable Options","advanced":false,"dynamic":false,"info":"Maximum number of options a user can select","title_case":false,"type":"int","_input_type":"IntInput"}},"description":"Create and send a poll message using Evolution API","icon":"bar-chart-2","base_classes":["Data"],"display_name":"Evolution Send Poll","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"message","display_name":"Message","method":"send_poll","value":"__UNDEFINED__","cache":true}],"field_order":["base_url","api_key","instance_id","number","name","selectable_count","poll_options"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1"},"type":"CustomComponent","id":"CustomComponent-grJsd"},"selected":false,"measured":{"width":320,"height":769},"dragging":false},{"id":"CustomComponent-74ODm","type":"genericNode","position":{"x":-1301.8821207366148,"y":645.3051930205424},"data":{"node":{"template":{"_type":"Component","api_key":{"load_from_db":false,"required":true,"placeholder":"","show":true,"name":"api_key","value":null,"display_name":"API Key","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API key for authentication","title_case":false,"password":true,"type":"str","_input_type":"SecretStrInput"},"base_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"base_url","value":"","display_name":"API Base URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API base URL (e.g., http://example.com:8080)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"button_text":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"button_text","value":"uhulll","display_name":"Button Text","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Text to display on the button","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Dict, Any\r\nfrom itertools import count\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    SecretStrInput,\r\n    TableInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass SendListComponent(Component):\r\n    display_name = \"Evolution Send List\"\r\n    description = \"Send an interactive list message using Evolution API\"\r\n    icon = \"list\"\r\n    name = \"send_list\"\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"base_url\",\r\n            display_name=\"API Base URL\",\r\n            info=\"Evolution API base URL (e.g., http://example.com:8080)\",\r\n            required=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"api_key\",\r\n            display_name=\"API Key\",\r\n            info=\"Evolution API key for authentication\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"number\",\r\n            display_name=\"Recipient Number\",\r\n            info=\"WhatsApp ID of the recipient (e.g., 5511999999999@s.whatsapp.net)\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"title\",\r\n            display_name=\"List Title\",\r\n            info=\"Title of the list message\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"list_description\",\r\n            display_name=\"Description\",\r\n            info=\"Description of the list\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"button_text\",\r\n            display_name=\"Button Text\",\r\n            info=\"Text to display on the button\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"footer_text\",\r\n            display_name=\"Footer Text\",\r\n            info=\"Text to display in the footer\",\r\n            required=True,\r\n        ),\r\n        TableInput(\r\n            name=\"list_items\",\r\n            display_name=\"List Items\",\r\n            info=\"Add rows to your list. Rows with the same section title will be grouped together.\",\r\n            required=True,\r\n            table_schema=[\r\n                {\r\n                    \"name\": \"section_title\",\r\n                    \"display_name\": \"Section Title\",\r\n                    \"type\": \"str\",\r\n                    \"description\": \"Title of the section. Rows with the same section title will be grouped together.\",\r\n                    \"required\": True,\r\n                },\r\n                {\r\n                    \"name\": \"row_title\",\r\n                    \"display_name\": \"Row Title\",\r\n                    \"type\": \"str\",\r\n                    \"description\": \"Title for this list item\",\r\n                    \"required\": True,\r\n                },\r\n                {\r\n                    \"name\": \"row_description\",\r\n                    \"display_name\": \"Row Description\",\r\n                    \"type\": \"str\",\r\n                    \"description\": \"Description for this list item\",\r\n                    \"required\": True,\r\n                }\r\n            ],\r\n            value=[{\r\n                \"section_title\": \"My Section\",\r\n                \"row_title\": \"First Item\",\r\n                \"row_description\": \"Description of first item\"\r\n            }],\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"message\",\r\n            display_name=\"Message\",\r\n            method=\"send_list\",\r\n        ),\r\n    ]\r\n\r\n    def group_items_by_section(self) -> list:\r\n        \"\"\"\r\n        Group list items by section title and add auto-generated row IDs.\r\n        Returns list of sections with their rows.\r\n        \"\"\"\r\n        # Group items by section title\r\n        sections_dict = {}\r\n        row_counter = count(1)\r\n        \r\n        for item in self.list_items:\r\n            section_title = item[\"section_title\"]\r\n            \r\n            # Create row with auto-generated ID\r\n            row = {\r\n                \"title\": item[\"row_title\"],\r\n                \"description\": item[\"row_description\"],\r\n                \"rowId\": f\"rowId {str(next(row_counter)).zfill(3)}\"\r\n            }\r\n            \r\n            # Add to existing section or create new one\r\n            if section_title in sections_dict:\r\n                sections_dict[section_title].append(row)\r\n            else:\r\n                sections_dict[section_title] = [row]\r\n        \r\n        # Convert to list of sections\r\n        sections = [\r\n            {\r\n                \"title\": section_title,\r\n                \"rows\": rows\r\n            }\r\n            for section_title, rows in sections_dict.items()\r\n        ]\r\n        \r\n        return sections\r\n\r\n    def build_raw_payload(self) -> str:\r\n        \"\"\"\r\n        Build the request payload as a raw JSON string to maintain formatting.\r\n        \"\"\"\r\n        # Get grouped sections and rows\r\n        sections = self.group_items_by_section()\r\n        \r\n        # Format sections as JSON\r\n        sections_json = json.dumps(sections, ensure_ascii=False)\r\n        \r\n        # Construct final JSON payload\r\n        payload = f'''{{\r\n    \"number\": \"{self.number}\",\r\n    \"title\": \"{self.title}\",\r\n    \"description\": \"{self.list_description}\",\r\n    \"buttonText\": \"{self.button_text}\",\r\n    \"footerText\": \"{self.footer_text}\",\r\n    \"sections\": {sections_json}\r\n}}'''\r\n        \r\n        # Log payload (excluding sensitive data)\r\n        safe_payload = payload.replace(self.number, \"***hidden***\")\r\n        self.log(f\"Built payload: {safe_payload}\")\r\n        \r\n        return payload\r\n\r\n    def send_list(self) -> Data:\r\n        \"\"\"\r\n        Send a list message via Evolution API.\r\n        \"\"\"\r\n        try:\r\n            # Ensure base URL format\r\n            base_url = self.base_url.rstrip('/')\r\n            self.log(f\"Using base URL: {base_url}\")\r\n            \r\n            # Build API endpoint URL\r\n            url = f\"{base_url}/message/sendList/{self.instance_id}\"\r\n            self.log(f\"Full API endpoint URL: {url}\")\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n                \"Content-Type\": \"application/json\"\r\n            }\r\n            self.log(\"Headers prepared (apikey hidden)\")\r\n\r\n            # Build payload\r\n            payload = self.build_raw_payload()\r\n            \r\n            # Log request details\r\n            self.log(f\"Making request to: {url}\")\r\n            self.log(\"Headers: Content-Type: application/json, apikey: ***hidden***\")\r\n\r\n            # Make API request\r\n            response = requests.post(\r\n                url, \r\n                headers=headers, \r\n                data=payload.encode('utf-8')\r\n            )\r\n            \r\n            self.log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Check for successful response\r\n            response.raise_for_status()\r\n            \r\n            # Parse response\r\n            data = response.json()\r\n            \r\n            # Process response into consistent format\r\n            processed_response = {\r\n                \"key\": data.get(\"key\", {}),\r\n                \"pushName\": data.get(\"pushName\", \"\"),\r\n                \"status\": data.get(\"status\"),\r\n                \"message\": data.get(\"message\", {}),\r\n                \"contextInfo\": data.get(\"contextInfo\"),\r\n                \"messageType\": data.get(\"messageType\"),\r\n                \"messageTimestamp\": data.get(\"messageTimestamp\"),\r\n                \"instanceId\": data.get(\"instanceId\"),\r\n                \"source\": data.get(\"source\")\r\n            }\r\n            \r\n            self.log(\"List message sent successfully\")\r\n            self.log(f\"Message status: {processed_response.get('status')}\")\r\n            \r\n            return Data(data=processed_response)\r\n\r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"API request failed: {str(e)}\"\r\n            self.log(f\"Request error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Unexpected error: {error_msg}\")\r\n            return Data(data={\r\n                \"error\": error_msg,\r\n                \"status\": \"ERROR\"\r\n            })","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"footer_text":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"footer_text","value":"hahaha","display_name":"Footer Text","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Text to display in the footer","title_case":false,"type":"str","_input_type":"MessageTextInput"},"instance_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"felipe8888","display_name":"Instance ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"MessageTextInput"},"list_description":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"list_description","value":"desc","display_name":"Description","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Description of the list","title_case":false,"type":"str","_input_type":"MessageTextInput"},"list_items":{"tool_mode":false,"is_list":true,"table_schema":{"columns":[{"name":"section_title","display_name":"Section Title","sortable":true,"filterable":true,"type":"text","description":"Title of the section. Rows with the same section title will be grouped together.","disable_edit":false,"edit_mode":"modal","formatter":"text"},{"name":"row_title","display_name":"Row Title","sortable":true,"filterable":true,"type":"text","description":"Title for this list item","disable_edit":false,"edit_mode":"modal","formatter":"text"},{"name":"row_description","display_name":"Row Description","sortable":true,"filterable":true,"type":"text","description":"Description for this list item","disable_edit":false,"edit_mode":"modal","formatter":"text"}]},"trigger_text":"Open table","trigger_icon":"Table","trace_as_metadata":true,"required":true,"placeholder":"","show":true,"name":"list_items","value":[{"section_title":"1","row_title":"First Item","row_description":"Description of first item"},{"section_title":"1","row_title":"second","row_description":"heuehue"},{"section_title":"1","row_title":"11","row_description":"111"},{"section_title":"2","row_title":"22","row_description":"222"},{"section_title":"3","row_title":"33","row_description":"333"}],"display_name":"List Items","advanced":false,"dynamic":false,"info":"Add rows to your list. Rows with the same section title will be grouped together.","title_case":false,"type":"table","_input_type":"TableInput","load_from_db":false},"number":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"number","value":"5511986780008@s.whatsapp.net","display_name":"Recipient Number","advanced":false,"input_types":["Message"],"dynamic":false,"info":"WhatsApp ID of the recipient (e.g., 5511999999999@s.whatsapp.net)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"title":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"title","value":"teste","display_name":"List Title","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Title of the list message","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Send an interactive list message using Evolution API","icon":"list","base_classes":["Data"],"display_name":"Evolution Send List","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"message","display_name":"Message","method":"send_list","value":"__UNDEFINED__","cache":true}],"field_order":["base_url","api_key","instance_id","number","title","list_description","button_text","footer_text","list_items"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1"},"type":"CustomComponent","id":"CustomComponent-74ODm"},"selected":false,"measured":{"width":320,"height":942},"dragging":false},{"id":"CustomComponent-YenJI","type":"genericNode","position":{"x":-626.7584465420314,"y":713.6072109233182},"data":{"node":{"template":{"_type":"Component","api_key":{"load_from_db":false,"required":true,"placeholder":"","show":true,"name":"api_key","value":null,"display_name":"API Key","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API key for authentication","title_case":false,"password":true,"type":"str","_input_type":"SecretStrInput"},"base_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"base_url","value":"","display_name":"API Base URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API base URL (e.g., http://example.com:8080)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Dict, Any, List\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    SecretStrInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass VerifyWhatsAppNumbersComponent(Component):\r\n    display_name = \"Evolution Verify WhatsApp Numbers\"\r\n    description = \"Check if phone numbers exist on WhatsApp\"\r\n    icon = \"check\"\r\n    name = \"verify_whatsapp_numbers\"\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"base_url\",\r\n            display_name=\"API Base URL\",\r\n            info=\"Evolution API base URL (e.g., http://example.com:8080)\",\r\n            required=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"api_key\",\r\n            display_name=\"API Key\",\r\n            info=\"Evolution API key for authentication\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"numbers\",\r\n            display_name=\"Phone Numbers\",\r\n            info=\"List of phone numbers to check (one per line)\",\r\n            required=True,\r\n            is_list=True,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"verification_results\",\r\n            display_name=\"Verification Results\",\r\n            description=\"Results of WhatsApp number verification\",\r\n            method=\"verify_numbers\",\r\n            type=\"list[Data]\"\r\n        ),\r\n    ]\r\n\r\n    def build_raw_payload(self) -> str:\r\n        \"\"\"\r\n        Build the request payload as a raw JSON string.\r\n        \"\"\"\r\n        # Convert numbers to clean format (strip any extra whitespace)\r\n        numbers = [str(num).strip() for num in self.numbers]\r\n        \r\n        # Construct JSON payload\r\n        payload = f'{{\"numbers\": {json.dumps(numbers, ensure_ascii=False)}}}'\r\n        \r\n        # Log payload\r\n        self.log(f\"Built payload: {payload}\")\r\n        \r\n        return payload\r\n\r\n    def verify_numbers(self) -> List[Data]:\r\n        \"\"\"\r\n        Verify numbers against WhatsApp and return results as list of Data objects.\r\n        \"\"\"\r\n        try:\r\n            # Ensure base URL format\r\n            base_url = self.base_url.rstrip('/')\r\n            self.log(f\"Using base URL: {base_url}\")\r\n            \r\n            # Build API endpoint URL\r\n            url = f\"{base_url}/chat/whatsappNumbers/{self.instance_id}\"\r\n            self.log(f\"Full API endpoint URL: {url}\")\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n                \"Content-Type\": \"application/json\"\r\n            }\r\n            self.log(\"Headers prepared (apikey hidden)\")\r\n\r\n            # Build payload\r\n            payload = self.build_raw_payload()\r\n            \r\n            # Log request details\r\n            self.log(f\"Making request to: {url}\")\r\n            self.log(\"Headers: Content-Type: application/json, apikey: ***hidden***\")\r\n\r\n            # Make API request\r\n            response = requests.post(\r\n                url, \r\n                headers=headers, \r\n                data=payload.encode('utf-8')\r\n            )\r\n            \r\n            self.log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Check for successful response\r\n            response.raise_for_status()\r\n            \r\n            # Parse response\r\n            results = response.json()\r\n            self.log(f\"Verification complete. Found {len(results)} results.\")\r\n            \r\n            # Convert each result into a Data object with specific fields\r\n            processed_results = []\r\n            for result in results:\r\n                processed_results.append(Data(data={\r\n                    \"exists\": result.get(\"exists\", False),\r\n                    \"number\": result.get(\"number\", \"\"),\r\n                    \"name\": result.get(\"name\", \"\"),\r\n                    \"jid\": result.get(\"jid\", \"\")\r\n                }))\r\n            \r\n            return processed_results\r\n\r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"API request failed: {str(e)}\"\r\n            self.log(f\"Request error: {error_msg}\")\r\n            return [Data(data={\r\n                \"exists\": False,\r\n                \"number\": \"\",\r\n                \"name\": \"\",\r\n                \"jid\": \"\"\r\n            })]\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Unexpected error: {error_msg}\")\r\n            return [Data(data={\r\n                \"exists\": False,\r\n                \"number\": \"\",\r\n                \"name\": \"\",\r\n                \"jid\": \"\"\r\n            })]","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"instance_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"felipe8888","display_name":"Instance ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"MessageTextInput"},"numbers":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":true,"required":true,"placeholder":"","show":true,"name":"numbers","value":["5511986780008","5511986780007"],"display_name":"Phone Numbers","advanced":false,"input_types":["Message"],"dynamic":false,"info":"List of phone numbers to check (one per line)","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Check if phone numbers exist on WhatsApp","icon":"check","base_classes":["Data"],"display_name":"Evolution Verify WhatsApp Numbers","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"verification_results","display_name":"Verification Results","method":"verify_numbers","value":"__UNDEFINED__","cache":true}],"field_order":["base_url","api_key","instance_id","numbers"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1"},"type":"CustomComponent","id":"CustomComponent-YenJI"},"selected":false,"measured":{"width":320,"height":539},"dragging":false},{"id":"CustomComponent-8YjZD","type":"genericNode","position":{"x":-3348.8195039685797,"y":727.8991450494445},"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from typing import Any, Dict, List, Optional\r\nfrom sqlalchemy import create_engine, text\r\nimport json\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    StrInput,\r\n    MessageTextInput,\r\n    IntInput,\r\n    DropdownInput,\r\n    Output, \r\n    BoolInput\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass TextMessageQueryComponent(Component):\r\n    display_name = \"Evolution Text Message Query\"\r\n    description = \"Query text messages from Evolution database with different filter options\"\r\n    icon = \"message-square\"\r\n    name = \"evolution_text_message_query\"\r\n\r\n    def __init__(self, **data):\r\n        super().__init__(**data)\r\n        self._engine = None\r\n\r\n    inputs = [\r\n        StrInput(\r\n            name=\"connection_string\",\r\n            display_name=\"Connection String\",\r\n            info=\"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)\",\r\n            required=True\r\n        ),\r\n        StrInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"message_id\",\r\n            display_name=\"Message ID\",\r\n            info=\"Find specific text message by ID\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"remote_jid\",\r\n            display_name=\"Remote JID\",\r\n            info=\"Filter by remote JID (e.g., 5511999999999@s.whatsapp.net or 123456789@g.us for groups)\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"push_name\",\r\n            display_name=\"Push Name\",\r\n            info=\"Filter by contact name\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"text_search\",\r\n            display_name=\"Text Search\",\r\n            info=\"Search for specific text in messages\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"participant\",\r\n            display_name=\"Participant\",\r\n            info=\"Filter by participant in group chats (JID)\",\r\n            required=False,\r\n            advanced=True\r\n        ),\r\n        BoolInput(\r\n            name=\"from_me\",\r\n            display_name=\"From Me\",\r\n            info=\"Filter messages sent by me\",\r\n            advanced=True\r\n        ),\r\n        BoolInput(\r\n            name=\"is_group\",\r\n            display_name=\"Group Messages\",\r\n            info=\"Filter group messages only\",\r\n            advanced=True\r\n        ),\r\n        BoolInput(\r\n            name=\"has_quoted\",\r\n            display_name=\"Has Quote\",\r\n            info=\"Filter messages that quote other messages\",\r\n            advanced=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"start_time\",\r\n            display_name=\"Start Time\",\r\n            info=\"Start time (YYYY-MM-DD HH:MM:SS)\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"end_time\",\r\n            display_name=\"End Time\", \r\n            info=\"End time (YYYY-MM-DD HH:MM:SS)\",\r\n            required=False\r\n        ),\r\n        DropdownInput(\r\n            name=\"sort_direction\",\r\n            display_name=\"Sort Direction\",\r\n            info=\"Sort direction by messageTimestamp\",\r\n            options=[\"ASC\", \"DESC\"],\r\n            value=\"DESC\",\r\n            required=False\r\n        ),\r\n        IntInput(\r\n            name=\"page_size\",\r\n            display_name=\"Page Size\",\r\n            info=\"Number of records per page\",\r\n            value=100,\r\n            required=True\r\n        ),\r\n        IntInput(\r\n            name=\"page\",\r\n            display_name=\"Page\",\r\n            info=\"Page number (starts at 1)\",\r\n            value=1,\r\n            required=True\r\n        )\r\n    ]\r\n\r\n    outputs = [\r\n        Output(name=\"messages\", display_name=\"Messages\", method=\"execute_query\"),\r\n        Output(name=\"parsed_text\", display_name=\"Parsed Text\", method=\"get_parsed_text\"),\r\n    ]\r\n\r\n    def parse_message(self, message: dict, contextInfo: dict = None) -> dict:\r\n        \"\"\"Parse message content to extract text and quoted message.\"\"\"\r\n        try:\r\n            if not message:\r\n                return {}\r\n                \r\n            if isinstance(message, str):\r\n                message = json.loads(message)\r\n\r\n            # Get main message text\r\n            text = message.get(\"conversation\", \"\")\r\n\r\n            # Check for quoted message in contextInfo\r\n            quoted_text = None\r\n            if contextInfo and \"quotedMessage\" in contextInfo:\r\n                quoted = contextInfo[\"quotedMessage\"]\r\n                if isinstance(quoted, str):\r\n                    quoted = json.loads(quoted)\r\n                quoted_text = quoted.get(\"conversation\", \"\")\r\n\r\n            return {\r\n                \"text\": text,\r\n                \"quoted_text\": quoted_text\r\n            }\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error parsing message content: {str(e)}\")\r\n            return {}\r\n\r\n    def get_engine(self):\r\n        \"\"\"Get or create SQLAlchemy engine.\"\"\"\r\n        if not self._engine:\r\n            try:\r\n                self._engine = create_engine(\r\n                    self.connection_string,\r\n                    echo=False\r\n                )\r\n                \r\n                # Test the connection\r\n                with self._engine.connect() as conn:\r\n                    conn.execute(text(\"SELECT 1\"))\r\n                    \r\n            except Exception as e:\r\n                self.log(f\"Failed to create database engine: {str(e)}\")\r\n                raise ValueError(f\"Database connection failed: {str(e)}\") from e\r\n        return self._engine\r\n\r\n    def build_query(self) -> tuple[str, dict]:\r\n        \"\"\"Build the SQL query and parameters.\"\"\"\r\n        try:\r\n            query = '''\r\n                SELECT \r\n                    \"messageTimestamp\", \r\n                    \"messageType\", \r\n                    message, \r\n                    \"pushName\", \r\n                    key,\r\n                    \"contextInfo\"\r\n                FROM public.\"Message\"\r\n                WHERE \"messageType\" = 'conversation'\r\n                AND \"instanceId\" = :instance_id\r\n            '''\r\n            params = {\"instance_id\": self.instance_id}\r\n\r\n            # Add message ID filter if specified\r\n            if hasattr(self, 'message_id') and self.message_id:\r\n                query += \" AND (key->>'id')::text = :message_id\"\r\n                params[\"message_id\"] = str(self.message_id).strip()\r\n\r\n            # Add remote JID filter if specified\r\n            if hasattr(self, 'remote_jid') and self.remote_jid:\r\n                query += \" AND key->>'remoteJid' = :remote_jid\"\r\n                params[\"remote_jid\"] = str(self.remote_jid).strip()\r\n            # Only apply group filter if no specific remote_jid is provided\r\n            elif hasattr(self, 'is_group'):\r\n                if self.is_group:\r\n                    query += \" AND key->>'remoteJid' LIKE '%@g.us'\"\r\n                else:\r\n                    query += \" AND key->>'remoteJid' LIKE '%@s.whatsapp.net'\"\r\n\r\n            # Add push name filter if specified\r\n            if hasattr(self, 'push_name') and self.push_name:\r\n                query += ' AND \"pushName\" = :push_name'\r\n                params[\"push_name\"] = str(self.push_name).strip()\r\n\r\n            # Add text search if specified\r\n            if hasattr(self, 'text_search') and self.text_search:\r\n                query += \" AND message->>'conversation' ILIKE :text_search\"\r\n                params[\"text_search\"] = f\"%{str(self.text_search).strip()}%\"\r\n\r\n            # Add participant filter if specified\r\n            if hasattr(self, 'participant') and self.participant:\r\n                query += \" AND key->>'participant' = :participant\"\r\n                params[\"participant\"] = str(self.participant).strip()\r\n\r\n            # Add fromMe filter if specified\r\n            if hasattr(self, 'from_me'):\r\n                query += \" AND (key->>'fromMe')::boolean = :from_me\"\r\n                params[\"from_me\"] = self.from_me\r\n\r\n            # Add quoted messages filter if specified\r\n            if hasattr(self, 'has_quoted') and self.has_quoted:\r\n                query += ' AND \"contextInfo\"->\\'quotedMessage\\' IS NOT NULL'\r\n\r\n            # Add timestamp range if specified\r\n            if hasattr(self, 'start_time') and self.start_time:\r\n                query += ' AND \"messageTimestamp\" >= (extract(epoch from timestamp :start_time)::bigint)'\r\n                params[\"start_time\"] = str(self.start_time).strip()\r\n            if hasattr(self, 'end_time') and self.end_time:\r\n                query += ' AND \"messageTimestamp\" <= (extract(epoch from timestamp :end_time)::bigint)'\r\n                params[\"end_time\"] = str(self.end_time).strip()\r\n\r\n            # Add ORDER BY\r\n            query += f' ORDER BY \"messageTimestamp\" {self.sort_direction}'\r\n\r\n            # Add pagination\r\n            page = max(1, self.page)\r\n            page_size = max(1, self.page_size)\r\n            offset = (page - 1) * page_size\r\n            query += \" LIMIT :limit OFFSET :offset\"\r\n            params.update({\"limit\": page_size, \"offset\": offset})\r\n\r\n            return query, params\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error building query: {str(e)}\")\r\n            raise ValueError(f\"Failed to build query: {str(e)}\") from e\r\n\r\n    def execute_query(self) -> List[Data]:\r\n        \"\"\"Execute the query and return results.\"\"\"\r\n        try:\r\n            query, params = self.build_query()\r\n            self.log(f\"Executing query: {query} with params: {params}\")\r\n\r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                # Execute main query\r\n                result = conn.execute(text(query), params)\r\n                rows = [dict(zip(row._fields, row)) for row in result]\r\n\r\n                # Get total count\r\n                count_query = '''\r\n                    SELECT COUNT(*) \r\n                    FROM public.\"Message\" \r\n                    WHERE \"messageType\" = 'conversation'\r\n                    AND \"instanceId\" = :instance_id\r\n                '''\r\n                count_params = {\"instance_id\": self.instance_id}\r\n                \r\n                # Add message ID filter to count query\r\n                if hasattr(self, 'message_id') and self.message_id:\r\n                    count_query += \" AND (key->>'id')::text = :message_id\"\r\n                    count_params[\"message_id\"] = str(self.message_id).strip()\r\n\r\n                # Add remote JID filter to count query\r\n                if hasattr(self, 'remote_jid') and self.remote_jid:\r\n                    count_query += \" AND key->>'remoteJid' = :remote_jid\"\r\n                    count_params[\"remote_jid\"] = str(self.remote_jid).strip()\r\n                elif hasattr(self, 'is_group'):\r\n                    if self.is_group:\r\n                        count_query += \" AND key->>'remoteJid' LIKE '%@g.us'\"\r\n                    else:\r\n                        count_query += \" AND key->>'remoteJid' LIKE '%@s.whatsapp.net'\"\r\n\r\n                # Add push name filter to count query\r\n                if hasattr(self, 'push_name') and self.push_name:\r\n                    count_query += ' AND \"pushName\" = :push_name'\r\n                    count_params[\"push_name\"] = str(self.push_name).strip()\r\n\r\n                # Add text search to count query\r\n                if hasattr(self, 'text_search') and self.text_search:\r\n                    count_query += \" AND message->>'conversation' ILIKE :text_search\"\r\n                    count_params[\"text_search\"] = f\"%{str(self.text_search).strip()}%\"\r\n\r\n                # Add participant filter to count query\r\n                if hasattr(self, 'participant') and self.participant:\r\n                    count_query += \" AND key->>'participant' = :participant\"\r\n                    count_params[\"participant\"] = str(self.participant).strip()\r\n\r\n                # Add fromMe filter to count query\r\n                if hasattr(self, 'from_me'):\r\n                    count_query += \" AND (key->>'fromMe')::boolean = :from_me\"\r\n                    count_params[\"from_me\"] = self.from_me\r\n\r\n                # Add quoted messages filter to count query\r\n                if hasattr(self, 'has_quoted') and self.has_quoted:\r\n                    count_query += ' AND \"contextInfo\"->\\'quotedMessage\\' IS NOT NULL'\r\n\r\n                # Add timestamp range to count query\r\n                if hasattr(self, 'start_time') and self.start_time:\r\n                    count_query += ' AND \"messageTimestamp\" >= (extract(epoch from timestamp :start_time)::bigint)'\r\n                    count_params[\"start_time\"] = str(self.start_time).strip()\r\n                if hasattr(self, 'end_time') and self.end_time:\r\n                    count_query += ' AND \"messageTimestamp\" <= (extract(epoch from timestamp :end_time)::bigint)'\r\n                    count_params[\"end_time\"] = str(self.end_time).strip()\r\n\r\n                count_result = conn.execute(text(count_query), count_params)\r\n                total_count = count_result.scalar()\r\n\r\n            # Process messages and extract text\r\n            results = []\r\n            for row in rows:\r\n                parsed = self.parse_message(row[\"message\"], row[\"contextInfo\"])\r\n                \r\n                results.append(Data(\r\n                    data={\r\n                        \"messageTimestamp\": row[\"messageTimestamp\"],\r\n                        \"key\": row[\"key\"],\r\n                        \"pushName\": row[\"pushName\"],\r\n                        \"message\": row[\"message\"],\r\n                        \"contextInfo\": row[\"contextInfo\"],\r\n                        \"text\": parsed.get(\"text\", \"\"),\r\n                        \"quoted_text\": parsed.get(\"quoted_text\"),\r\n                        \"__meta__\": {\r\n                            \"total_records\": total_count,\r\n                            \"page\": self.page,\r\n                            \"page_size\": self.page_size,\r\n                            \"total_pages\": -(-total_count // self.page_size)\r\n                        }\r\n                    }\r\n                ))\r\n\r\n            return results\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error executing query: {str(e)}\")\r\n            raise ValueError(f\"Query execution failed: {str(e)}\") from e\r\n\r\n    def get_parsed_text(self) -> List[Data]:\r\n        \"\"\"Return just the parsed text content from messages.\"\"\"\r\n        try:\r\n            query, params = self.build_query()\r\n            \r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                result = conn.execute(text(query), params)\r\n                rows = [dict(zip(row._fields, row)) for row in result]\r\n\r\n            # Return just the parsed text\r\n            return [\r\n                Data(\r\n                    data={\r\n                        \"text\": self.parse_message(row[\"message\"], row[\"contextInfo\"]).get(\"text\", \"\"),\r\n                        \"quoted_text\": self.parse_message(row[\"message\"], row[\"contextInfo\"]).get(\"quoted_text\")\r\n                    }\r\n                )\r\n                for row in rows\r\n            ]\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error getting parsed text: {str(e)}\")\r\n            raise ValueError(f\"Failed to get parsed text: {str(e)}\") from e","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"connection_string":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"connection_string","value":"postgresql://evolution_user:Duassenha2024@192.168.112.131:5432/evolution_db","display_name":"Connection String","advanced":false,"dynamic":false,"info":"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)","title_case":false,"type":"str","_input_type":"StrInput"},"end_time":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"end_time","value":"","display_name":"End Time","advanced":false,"input_types":["Message"],"dynamic":false,"info":"End time (YYYY-MM-DD HH:MM:SS)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"from_me":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"from_me","value":false,"display_name":"From Me","advanced":true,"dynamic":false,"info":"Filter messages sent by me","title_case":false,"type":"bool","_input_type":"BoolInput"},"has_quoted":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"has_quoted","value":false,"display_name":"Has Quote","advanced":true,"dynamic":false,"info":"Filter messages that quote other messages","title_case":false,"type":"bool","_input_type":"BoolInput"},"instance_id":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"","display_name":"Instance ID","advanced":false,"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"StrInput"},"is_group":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"is_group","value":false,"display_name":"Group Messages","advanced":true,"dynamic":false,"info":"Filter group messages only","title_case":false,"type":"bool","_input_type":"BoolInput"},"message_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"message_id","value":"","display_name":"Message ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Find specific text message by ID","title_case":false,"type":"str","_input_type":"MessageTextInput"},"page":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":true,"placeholder":"","show":true,"name":"page","value":1,"display_name":"Page","advanced":false,"dynamic":false,"info":"Page number (starts at 1)","title_case":false,"type":"int","_input_type":"IntInput"},"page_size":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":true,"placeholder":"","show":true,"name":"page_size","value":100,"display_name":"Page Size","advanced":false,"dynamic":false,"info":"Number of records per page","title_case":false,"type":"int","_input_type":"IntInput","load_from_db":false},"participant":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"participant","value":"","display_name":"Participant","advanced":true,"input_types":["Message"],"dynamic":false,"info":"Filter by participant in group chats (JID)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"push_name":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"push_name","value":"","display_name":"Push Name","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Filter by contact name","title_case":false,"type":"str","_input_type":"MessageTextInput"},"remote_jid":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"remote_jid","value":"5511986780008@s.whatsapp.net","display_name":"Remote JID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Filter by remote JID (e.g., 5511999999999@s.whatsapp.net or 123456789@g.us for groups)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"sort_direction":{"tool_mode":false,"trace_as_metadata":true,"options":["ASC","DESC"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"sort_direction","value":"DESC","display_name":"Sort Direction","advanced":false,"dynamic":false,"info":"Sort direction by messageTimestamp","title_case":false,"type":"str","_input_type":"DropdownInput"},"start_time":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"start_time","value":"","display_name":"Start Time","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Start time (YYYY-MM-DD HH:MM:SS)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"text_search":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"text_search","value":"","display_name":"Text Search","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Search for specific text in messages","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Query text messages from Evolution database with different filter options","icon":"message-square","base_classes":["Data"],"display_name":"Evolution Text Message Query","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"messages","display_name":"Messages","method":"execute_query","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"parsed_text","display_name":"Parsed Text","method":"get_parsed_text","value":"__UNDEFINED__","cache":true}],"field_order":["connection_string","instance_id","message_id","remote_jid","push_name","text_search","participant","from_me","is_group","has_quoted","start_time","end_time","sort_direction","page_size","page"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14"},"type":"CustomComponent","id":"CustomComponent-8YjZD"},"selected":false,"measured":{"width":320,"height":1158},"dragging":false},{"id":"CustomComponent-Gb3t3","type":"genericNode","position":{"x":-2820.0248296298896,"y":769.0396657392945},"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from typing import Any, Dict, List, Optional\r\nfrom sqlalchemy import create_engine, text\r\nimport json\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    StrInput,\r\n    MessageTextInput,\r\n    IntInput,\r\n    DropdownInput,\r\n    Output\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass AudioMessageQueryComponent(Component):\r\n    display_name = \"Evolution Audio Message Query\"\r\n    description = \"Query audio messages from Evolution database with different filter options\"\r\n    icon = \"mic\"\r\n    name = \"evolution_audio_message_query\"\r\n\r\n    def __init__(self, **data):\r\n        super().__init__(**data)\r\n        self._engine = None\r\n\r\n    inputs = [\r\n        StrInput(\r\n            name=\"connection_string\",\r\n            display_name=\"Connection String\",\r\n            info=\"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)\",\r\n            required=True\r\n        ),\r\n        StrInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"message_id\",\r\n            display_name=\"Message ID\",\r\n            info=\"Find specific audio message by ID\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"remote_jid\",\r\n            display_name=\"Remote JID\",\r\n            info=\"Filter by remote JID (e.g., 555199999999@s.whatsapp.net)\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"push_name\",\r\n            display_name=\"Push Name\",\r\n            info=\"Filter by contact name\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"start_time\",\r\n            display_name=\"Start Time\",\r\n            info=\"Start time (YYYY-MM-DD HH:MM:SS)\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"end_time\",\r\n            display_name=\"End Time\", \r\n            info=\"End time (YYYY-MM-DD HH:MM:SS)\",\r\n            required=False\r\n        ),\r\n        DropdownInput(\r\n            name=\"sort_direction\",\r\n            display_name=\"Sort Direction\",\r\n            info=\"Sort direction by messageTimestamp\",\r\n            options=[\"ASC\", \"DESC\"],\r\n            value=\"DESC\",\r\n            required=False\r\n        ),\r\n        IntInput(\r\n            name=\"page_size\",\r\n            display_name=\"Page Size\",\r\n            info=\"Number of records per page\",\r\n            value=100,\r\n            required=True\r\n        ),\r\n        IntInput(\r\n            name=\"page\",\r\n            display_name=\"Page\",\r\n            info=\"Page number (starts at 1)\",\r\n            value=1,\r\n            required=True\r\n        )\r\n    ]\r\n\r\n    outputs = [\r\n        Output(name=\"messages\", display_name=\"Messages\", method=\"execute_query\"),\r\n        Output(name=\"parsed_urls\", display_name=\"Parsed URLs\", method=\"get_parsed_urls\")\r\n    ]\r\n\r\n    def parse_media_url(self, message: Any) -> str:\r\n        \"\"\"Extract and parse media URL from audio message.\"\"\"\r\n        try:\r\n            if isinstance(message, str):\r\n                message = json.loads(message)\r\n                \r\n            if \"mediaUrl\" in message:\r\n                url = message[\"mediaUrl\"]\r\n                if \"?\" in url:\r\n                    return url.split(\"?\")[0]\r\n                return url\r\n                \r\n            return None\r\n            \r\n        except Exception as e:\r\n            self.log(f\"Error parsing media URL: {str(e)}\")\r\n            return None\r\n\r\n    def get_engine(self):\r\n        \"\"\"Get or create SQLAlchemy engine.\"\"\"\r\n        if not self._engine:\r\n            try:\r\n                self._engine = create_engine(\r\n                    self.connection_string,\r\n                    echo=False\r\n                )\r\n                \r\n                # Test the connection\r\n                with self._engine.connect() as conn:\r\n                    conn.execute(text(\"SELECT 1\"))\r\n                    \r\n            except Exception as e:\r\n                self.log(f\"Failed to create database engine: {str(e)}\")\r\n                raise ValueError(f\"Database connection failed: {str(e)}\") from e\r\n        return self._engine\r\n\r\n    def build_query(self) -> tuple[str, dict]:\r\n        \"\"\"Build the SQL query and parameters.\"\"\"\r\n        try:\r\n            query = '''\r\n                SELECT \r\n                    \"messageTimestamp\", \r\n                    \"messageType\", \r\n                    message, \r\n                    \"pushName\", \r\n                    key,\r\n                    \"contextInfo\"\r\n                FROM public.\"Message\"\r\n                WHERE \"messageType\" = 'audioMessage'\r\n                AND \"instanceId\" = :instance_id\r\n            '''\r\n            params = {\"instance_id\": self.instance_id}\r\n\r\n            # Add message ID filter if specified\r\n            if hasattr(self, 'message_id') and self.message_id:\r\n                query += \" AND key->>'id' = :message_id\"\r\n                params[\"message_id\"] = str(self.message_id).strip()\r\n\r\n            # Add remote JID filter if specified\r\n            if hasattr(self, 'remote_jid') and self.remote_jid:\r\n                query += \" AND key->>'remoteJid' = :remote_jid\"\r\n                params[\"remote_jid\"] = str(self.remote_jid).strip()\r\n\r\n            # Add push name filter if specified\r\n            if hasattr(self, 'push_name') and self.push_name:\r\n                query += ' AND \"pushName\" = :push_name'\r\n                params[\"push_name\"] = str(self.push_name).strip()\r\n\r\n            # Add timestamp range if specified\r\n            if hasattr(self, 'start_time') and self.start_time:\r\n                query += ' AND \"messageTimestamp\" >= (extract(epoch from timestamp :start_time)::bigint)'\r\n                params[\"start_time\"] = str(self.start_time).strip()\r\n            if hasattr(self, 'end_time') and self.end_time:\r\n                query += ' AND \"messageTimestamp\" <= (extract(epoch from timestamp :end_time)::bigint)'\r\n                params[\"end_time\"] = str(self.end_time).strip()\r\n\r\n            # Add ORDER BY\r\n            query += f' ORDER BY \"messageTimestamp\" {self.sort_direction}'\r\n\r\n            # Add pagination\r\n            page = max(1, self.page)\r\n            page_size = max(1, self.page_size)\r\n            offset = (page - 1) * page_size\r\n            query += \" LIMIT :limit OFFSET :offset\"\r\n            params.update({\"limit\": page_size, \"offset\": offset})\r\n\r\n            return query, params\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error building query: {str(e)}\")\r\n            raise ValueError(f\"Failed to build query: {str(e)}\") from e\r\n\r\n    def execute_query(self) -> List[Data]:\r\n        \"\"\"Execute the query and return results with all fields.\"\"\"\r\n        try:\r\n            query, params = self.build_query()\r\n            self.log(f\"Executing query: {query} with params: {params}\")\r\n\r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                # Execute main query\r\n                result = conn.execute(text(query), params)\r\n                rows = [dict(zip(row._fields, row)) for row in result]\r\n\r\n                # Get total count\r\n                count_query = '''\r\n                    SELECT COUNT(*) \r\n                    FROM public.\"Message\"\r\n                    WHERE \"messageType\" = 'audioMessage'\r\n                    AND \"instanceId\" = :instance_id\r\n                '''\r\n                count_params = {\"instance_id\": self.instance_id}\r\n                \r\n                # Add message ID filter to count query\r\n                if hasattr(self, 'message_id') and self.message_id:\r\n                    count_query += \" AND key->>'id' = :message_id\"\r\n                    count_params[\"message_id\"] = str(self.message_id).strip()\r\n\r\n                # Add remote JID filter to count query\r\n                if hasattr(self, 'remote_jid') and self.remote_jid:\r\n                    count_query += \" AND key->>'remoteJid' = :remote_jid\"\r\n                    count_params[\"remote_jid\"] = str(self.remote_jid).strip()\r\n\r\n                # Add push name filter to count query\r\n                if hasattr(self, 'push_name') and self.push_name:\r\n                    count_query += ' AND \"pushName\" = :push_name'\r\n                    count_params[\"push_name\"] = str(self.push_name).strip()\r\n\r\n                # Add timestamp range to count query\r\n                if hasattr(self, 'start_time') and self.start_time:\r\n                    count_query += ' AND \"messageTimestamp\" >= (extract(epoch from timestamp :start_time)::bigint)'\r\n                    count_params[\"start_time\"] = str(self.start_time).strip()\r\n                if hasattr(self, 'end_time') and self.end_time:\r\n                    count_query += ' AND \"messageTimestamp\" <= (extract(epoch from timestamp :end_time)::bigint)'\r\n                    count_params[\"end_time\"] = str(self.end_time).strip()\r\n\r\n                count_result = conn.execute(text(count_query), count_params)\r\n                total_count = count_result.scalar()\r\n\r\n            # Convert rows to Data objects with pagination info\r\n            return [\r\n                Data(\r\n                    data={\r\n                        \"messageTimestamp\": row[\"messageTimestamp\"],\r\n                        \"key\": row[\"key\"],\r\n                        \"pushName\": row[\"pushName\"],\r\n                        \"message\": row[\"message\"],\r\n                        \"contextInfo\": row[\"contextInfo\"],\r\n                        \"parsed_url\": self.parse_media_url(row[\"message\"]),\r\n                        \"__meta__\": {\r\n                            \"total_records\": total_count,\r\n                            \"page\": self.page,\r\n                            \"page_size\": self.page_size,\r\n                            \"total_pages\": -(-total_count // self.page_size)\r\n                        }\r\n                    }\r\n                )\r\n                for row in rows\r\n            ]\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error executing query: {str(e)}\")\r\n            raise ValueError(f\"Query execution failed: {str(e)}\") from e\r\n\r\n    def get_parsed_urls(self) -> List[Data]:\r\n        \"\"\"Return just the parsed URLs from the audio messages.\"\"\"\r\n        try:\r\n            query, params = self.build_query()\r\n            \r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                result = conn.execute(text(query), params)\r\n                rows = [dict(zip(row._fields, row)) for row in result]\r\n\r\n            # Return just the parsed URLs\r\n            return [\r\n                Data(\r\n                    data={\r\n                        \"url\": self.parse_media_url(row[\"message\"])\r\n                    }\r\n                )\r\n                for row in rows\r\n                if self.parse_media_url(row[\"message\"]) is not None\r\n            ]\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error getting parsed URLs: {str(e)}\")\r\n            raise ValueError(f\"Failed to get parsed URLs: {str(e)}\") from e","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"connection_string":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"connection_string","value":"postgresql://evolution_user:Duassenha2024@192.168.112.131:5432/evolution_db","display_name":"Connection String","advanced":false,"dynamic":false,"info":"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)","title_case":false,"type":"str","_input_type":"StrInput"},"end_time":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"end_time","value":"2024-12-26 23:59:59","display_name":"End Time","advanced":false,"input_types":["Message"],"dynamic":false,"info":"End time (YYYY-MM-DD HH:MM:SS)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"instance_id":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"","display_name":"Instance ID","advanced":false,"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"StrInput"},"message_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"message_id","value":"","display_name":"Message ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Find specific audio message by ID","title_case":false,"type":"str","_input_type":"MessageTextInput"},"page":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":true,"placeholder":"","show":true,"name":"page","value":1,"display_name":"Page","advanced":false,"dynamic":false,"info":"Page number (starts at 1)","title_case":false,"type":"int","_input_type":"IntInput"},"page_size":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":true,"placeholder":"","show":true,"name":"page_size","value":100,"display_name":"Page Size","advanced":false,"dynamic":false,"info":"Number of records per page","title_case":false,"type":"int","_input_type":"IntInput"},"push_name":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"push_name","value":"","display_name":"Push Name","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Filter by contact name","title_case":false,"type":"str","_input_type":"MessageTextInput"},"remote_jid":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"remote_jid","value":"","display_name":"Remote JID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Filter by remote JID (e.g., 555199999999@s.whatsapp.net)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"sort_direction":{"tool_mode":false,"trace_as_metadata":true,"options":["ASC","DESC"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"sort_direction","value":"DESC","display_name":"Sort Direction","advanced":false,"dynamic":false,"info":"Sort direction by messageTimestamp","title_case":false,"type":"str","_input_type":"DropdownInput"},"start_time":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"start_time","value":"2024-12-25 00:00:00","display_name":"Start Time","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Start time (YYYY-MM-DD HH:MM:SS)","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Query audio messages from Evolution database with different filter options","icon":"mic","base_classes":["Data"],"display_name":"Evolution Audio Message Query","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"messages","display_name":"Messages","method":"execute_query","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"parsed_urls","display_name":"Parsed URLs","method":"get_parsed_urls","value":"__UNDEFINED__","cache":true}],"field_order":["connection_string","instance_id","message_id","remote_jid","push_name","start_time","end_time","sort_direction","page_size","page"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14"},"type":"CustomComponent","id":"CustomComponent-Gb3t3"},"selected":false,"measured":{"width":320,"height":1072},"dragging":false},{"id":"CustomComponent-4Sysy","type":"genericNode","position":{"x":-3961.846908362683,"y":1036.0337904526195},"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from typing import List\r\nfrom sqlalchemy import create_engine, text\r\nfrom datetime import datetime\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    StrInput,\r\n    MessageTextInput,\r\n    Output,\r\n    BoolInput\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass ChatDigestComponent(Component):\r\n    display_name = \"Evolution Chat Digest\"\r\n    description = \"Generate daily digests of WhatsApp conversations for a given time period\"\r\n    icon = \"message-square\"\r\n    name = \"evolution_chat_digest\"\r\n\r\n    def __init__(self, **data):\r\n        super().__init__(**data)\r\n        self._engine = None\r\n\r\n    inputs = [\r\n        StrInput(\r\n            name=\"connection_string\",\r\n            display_name=\"Connection String\",\r\n            info=\"PostgreSQL connection string\",\r\n            required=True\r\n        ),\r\n        StrInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"start_time\",\r\n            display_name=\"Start Time\",\r\n            info=\"Start time (YYYY-MM-DD HH:MM:SS)\",\r\n            required=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"end_time\",\r\n            display_name=\"End Time\", \r\n            info=\"End time (YYYY-MM-DD HH:MM:SS)\",\r\n            required=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"remote_jid\",\r\n            display_name=\"Remote JID Filter\",\r\n            info=\"Filter by specific WhatsApp ID (optional)\",\r\n            required=False\r\n        ),\r\n        BoolInput(\r\n            name=\"include_groups\",\r\n            display_name=\"Include Group Chats\",\r\n            info=\"Include group conversations in the output\",\r\n            value=True\r\n        )\r\n    ]\r\n\r\n    outputs = [\r\n        Output(name=\"chat_digests\", display_name=\"Chat Digests\", method=\"generate_digests\"),\r\n    ]\r\n\r\n    def get_engine(self):\r\n        \"\"\"Get or create SQLAlchemy engine.\"\"\"\r\n        if not self._engine:\r\n            try:\r\n                self._engine = create_engine(self.connection_string, echo=False)\r\n            except Exception as e:\r\n                self.log(f\"Database connection error: {str(e)}\")\r\n                raise\r\n        return self._engine\r\n\r\n    def format_timestamp(self, timestamp: int) -> str:\r\n        \"\"\"Format Unix timestamp to readable date/time.\"\"\"\r\n        try:\r\n            dt = datetime.fromtimestamp(timestamp)\r\n            return dt.strftime(\"%m/%d, %H:%M\")\r\n        except Exception as e:\r\n            self.log(f\"Error formatting timestamp: {str(e)}\")\r\n            return \"\"\r\n\r\n    def generate_digests(self) -> List[Data]:\r\n        \"\"\"Generate chat digests for each conversation.\"\"\"\r\n        try:\r\n            self.log(\"Starting digest generation...\")\r\n            \r\n            # Build query with conditional filters\r\n            query = '''\r\n                SELECT \r\n                    \"messageTimestamp\",\r\n                    message,\r\n                    \"pushName\",\r\n                    key,\r\n                    (key->>'fromMe')::boolean as from_me\r\n                FROM public.\"Message\"\r\n                WHERE \"messageType\" = 'conversation'\r\n                AND \"instanceId\" = :instance_id\r\n                AND \"messageTimestamp\" >= (extract(epoch from timestamp :start_time)::bigint)\r\n                AND \"messageTimestamp\" <= (extract(epoch from timestamp :end_time)::bigint)\r\n            '''\r\n            \r\n            # Build parameters\r\n            params = {\r\n                \"instance_id\": self.instance_id,\r\n                \"start_time\": self.start_time,\r\n                \"end_time\": self.end_time\r\n            }\r\n\r\n            # Add remoteJid filter if provided\r\n            if hasattr(self, 'remote_jid') and self.remote_jid:\r\n                self.log(f\"Adding remote_jid filter: {self.remote_jid}\")\r\n                query += \" AND (key->>'remoteJid') = :remote_jid\"\r\n                params[\"remote_jid\"] = self.remote_jid.strip()\r\n\r\n            # Add group filter if not including groups\r\n            if not self.include_groups:\r\n                self.log(\"Excluding group chats\")\r\n                query += \" AND (key->>'remoteJid') LIKE '%@s.whatsapp.net'\"\r\n\r\n            # Add ordering\r\n            query += ' ORDER BY key->>\\'remoteJid\\', \"messageTimestamp\"'\r\n\r\n            self.log(f\"Query parameters: {params}\")\r\n            engine = self.get_engine()\r\n            conversations = {}\r\n            \r\n            with engine.connect() as conn:\r\n                self.log(\"Executing query...\")\r\n                result = conn.execute(text(query), params)\r\n                rows = [dict(zip(row._fields, row)) for row in result]\r\n                self.log(f\"Retrieved {len(rows)} messages\")\r\n\r\n                for row in rows:\r\n                    # Extract key info (already a dict from PostgreSQL)\r\n                    key = row[\"key\"]\r\n                    remote_jid = key.get(\"remoteJid\", \"\")\r\n                    if not remote_jid:\r\n                        self.log(\"No remoteJid found, skipping message\")\r\n                        continue\r\n\r\n                    # Initialize conversation if needed\r\n                    if remote_jid not in conversations:\r\n                        is_group = remote_jid.endswith(\"@g.us\")\r\n                        conversations[remote_jid] = {\r\n                            \"messages\": [],\r\n                            \"contact_name\": row[\"pushName\"] if not row[\"from_me\"] else None,\r\n                            \"is_group\": is_group,\r\n                            \"participants\": set()\r\n                        }\r\n\r\n                    # For group chats, track participants\r\n                    if conversations[remote_jid][\"is_group\"] and \"participant\" in key:\r\n                        conversations[remote_jid][\"participants\"].add(key[\"participant\"])\r\n\r\n                    # Update contact name if needed (only for individual chats)\r\n                    if not conversations[remote_jid][\"is_group\"] and not row[\"from_me\"]:\r\n                        conversations[remote_jid][\"contact_name\"] = row[\"pushName\"]\r\n                    \r\n                    try:\r\n                        # Format timestamp\r\n                        timestamp = self.format_timestamp(row[\"messageTimestamp\"])\r\n                        if not timestamp:\r\n                            self.log(f\"Invalid timestamp: {row['messageTimestamp']}\")\r\n                            continue\r\n\r\n                        # Get sender name\r\n                        if conversations[remote_jid][\"is_group\"]:\r\n                            name = row[\"pushName\"] or \"Unknown\"\r\n                        else:\r\n                            name = \"You\" if row[\"from_me\"] else (row[\"pushName\"] or \"Unknown\")\r\n\r\n                        # Extract message text (already a dict from PostgreSQL)\r\n                        message = row[\"message\"]\r\n                        message_text = message.get(\"conversation\", \"\") if message else \"\"\r\n                        \r\n                        if not message_text:\r\n                            self.log(\"Empty message text, skipping\")\r\n                            continue\r\n                        \r\n                        # Format and add message\r\n                        formatted_message = f\"[{timestamp}] {name}: {message_text}\"\r\n                        conversations[remote_jid][\"messages\"].append(formatted_message)\r\n                        \r\n                    except Exception as e:\r\n                        self.log(f\"Error processing message: {str(e)}\")\r\n                        continue\r\n\r\n            # Create digest for each conversation\r\n            self.log(\"Creating final digests...\")\r\n            digests = []\r\n            for remote_jid, conv in conversations.items():\r\n                chat_history = \"\\n\".join(conv[\"messages\"])\r\n                \r\n                # Prepare conversation info\r\n                chat_info = {\r\n                    \"remote_jid\": remote_jid,\r\n                    \"message_count\": len(conv[\"messages\"]),\r\n                    \"chat_history\": chat_history\r\n                }\r\n\r\n                # Add group-specific or individual chat info\r\n                if conv[\"is_group\"]:\r\n                    chat_info.update({\r\n                        \"type\": \"group\",\r\n                        \"group_name\": conv[\"contact_name\"] or \"Unknown Group\",\r\n                        \"participant_count\": len(conv[\"participants\"]),\r\n                        \"participants\": list(conv[\"participants\"])\r\n                    })\r\n                else:\r\n                    chat_info.update({\r\n                        \"type\": \"individual\",\r\n                        \"contact_name\": conv[\"contact_name\"] or \"Unknown Contact\"\r\n                    })\r\n\r\n                digests.append(Data(data=chat_info))\r\n\r\n            self.log(f\"Successfully created {len(digests)} digests\")\r\n            return digests\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error generating digests: {str(e)}\")\r\n            raise ValueError(f\"Failed to generate digests: {str(e)}\") from e","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"connection_string":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"connection_string","value":"postgresql://evolution_user:Duassenha2024@192.168.112.131:5432/evolution_db","display_name":"Connection String","advanced":false,"dynamic":false,"info":"PostgreSQL connection string","title_case":false,"type":"str","_input_type":"StrInput"},"end_time":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"end_time","value":"2024-12-27 23:59:59","display_name":"End Time","advanced":false,"input_types":["Message"],"dynamic":false,"info":"End time (YYYY-MM-DD HH:MM:SS)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"include_groups":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"include_groups","value":false,"display_name":"Include Group Chats","advanced":false,"dynamic":false,"info":"Include group conversations in the output","title_case":false,"type":"bool","_input_type":"BoolInput"},"instance_id":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"","display_name":"Instance ID","advanced":false,"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"StrInput"},"remote_jid":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"remote_jid","value":"","display_name":"Remote JID Filter","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Filter by specific WhatsApp ID (optional)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"start_time":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"start_time","value":"2024-12-25 00:00:00","display_name":"Start Time","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Start time (YYYY-MM-DD HH:MM:SS)","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Generate daily digests of WhatsApp conversations for a given time period","icon":"message-square","base_classes":["Data"],"display_name":"Evolution Chat Digest","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"chat_digests","display_name":"Chat Digests","method":"generate_digests","value":"__UNDEFINED__","cache":true}],"field_order":["connection_string","instance_id","start_time","end_time","remote_jid","include_groups"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14"},"type":"CustomComponent","id":"CustomComponent-4Sysy"},"selected":false,"measured":{"width":320,"height":643},"dragging":false}],"edges":[],"viewport":{"x":1042.4263948540738,"y":201.28145254192756,"zoom":0.24918796700306003}},"is_component":false,"updated_at":"2025-01-06T17:56:24+00:00","webhook":false,"endpoint_name":null,"tags":null,"locked":false,"id":"9dd90f93-5b32-4e76-b466-24582d0a7cd3","user_id":"556fed76-1562-4baf-8a2e-ef9be2d194e4","folder_id":"22c5349e-60ef-45a2-a8ec-0debcd24f6dd"},{"name":"auto_transcription_brokenloop","description":"","icon":null,"icon_bg_color":null,"gradient":null,"data":{"nodes":[{"id":"CustomComponent-n4VUY","type":"genericNode","position":{"x":-2969.104039358143,"y":-1158.5889073917622},"data":{"node":{"template":{"_type":"Component","input_data":{"tool_mode":false,"trace_as_metadata":true,"list":false,"trace_as_input":true,"required":true,"placeholder":"","show":true,"name":"input_data","value":"","display_name":"Input Data","advanced":false,"input_types":["Data"],"dynamic":false,"info":"Audio message data containing URL and metadata","title_case":false,"type":"other","_input_type":"DataInput"},"api_key":{"load_from_db":false,"required":true,"placeholder":"","show":true,"name":"api_key","value":null,"display_name":"API Key","advanced":false,"input_types":["Message"],"dynamic":false,"info":"API key for authentication","title_case":false,"password":true,"type":"str","_input_type":"SecretStrInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\r\nimport requests\r\nfrom typing import Dict, Any, Optional\r\nfrom sqlalchemy import create_engine, text\r\nimport uuid\r\nimport time\r\nimport string\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    MessageTextInput,\r\n    SecretStrInput,\r\n    StrInput,\r\n    DataInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\ndef base36encode(number: int) -> str:\r\n    \"\"\"Convert an integer to base36 string.\"\"\"\r\n    alphabet = string.digits + string.ascii_lowercase\r\n    base36 = ''\r\n    \r\n    while number:\r\n        number, i = divmod(number, 36)\r\n        base36 = alphabet[i] + base36\r\n    \r\n    return base36 or '0'\r\n\r\n\r\nclass AudioProcessorComponent(Component):\r\n    display_name = \"Audio Transcriber\"\r\n    description = \"Transcribe audio files from URLs and store results in database\"\r\n    icon = \"mic\"\r\n    name = \"audio_transcriber\"\r\n\r\n    def __init__(self, **data):\r\n        super().__init__(**data)\r\n        self._engine = None\r\n\r\n    def __del__(self):\r\n        \"\"\"Cleanup method to dispose of the engine when component is destroyed.\"\"\"\r\n        self.cleanup()\r\n\r\n    def cleanup(self):\r\n        \"\"\"Cleanup database resources.\"\"\"\r\n        if self._engine:\r\n            self.log(\"Disposing database engine...\")\r\n            self._engine.dispose()\r\n            self._engine = None\r\n\r\n    inputs = [\r\n        DataInput(\r\n            name=\"input_data\",\r\n            display_name=\"Input Data\",\r\n            info=\"Audio message data containing URL and metadata\",\r\n            required=True,\r\n            is_list=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True,\r\n        ),\r\n        MessageTextInput(\r\n            name=\"server_url\",\r\n            display_name=\"Server URL\",\r\n            info=\"Transcription server URL (e.g., http://localhost:4040)\",\r\n            required=True,\r\n        ),\r\n        StrInput(\r\n            name=\"connection_string\",\r\n            display_name=\"Connection String\",\r\n            info=\"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)\",\r\n            required=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"language\",\r\n            display_name=\"Language\",\r\n            info=\"Optional: Language code for transcription\",\r\n            required=False,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"api_key\",\r\n            display_name=\"API Key\",\r\n            info=\"API key for authentication\",\r\n            required=True,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"transcription\",\r\n            display_name=\"Transcription\",\r\n            method=\"transcribe_audio\",\r\n        ),\r\n    ]\r\n\r\n    def generate_cuid2(self) -> str:\r\n        \"\"\"Generate a CUID2-like ID.\"\"\"\r\n        # Get current time in milliseconds and convert to base36\r\n        timestamp = int(time.time() * 1000)\r\n        timestamp_b36 = base36encode(timestamp)\r\n\r\n        # Generate some random bytes\r\n        random_bytes = uuid.uuid4().bytes[:8]\r\n        random_b36 = base36encode(int.from_bytes(random_bytes, 'big'))\r\n\r\n        # Combine to match pattern length (25 chars)\r\n        cuid = f\"{timestamp_b36[:6]}{random_b36[:19]}\"\r\n        return cuid\r\n\r\n    def get_engine(self):\r\n        \"\"\"Get or create SQLAlchemy engine with proper connection pooling.\"\"\"\r\n        if not self._engine:\r\n            try:\r\n                self._engine = create_engine(\r\n                    self.connection_string,\r\n                    echo=False,\r\n                    pool_size=5,  # Set maximum pool size\r\n                    max_overflow=10,  # Allow up to 10 connections to overflow\r\n                    pool_timeout=30,  # Wait up to 30 seconds for available connection\r\n                    pool_recycle=3600,  # Recycle connections after 1 hour\r\n                    pool_pre_ping=True  # Verify connection is still valid before using\r\n                )\r\n                \r\n                # Test the connection\r\n                with self._engine.connect() as conn:\r\n                    conn.execute(text(\"SELECT 1\"))\r\n                    \r\n            except Exception as e:\r\n                self.log(f\"Failed to create database engine: {str(e)}\")\r\n                self.cleanup()  # Ensure cleanup on error\r\n                raise ValueError(f\"Database connection failed: {str(e)}\") from e\r\n        return self._engine\r\n\r\n    def extract_message_id(self, key: Dict[str, Any]) -> Optional[str]:\r\n        \"\"\"Extract message ID from key dictionary.\"\"\"\r\n        try:\r\n            if isinstance(key, str):\r\n                key = json.loads(key)\r\n            # Return just the base ID without any _TRANS suffix\r\n            msg_id = key.get('id', '')\r\n            return msg_id.split('_')[0] if '_' in msg_id else msg_id\r\n        except Exception as e:\r\n            self.log(f\"Error extracting message ID: {str(e)}\")\r\n            return None\r\n\r\n    def check_existing_transcription(self, message_id: str) -> Optional[Dict[str, Any]]:\r\n        \"\"\"Check if transcription already exists for this message.\"\"\"\r\n        try:\r\n            query = '''\r\n                SELECT message\r\n                FROM public.\"Message\"\r\n                WHERE id = :transcription_id\r\n            '''\r\n            \r\n            # Create the transcription ID to check\r\n            transcription_id = f\"{message_id}_TRANS\"\r\n            \r\n            self.log(f\"Checking for existing transcription with ID: {transcription_id}\")\r\n                \r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                result = conn.execute(\r\n                    text(query),\r\n                    {\"transcription_id\": transcription_id}\r\n                )\r\n                row = result.fetchone()\r\n                \r\n                if row:\r\n                    self.log(f\"Found existing transcription for message {message_id}\")\r\n                    return row[0] if isinstance(row[0], dict) else json.loads(row[0])\r\n                    \r\n                self.log(f\"No existing transcription found for message {message_id}\")\r\n                return None\r\n                \r\n        except Exception as e:\r\n            self.log(f\"Error checking existing transcription: {str(e)}\")\r\n            self.cleanup()  # Ensure cleanup on error\r\n            raise ValueError(f\"Failed to check existing transcription: {str(e)}\") from e\r\n\r\n    def insert_transcription(self, transcription: str, original_data: Dict[str, Any]) -> None:\r\n        \"\"\"Insert transcription into database.\"\"\"\r\n        try:\r\n            # Prepare the message data\r\n            message_data = {\"conversation\": transcription}\r\n            \r\n            # Get original key data and message ID\r\n            original_key = original_data.get(\"key\", {})\r\n            if isinstance(original_key, str):\r\n                original_key = json.loads(original_key)\r\n                \r\n            original_id = original_key.get(\"id\")\r\n            if not original_id:\r\n                raise ValueError(\"No message ID found in original key\")\r\n                \r\n            # Create transcription ID by appending suffix\r\n            transcription_id = f\"{original_id}_TRANS\"\r\n            \r\n            # Create the key object for the transcription matching the ID\r\n            transcription_key = {\r\n                \"id\": transcription_id,\r\n                \"fromMe\": original_key.get(\"fromMe\", False),\r\n                \"remoteJid\": original_key.get(\"remoteJid\", \"\")\r\n            }\r\n            \r\n            query = '''\r\n                INSERT INTO public.\"Message\" (\r\n                    id,\r\n                    \"messageTimestamp\",\r\n                    \"messageType\",\r\n                    message,\r\n                    \"pushName\",\r\n                    key,\r\n                    \"instanceId\",\r\n                    \"contextInfo\",\r\n                    source\r\n                ) VALUES (\r\n                    :id,\r\n                    :timestamp,\r\n                    'audioTranscription',\r\n                    :message,\r\n                    :push_name,\r\n                    :key,\r\n                    :instance_id,\r\n                    :context_info,\r\n                    :source\r\n                )\r\n            '''\r\n            \r\n            params = {\r\n                \"id\": transcription_id,\r\n                \"timestamp\": original_data.get(\"messageTimestamp\"),\r\n                \"message\": json.dumps(message_data),\r\n                \"push_name\": original_data.get(\"pushName\"),\r\n                \"key\": json.dumps(transcription_key),\r\n                \"instance_id\": self.instance_id,\r\n                \"context_info\": json.dumps(original_data.get(\"contextInfo\")),\r\n                \"source\": original_data.get(\"source\", \"android\")  # Use original source or fallback to android\r\n            }\r\n            \r\n            self.log(\"Inserting transcription into database\")\r\n            \r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                conn.execute(text(query), params)\r\n                conn.commit()\r\n                \r\n            self.log(\"Successfully inserted transcription\")\r\n            \r\n        except Exception as e:\r\n            self.log(f\"Error inserting transcription: {str(e)}\")\r\n            self.cleanup()  # Ensure cleanup on error\r\n            raise ValueError(f\"Failed to insert transcription: {str(e)}\") from e\r\n\r\n    def transcribe_audio(self) -> Data:\r\n        \"\"\"\r\n        Transcribe audio and store in database.\r\n        \"\"\"\r\n        try:\r\n            # Debug logging for input data\r\n            self.log(f\"Input data object: {self.input_data}\")\r\n            self.log(f\"Input data type: {type(self.input_data)}\")\r\n            \r\n            # Handle list input\r\n            if isinstance(self.input_data, list):\r\n                if not self.input_data:\r\n                    self.log(\"Error: Empty input list\")\r\n                    return Data(data={\"error\": \"No input data provided\"})\r\n                    \r\n                input_item = self.input_data[0]\r\n                self.log(f\"Using first item from list: {input_item}\")\r\n            else:\r\n                input_item = self.input_data\r\n            \r\n            # Extract data from input item\r\n            if not hasattr(input_item, 'data'):\r\n                self.log(\"Error: input item has no 'data' attribute\")\r\n                return Data(data={\"error\": \"Invalid input data format\"})\r\n                \r\n            input_data = input_item.data\r\n            self.log(f\"Extracted input data: {input_data}\")\r\n            \r\n            if not input_data:\r\n                self.log(\"Error: Input data is empty\")\r\n                return Data(data={\"error\": \"Input data is empty\"})\r\n                \r\n            # Extract message ID and check for existing transcription\r\n            message_id = self.extract_message_id(input_data.get(\"key\", {}))\r\n            if not message_id:\r\n                raise ValueError(\"Could not extract message ID from input data\")\r\n                \r\n            # Check for existing transcription\r\n            existing = self.check_existing_transcription(message_id)\r\n            if existing:\r\n                self.log(\"Returning existing transcription\")\r\n                return Data(data=existing)\r\n\r\n            # Get audio URL\r\n            audio_url = input_data.get(\"parsed_url\")\r\n            if not audio_url:\r\n                raise ValueError(\"No audio URL found in input data\")\r\n\r\n            # Ensure server URL format\r\n            server_url = self.server_url.rstrip('/')\r\n            self.log(f\"Using server URL: {server_url}\")\r\n            \r\n            # Build API endpoint URL\r\n            url = f\"{server_url}/transcribe\"\r\n            self.log(f\"Full API endpoint URL: {url}\")\r\n\r\n            # Prepare headers\r\n            headers = {\r\n                \"apikey\": self.api_key,\r\n            }\r\n            self.log(\"Headers prepared (apikey hidden)\")\r\n\r\n            # Prepare payload\r\n            payload = {\r\n                \"url\": audio_url\r\n            }\r\n            \r\n            # Add optional language if provided\r\n            if hasattr(self, 'language') and self.language:\r\n                payload[\"language\"] = self.language\r\n            \r\n            # Log the request (excluding sensitive data)\r\n            request_info = {\r\n                \"url\": url,\r\n                \"headers\": {\r\n                    \"apikey\": \"***hidden***\"\r\n                },\r\n                \"payload\": payload\r\n            }\r\n            self.log(f\"Making request: {json.dumps(request_info, indent=2)}\")\r\n\r\n            # Make API request\r\n            response = requests.post(\r\n                url, \r\n                headers=headers,\r\n                data=payload\r\n            )\r\n            \r\n            self.log(f\"Response status code: {response.status_code}\")\r\n            \r\n            # Check for successful response\r\n            response.raise_for_status()\r\n            \r\n            # Parse response\r\n            data = response.json()\r\n            \r\n            # Extract transcription\r\n            transcription = data.get(\"transcription\", \"\")\r\n            if not transcription:\r\n                raise ValueError(\"No transcription found in response\")\r\n            \r\n            self.log(\"Successfully extracted transcription\")\r\n            \r\n            # Insert into database\r\n            self.insert_transcription(transcription, input_data)\r\n            \r\n            # Return transcription as data\r\n            return Data(data={\"conversation\": transcription})\r\n            \r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"API request failed: {str(e)}\"\r\n            self.log(f\"Request error: {error_msg}\")\r\n            self.cleanup()  # Ensure cleanup on error\r\n            return Data(data={\"error\": error_msg})\r\n        except Exception as e:\r\n            error_msg = f\"Unexpected error: {str(e)}\"\r\n            self.log(f\"Unexpected error: {error_msg}\")\r\n            self.cleanup()  # Ensure cleanup on error\r\n            return Data(data={\"error\": error_msg})","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"connection_string":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"connection_string","value":"postgresql://evolution_user:Duassenha2024@192.168.112.131:5432/evolution_db","display_name":"Connection String","advanced":false,"dynamic":false,"info":"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)","title_case":false,"type":"str","_input_type":"StrInput"},"instance_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"","display_name":"Instance ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"MessageTextInput"},"language":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"language","value":"","display_name":"Language","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Optional: Language code for transcription","title_case":false,"type":"str","_input_type":"MessageTextInput"},"server_url":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"server_url","value":"http://192.168.112.131:4040","display_name":"Server URL","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Transcription server URL (e.g., http://localhost:4040)","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Transcribe audio files from URLs and store results in database","icon":"mic","base_classes":["Data"],"display_name":"Audio Transcriber","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"transcription","display_name":"Transcription","method":"transcribe_audio","value":"__UNDEFINED__","cache":true}],"field_order":["input_data","instance_id","server_url","connection_string","language","api_key"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14"},"type":"CustomComponent","id":"CustomComponent-n4VUY"},"selected":false,"measured":{"width":320,"height":645},"dragging":false},{"id":"CustomComponent-P72R8","type":"genericNode","position":{"x":-3506.8472731941656,"y":-1127.2687716050864},"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from typing import Any, Dict, List, Optional\r\nfrom sqlalchemy import create_engine, text\r\nimport json\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    StrInput,\r\n    MessageTextInput,\r\n    IntInput,\r\n    DropdownInput,\r\n    Output\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass AudioMessageQueryComponent(Component):\r\n    display_name = \"Evolution Audio Message Query\"\r\n    description = \"Query audio messages from Evolution database with different filter options\"\r\n    icon = \"mic\"\r\n    name = \"evolution_audio_message_query\"\r\n\r\n    def __init__(self, **data):\r\n        super().__init__(**data)\r\n        self._engine = None\r\n\r\n    def __del__(self):\r\n        \"\"\"Cleanup method to dispose of the engine when component is destroyed.\"\"\"\r\n        self.cleanup()\r\n\r\n    def cleanup(self):\r\n        \"\"\"Cleanup database resources.\"\"\"\r\n        if self._engine:\r\n            self.log(\"Disposing database engine...\")\r\n            self._engine.dispose()\r\n            self._engine = None\r\n\r\n    inputs = [\r\n        StrInput(\r\n            name=\"connection_string\",\r\n            display_name=\"Connection String\",\r\n            info=\"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)\",\r\n            required=True\r\n        ),\r\n        StrInput(\r\n            name=\"instance_id\",\r\n            display_name=\"Instance ID\",\r\n            info=\"Evolution API instance identifier\",\r\n            required=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"message_id\",\r\n            display_name=\"Message ID\",\r\n            info=\"Find specific audio message by ID\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"remote_jid\",\r\n            display_name=\"Remote JID\",\r\n            info=\"Filter by remote JID (e.g., 555199999999@s.whatsapp.net)\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"push_name\",\r\n            display_name=\"Push Name\",\r\n            info=\"Filter by contact name\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"start_time\",\r\n            display_name=\"Start Time\",\r\n            info=\"Start time (YYYY-MM-DD HH:MM:SS)\",\r\n            required=False\r\n        ),\r\n        MessageTextInput(\r\n            name=\"end_time\",\r\n            display_name=\"End Time\", \r\n            info=\"End time (YYYY-MM-DD HH:MM:SS)\",\r\n            required=False\r\n        ),\r\n        DropdownInput(\r\n            name=\"sort_direction\",\r\n            display_name=\"Sort Direction\",\r\n            info=\"Sort direction by messageTimestamp\",\r\n            options=[\"ASC\", \"DESC\"],\r\n            value=\"DESC\",\r\n            required=False\r\n        ),\r\n        IntInput(\r\n            name=\"page_size\",\r\n            display_name=\"Page Size\",\r\n            info=\"Number of records per page\",\r\n            value=100,\r\n            required=True\r\n        ),\r\n        IntInput(\r\n            name=\"page\",\r\n            display_name=\"Page\",\r\n            info=\"Page number (starts at 1)\",\r\n            value=1,\r\n            required=True\r\n        )\r\n    ]\r\n\r\n    outputs = [\r\n        Output(name=\"messages\", display_name=\"Messages\", method=\"execute_query\"),\r\n        Output(name=\"parsed_urls\", display_name=\"Parsed URLs\", method=\"get_parsed_urls\")\r\n    ]\r\n\r\n    def parse_media_url(self, message: Any) -> str:\r\n        \"\"\"Extract and parse media URL from audio message.\"\"\"\r\n        try:\r\n            if isinstance(message, str):\r\n                message = json.loads(message)\r\n                \r\n            if \"mediaUrl\" in message:\r\n                url = message[\"mediaUrl\"]\r\n                if \"?\" in url:\r\n                    return url.split(\"?\")[0]\r\n                return url\r\n                \r\n            return None\r\n            \r\n        except Exception as e:\r\n            self.log(f\"Error parsing media URL: {str(e)}\")\r\n            return None\r\n\r\n    def get_engine(self):\r\n        \"\"\"Get or create SQLAlchemy engine.\"\"\"\r\n        if not self._engine:\r\n            try:\r\n                self._engine = create_engine(\r\n                    self.connection_string,\r\n                    echo=False,\r\n                    pool_size=5,  # Set maximum pool size\r\n                    max_overflow=10,  # Allow up to 10 connections to overflow\r\n                    pool_timeout=30,  # Wait up to 30 seconds for available connection\r\n                    pool_recycle=3600,  # Recycle connections after 1 hour\r\n                    pool_pre_ping=True  # Verify connection is still valid before using\r\n                )\r\n                \r\n                # Test the connection\r\n                with self._engine.connect() as conn:\r\n                    conn.execute(text(\"SELECT 1\"))\r\n                    \r\n            except Exception as e:\r\n                self.log(f\"Failed to create database engine: {str(e)}\")\r\n                self.cleanup()  # Ensure cleanup on error\r\n                raise ValueError(f\"Database connection failed: {str(e)}\") from e\r\n        return self._engine\r\n\r\n    def build_query(self) -> tuple[str, dict]:\r\n        \"\"\"Build the SQL query and parameters.\"\"\"\r\n        try:\r\n            query = '''\r\n                SELECT \r\n                    \"messageTimestamp\", \r\n                    \"messageType\", \r\n                    message, \r\n                    \"pushName\", \r\n                    key,\r\n                    \"contextInfo\"\r\n                FROM public.\"Message\"\r\n                WHERE \"messageType\" = 'audioMessage'\r\n                AND \"instanceId\" = :instance_id\r\n            '''\r\n            params = {\"instance_id\": self.instance_id}\r\n\r\n            # Add message ID filter if specified\r\n            if hasattr(self, 'message_id') and self.message_id:\r\n                query += \" AND key->>'id' = :message_id\"\r\n                params[\"message_id\"] = str(self.message_id).strip()\r\n\r\n            # Add remote JID filter if specified\r\n            if hasattr(self, 'remote_jid') and self.remote_jid:\r\n                query += \" AND key->>'remoteJid' = :remote_jid\"\r\n                params[\"remote_jid\"] = str(self.remote_jid).strip()\r\n\r\n            # Add push name filter if specified\r\n            if hasattr(self, 'push_name') and self.push_name:\r\n                query += ' AND \"pushName\" = :push_name'\r\n                params[\"push_name\"] = str(self.push_name).strip()\r\n\r\n            # Add timestamp range if specified\r\n            if hasattr(self, 'start_time') and self.start_time:\r\n                query += ' AND \"messageTimestamp\" >= (extract(epoch from timestamp :start_time)::bigint)'\r\n                params[\"start_time\"] = str(self.start_time).strip()\r\n            if hasattr(self, 'end_time') and self.end_time:\r\n                query += ' AND \"messageTimestamp\" <= (extract(epoch from timestamp :end_time)::bigint)'\r\n                params[\"end_time\"] = str(self.end_time).strip()\r\n\r\n            # Add ORDER BY\r\n            query += f' ORDER BY \"messageTimestamp\" {self.sort_direction}'\r\n\r\n            # Add pagination\r\n            page = max(1, self.page)\r\n            page_size = max(1, self.page_size)\r\n            offset = (page - 1) * page_size\r\n            query += \" LIMIT :limit OFFSET :offset\"\r\n            params.update({\"limit\": page_size, \"offset\": offset})\r\n\r\n            return query, params\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error building query: {str(e)}\")\r\n            raise ValueError(f\"Failed to build query: {str(e)}\") from e\r\n\r\n    def execute_query(self) -> List[Data]:\r\n        \"\"\"Execute the query and return results with all fields.\"\"\"\r\n        try:\r\n            query, params = self.build_query()\r\n            self.log(f\"Executing query: {query} with params: {params}\")\r\n\r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                # Execute main query\r\n                result = conn.execute(text(query), params)\r\n                rows = [dict(zip(row._fields, row)) for row in result]\r\n\r\n                # Get total count\r\n                count_query = '''\r\n                    SELECT COUNT(*) \r\n                    FROM public.\"Message\"\r\n                    WHERE \"messageType\" = 'audioMessage'\r\n                    AND \"instanceId\" = :instance_id\r\n                '''\r\n                count_params = {\"instance_id\": self.instance_id}\r\n                \r\n                # Add message ID filter to count query\r\n                if hasattr(self, 'message_id') and self.message_id:\r\n                    count_query += \" AND key->>'id' = :message_id\"\r\n                    count_params[\"message_id\"] = str(self.message_id).strip()\r\n\r\n                # Add remote JID filter to count query\r\n                if hasattr(self, 'remote_jid') and self.remote_jid:\r\n                    count_query += \" AND key->>'remoteJid' = :remote_jid\"\r\n                    count_params[\"remote_jid\"] = str(self.remote_jid).strip()\r\n\r\n                # Add push name filter to count query\r\n                if hasattr(self, 'push_name') and self.push_name:\r\n                    count_query += ' AND \"pushName\" = :push_name'\r\n                    count_params[\"push_name\"] = str(self.push_name).strip()\r\n\r\n                # Add timestamp range to count query\r\n                if hasattr(self, 'start_time') and self.start_time:\r\n                    count_query += ' AND \"messageTimestamp\" >= (extract(epoch from timestamp :start_time)::bigint)'\r\n                    count_params[\"start_time\"] = str(self.start_time).strip()\r\n                if hasattr(self, 'end_time') and self.end_time:\r\n                    count_query += ' AND \"messageTimestamp\" <= (extract(epoch from timestamp :end_time)::bigint)'\r\n                    count_params[\"end_time\"] = str(self.end_time).strip()\r\n\r\n                count_result = conn.execute(text(count_query), count_params)\r\n                total_count = count_result.scalar()\r\n\r\n            # Convert rows to Data objects with pagination info\r\n            return [\r\n                Data(\r\n                    data={\r\n                        \"messageTimestamp\": row[\"messageTimestamp\"],\r\n                        \"key\": row[\"key\"],\r\n                        \"pushName\": row[\"pushName\"],\r\n                        \"message\": row[\"message\"],\r\n                        \"contextInfo\": row[\"contextInfo\"],\r\n                        \"parsed_url\": self.parse_media_url(row[\"message\"]),\r\n                        \"__meta__\": {\r\n                            \"total_records\": total_count,\r\n                            \"page\": self.page,\r\n                            \"page_size\": self.page_size,\r\n                            \"total_pages\": -(-total_count // self.page_size)\r\n                        }\r\n                    }\r\n                )\r\n                for row in rows\r\n            ]\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error executing query: {str(e)}\")\r\n            self.cleanup()  # Ensure cleanup on error\r\n            raise ValueError(f\"Query execution failed: {str(e)}\") from e\r\n\r\n    def get_parsed_urls(self) -> List[Data]:\r\n        \"\"\"Return just the parsed URLs from the audio messages.\"\"\"\r\n        try:\r\n            query, params = self.build_query()\r\n            \r\n            engine = self.get_engine()\r\n            with engine.connect() as conn:\r\n                result = conn.execute(text(query), params)\r\n                rows = [dict(zip(row._fields, row)) for row in result]\r\n\r\n            # Return just the parsed URLs\r\n            return [\r\n                Data(\r\n                    data={\r\n                        \"url\": self.parse_media_url(row[\"message\"])\r\n                    }\r\n                )\r\n                for row in rows\r\n                if self.parse_media_url(row[\"message\"]) is not None\r\n            ]\r\n\r\n        except Exception as e:\r\n            self.log(f\"Error getting parsed URLs: {str(e)}\")\r\n            self.cleanup()  # Ensure cleanup on error\r\n            raise ValueError(f\"Failed to get parsed URLs: {str(e)}\") from e","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"connection_string":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"connection_string","value":"postgresql://evolution_user:Duassenha2024@192.168.112.131:5432/evolution_db","display_name":"Connection String","advanced":false,"dynamic":false,"info":"PostgreSQL connection string (e.g., postgresql://user:pass@host:5432/dbname)","title_case":false,"type":"str","_input_type":"StrInput"},"end_time":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"end_time","value":"","display_name":"End Time","advanced":false,"input_types":["Message"],"dynamic":false,"info":"End time (YYYY-MM-DD HH:MM:SS)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"instance_id":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":true,"placeholder":"","show":true,"name":"instance_id","value":"","display_name":"Instance ID","advanced":false,"dynamic":false,"info":"Evolution API instance identifier","title_case":false,"type":"str","_input_type":"StrInput"},"message_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"message_id","value":"","display_name":"Message ID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Find specific audio message by ID","title_case":false,"type":"str","_input_type":"MessageTextInput"},"page":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":true,"placeholder":"","show":true,"name":"page","value":1,"display_name":"Page","advanced":false,"dynamic":false,"info":"Page number (starts at 1)","title_case":false,"type":"int","_input_type":"IntInput"},"page_size":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":true,"placeholder":"","show":true,"name":"page_size","value":100,"display_name":"Page Size","advanced":false,"dynamic":false,"info":"Number of records per page","title_case":false,"type":"int","_input_type":"IntInput"},"push_name":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"push_name","value":"","display_name":"Push Name","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Filter by contact name","title_case":false,"type":"str","_input_type":"MessageTextInput"},"remote_jid":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"remote_jid","value":"","display_name":"Remote JID","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Filter by remote JID (e.g., 555199999999@s.whatsapp.net)","title_case":false,"type":"str","_input_type":"MessageTextInput"},"sort_direction":{"tool_mode":false,"trace_as_metadata":true,"options":["ASC","DESC"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"sort_direction","value":"DESC","display_name":"Sort Direction","advanced":false,"dynamic":false,"info":"Sort direction by messageTimestamp","title_case":false,"type":"str","_input_type":"DropdownInput"},"start_time":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"start_time","value":"","display_name":"Start Time","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Start time (YYYY-MM-DD HH:MM:SS)","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Query audio messages from Evolution database with different filter options","icon":"mic","base_classes":["Data"],"display_name":"Evolution Audio Message Query","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"messages","display_name":"Messages","method":"execute_query","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"parsed_urls","display_name":"Parsed URLs","method":"get_parsed_urls","value":"__UNDEFINED__","cache":true}],"field_order":["connection_string","instance_id","message_id","remote_jid","push_name","start_time","end_time","sort_direction","page_size","page"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14"},"type":"CustomComponent","id":"CustomComponent-P72R8"},"selected":false,"measured":{"width":320,"height":1075},"dragging":false},{"id":"CurrentDate-Uth48","type":"genericNode","position":{"x":-4004.651681146568,"y":-819.1368946144758},"data":{"node":{"template":{"_type":"Component","webhook":{"tool_mode":true,"trace_as_metadata":true,"list":false,"trace_as_input":true,"required":false,"placeholder":"","show":true,"name":"webhook","value":"","display_name":"Webhook Data","advanced":false,"input_types":["Data"],"dynamic":false,"info":"Data input used to trigger component execution. The data itself is not used.","title_case":false,"type":"other","_input_type":"DataInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from datetime import datetime, timedelta\r\nfrom zoneinfo import ZoneInfo\r\nfrom langflow.custom import Component\r\nfrom langflow.io import DropdownInput, Output, DataInput\r\nfrom langflow.schema.message import Message\r\n\r\nclass TimeIntervalComponent(Component):\r\n    display_name = \"Time Interval\"\r\n    description = \"Returns the start and end dates for different time intervals in the selected timezone.\"\r\n    icon = \"clock\"\r\n    name = \"TimeInterval\"\r\n    \r\n    inputs = [\r\n        DropdownInput(\r\n            name=\"timezone\",\r\n            display_name=\"Timezone\",\r\n            options=[\r\n                \"UTC\",\r\n                \"US/Eastern\", \r\n                \"US/Central\", \r\n                \"US/Mountain\",\r\n                \"US/Pacific\",\r\n                \"Europe/London\",\r\n                \"Europe/Paris\",\r\n                \"Europe/Berlin\",\r\n                \"Europe/Moscow\",\r\n                \"Asia/Tokyo\",\r\n                \"Asia/Shanghai\",\r\n                \"Asia/Singapore\",\r\n                \"Asia/Dubai\",\r\n                \"Australia/Sydney\",\r\n                \"Australia/Melbourne\",\r\n                \"Pacific/Auckland\",\r\n                \"America/Sao_Paulo\",\r\n                \"America/Mexico_City\",\r\n                \"America/Toronto\",\r\n                \"America/Vancouver\",\r\n                \"Africa/Cairo\",\r\n                \"Africa/Johannesburg\",\r\n                \"Atlantic/Reykjavik\",\r\n                \"Indian/Maldives\",\r\n                \"America/Bogota\",\r\n                \"America/Lima\",\r\n                \"America/Santiago\",\r\n                \"America/Buenos_Aires\",\r\n                \"America/Caracas\",\r\n                \"America/La_Paz\",\r\n                \"America/Montevideo\",\r\n                \"America/Asuncion\",\r\n                \"America/Cuiaba\",\r\n            ],\r\n            value=\"UTC\",\r\n            info=\"Select the timezone for the time interval calculation.\",\r\n            tool_mode=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"interval\",\r\n            display_name=\"Time Interval\",\r\n            options=[\r\n                \"1 hour\",\r\n                \"12 hours\",\r\n                \"1 day\",\r\n                \"7 days\",\r\n                \"15 days\",\r\n                \"1 month\"\r\n            ],\r\n            value=\"1 day\",\r\n            info=\"Select the time interval to calculate.\",\r\n            tool_mode=True,\r\n        ),\r\n        DataInput(\r\n            name=\"webhook\",\r\n            display_name=\"Webhook Data\",\r\n            info=\"Data input used to trigger component execution. The data itself is not used.\",\r\n            tool_mode=True,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            display_name=\"Start Time\", \r\n            name=\"start_time\", \r\n            method=\"get_start_time\"\r\n        ),\r\n        Output(\r\n            display_name=\"End Time\", \r\n            name=\"end_time\", \r\n            method=\"get_end_time\"\r\n        ),\r\n    ]\r\n\r\n    def calculate_times(self):\r\n        \"\"\"Helper method to calculate interval times.\"\"\"\r\n        # Get current time in specified timezone\r\n        tz = ZoneInfo(self.timezone)\r\n        end_time = datetime.now(tz)\r\n        \r\n        # Calculate start time based on selected interval\r\n        interval_map = {\r\n            \"1 hour\": timedelta(hours=1),\r\n            \"12 hours\": timedelta(hours=12),\r\n            \"1 day\": timedelta(days=1),\r\n            \"7 days\": timedelta(days=7),\r\n            \"15 days\": timedelta(days=15),\r\n            \"1 month\": timedelta(days=30)  # Approximating month as 30 days\r\n        }\r\n        \r\n        interval = interval_map[self.interval]\r\n        start_time = end_time - interval\r\n        \r\n        # Format with full timestamp\r\n        start_formatted = start_time.strftime(\"%Y-%m-%d %H:%M:%S\")\r\n        end_formatted = end_time.strftime(\"%Y-%m-%d %H:%M:%S\")\r\n        \r\n        return start_formatted, end_formatted\r\n\r\n    def get_start_time(self) -> Message:\r\n        \"\"\"Return the start time for the selected interval.\"\"\"\r\n        try:\r\n            start_time, _ = self.calculate_times()\r\n            return Message(text=start_time)\r\n        except Exception as e:\r\n            return Message(text=f\"Error calculating start time: {str(e)}\")\r\n\r\n    def get_end_time(self) -> Message:\r\n        \"\"\"Return the end time for the selected interval.\"\"\"\r\n        try:\r\n            _, end_time = self.calculate_times()\r\n            return Message(text=end_time)\r\n        except Exception as e:\r\n            return Message(text=f\"Error calculating end time: {str(e)}\")","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"interval":{"tool_mode":true,"trace_as_metadata":true,"options":["1 hour","12 hours","1 day","7 days","15 days","1 month"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"interval","value":"1 day","display_name":"Time Interval","advanced":false,"dynamic":false,"info":"Select the time interval to calculate.","title_case":false,"type":"str","_input_type":"DropdownInput"},"timezone":{"tool_mode":true,"trace_as_metadata":true,"options":["UTC","US/Eastern","US/Central","US/Mountain","US/Pacific","Europe/London","Europe/Paris","Europe/Berlin","Europe/Moscow","Asia/Tokyo","Asia/Shanghai","Asia/Singapore","Asia/Dubai","Australia/Sydney","Australia/Melbourne","Pacific/Auckland","America/Sao_Paulo","America/Mexico_City","America/Toronto","America/Vancouver","Africa/Cairo","Africa/Johannesburg","Atlantic/Reykjavik","Indian/Maldives","America/Bogota","America/Lima","America/Santiago","America/Buenos_Aires","America/Caracas","America/La_Paz","America/Montevideo","America/Asuncion","America/Cuiaba"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"timezone","value":"America/Sao_Paulo","display_name":"Timezone","advanced":false,"dynamic":false,"info":"Select the timezone for the time interval calculation.","title_case":false,"type":"str","_input_type":"DropdownInput","load_from_db":false}},"description":"Returns the start and end dates for different time intervals in the selected timezone.","icon":"clock","base_classes":["Message"],"display_name":"Time Interval","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"start_time","display_name":"Start Time","method":"get_start_time","value":"__UNDEFINED__","cache":true},{"types":["Message"],"selected":"Message","name":"end_time","display_name":"End Time","method":"get_end_time","value":"__UNDEFINED__","cache":true}],"field_order":["timezone","interval","webhook"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14"},"type":"CurrentDate","id":"CurrentDate-Uth48"},"selected":false,"measured":{"width":320,"height":435},"dragging":false},{"id":"CustomComponent-OZWNs","type":"genericNode","position":{"x":-2933.89978653918,"y":-409.39431479892517},"data":{"node":{"template":{"_type":"Component","data":{"tool_mode":false,"trace_as_metadata":true,"list":false,"trace_as_input":true,"required":false,"placeholder":"","show":true,"name":"data","value":"","display_name":"Data","advanced":false,"input_types":["Data"],"dynamic":false,"info":"The initial list of Data objects to iterate over.","title_case":false,"type":"other","_input_type":"DataInput"},"loop":{"tool_mode":false,"trace_as_metadata":true,"list":false,"trace_as_input":true,"required":false,"placeholder":"","show":true,"name":"loop","value":"","display_name":"Loop Input","advanced":false,"input_types":["Data"],"dynamic":false,"info":"Data to aggregate during the iteration.","title_case":false,"type":"other","_input_type":"DataInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from langflow.custom import Component\nfrom langflow.io import DataInput, Output\nfrom langflow.schema import Data\n\n\nclass IteratorComponent(Component):\n    display_name = \"Loop\"\n    description = (\n        \"Iterates over a list of Data objects, outputting one item at a time and aggregating results from loop inputs.\"\n    )\n    icon = \"infinity\"\n\n    inputs = [\n        DataInput(name=\"data\", display_name=\"Data\", info=\"The initial list of Data objects to iterate over.\"),\n        DataInput(name=\"loop\", display_name=\"Loop Input\", info=\"Data to aggregate during the iteration.\"),\n    ]\n\n    outputs = [\n        Output(display_name=\"Item\", name=\"item\", method=\"item_output\"),\n        Output(display_name=\"Done\", name=\"done\", method=\"done_output\"),\n    ]\n\n    def initialize_data(self):\n        \"\"\"Initialize the data list, context index, and aggregated list.\"\"\"\n        if not self.ctx.get(f\"{self._id}_initialized\", False):\n            # Ensure data is a list of Data objects\n            if isinstance(self.data, Data):\n                data_list = [self.data]\n            elif isinstance(self.data, list):\n                data_list = self.data\n            else:\n                raise ValueError(\"The 'data' input must be a list of Data objects or a single Data object.\")\n\n            # Store the initial data and context variables\n            self.update_ctx(\n                {\n                    f\"{self._id}_data\": data_list,\n                    f\"{self._id}_index\": 0,\n                    f\"{self._id}_aggregated\": [],\n                    f\"{self._id}_initialized\": True,\n                }\n            )\n\n    def item_output(self) -> Data:\n        \"\"\"Output the next item in the list.\"\"\"\n        self.initialize_data()\n\n        # Get data list and current index\n        data_list = self.ctx.get(f\"{self._id}_data\", [])\n        current_index = self.ctx.get(f\"{self._id}_index\", 0)\n\n        if current_index < len(data_list):\n            # Output current item\n            current_item = data_list[current_index]\n            self.update_ctx({f\"{self._id}_index\": current_index + 1})\n            print(\"item_output:\", current_item)\n            return current_item\n        # No more items to output\n        self.stop(\"item\")\n        return None\n\n    def done_output(self) -> Data:\n        \"\"\"Return the aggregated list once all items are processed.\"\"\"\n        self.initialize_data()\n\n        # Get data list and aggregated list\n        data_list = self.ctx.get(f\"{self._id}_data\", [])\n        aggregated = self.ctx.get(f\"{self._id}_aggregated\", [])\n\n        # Check if loop input is provided\n        loop_input = self.loop\n        if loop_input:\n            # Append loop input to aggregated list\n            aggregated.append(loop_input)\n            self.update_ctx({f\"{self._id}_aggregated\": aggregated})\n\n        # Check if aggregation is complete\n        if len(aggregated) >= len(data_list):\n            print(\"done_output:\", aggregated)\n            return [data for data in aggregated]\n        # Not all items have been processed yet\n        self.stop(\"done\")\n        return None","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false}},"description":"Iterates over a list of Data objects, outputting one item at a time and aggregating results from loop inputs.","icon":"infinity","base_classes":["Data"],"display_name":"Loop","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"item","display_name":"Item","method":"item_output","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"done","display_name":"Done","method":"done_output","value":"__UNDEFINED__","cache":true}],"field_order":["data","loop"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14"},"type":"CustomComponent","id":"CustomComponent-OZWNs"},"selected":false,"measured":{"width":320,"height":331},"dragging":false},{"id":"ParseData-S0SHi","type":"genericNode","position":{"x":-2492.5760395372517,"y":-465.9279580586717},"data":{"node":{"template":{"_type":"Component","data":{"tool_mode":false,"trace_as_metadata":true,"list":true,"trace_as_input":true,"required":false,"placeholder":"","show":true,"name":"data","value":"","display_name":"Data","advanced":false,"input_types":["Data"],"dynamic":false,"info":"The data to convert to text.","title_case":false,"type":"other","_input_type":"DataInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from typing import Optional, Tuple, List\r\nfrom langflow.custom import Component\r\nfrom langflow.helpers.data import data_to_text, data_to_text_list\r\nfrom langflow.io import DataInput, MultilineInput, Output, StrInput\r\nfrom langflow.schema import Data\r\nfrom langflow.schema.message import Message\r\n\r\nclass ParseDataComponent(Component):\r\n    display_name = \"Parse Data\"\r\n    description = \"Convert Data into plain text following a specified template.\"\r\n    icon = \"braces\"\r\n    name = \"ParseData\"\r\n\r\n    inputs = [\r\n        DataInput(\r\n            name=\"data\",\r\n            display_name=\"Data\",\r\n            info=\"The data to convert to text.\",\r\n            is_list=True,\r\n            required=False,\r\n        ),\r\n        MultilineInput(\r\n            name=\"template\",\r\n            display_name=\"Template\",\r\n            info=\"The template to use for formatting the data. \"\r\n            \"It can contain the keys {text}, {data} or any other key in the Data.\",\r\n            value=\"{text}\",\r\n            required=False,\r\n        ),\r\n        StrInput(\r\n            name=\"sep\",\r\n            display_name=\"Separator\",\r\n            advanced=True,\r\n            value=\"\\n\",\r\n            required=False,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            display_name=\"Text\",\r\n            name=\"text\",\r\n            info=\"Data as a single Message, with each input Data separated by Separator\",\r\n            method=\"parse_data\",\r\n        ),\r\n        Output(\r\n            display_name=\"Data List\",\r\n            name=\"data_list\",\r\n            info=\"Data as a list of new Data, each having `text` formatted by Template\",\r\n            method=\"parse_data_as_list\",\r\n        ),\r\n    ]\r\n\r\n    def _clean_args(self) -> Tuple[List[Data], str, str]:\r\n        \"\"\"Clean and validate input arguments with safe defaults.\"\"\"\r\n        try:\r\n            # Handle data input\r\n            data = getattr(self, 'data', None)\r\n            if data is None:\r\n                data = []\r\n            elif not isinstance(data, list):\r\n                data = [data]\r\n\r\n            # Handle template input\r\n            template = getattr(self, 'template', '{text}') or '{text}'\r\n\r\n            # Handle separator input\r\n            sep = getattr(self, 'sep', '\\n') or '\\n'\r\n\r\n            return data, template, sep\r\n        except Exception as e:\r\n            self.log(f\"Error in _clean_args: {str(e)}\")\r\n            return [], '{text}', '\\n'\r\n\r\n    def parse_data(self) -> Message:\r\n        \"\"\"Parse data into a single message.\"\"\"\r\n        try:\r\n            data, template, sep = self._clean_args()\r\n            if not data:\r\n                result_string = \"\"\r\n            else:\r\n                result_string = data_to_text(template, data, sep)\r\n            self.status = result_string\r\n            return Message(text=result_string)\r\n        except Exception as e:\r\n            self.log(f\"Error in parse_data: {str(e)}\")\r\n            return Message(text=\"\")\r\n\r\n    def parse_data_as_list(self) -> List[Data]:\r\n        \"\"\"Parse data into a list of Data objects.\"\"\"\r\n        try:\r\n            data, template, _ = self._clean_args()\r\n            if not data:\r\n                return []\r\n            \r\n            text_list, data_list = data_to_text_list(template, data)\r\n            for item, text in zip(data_list, text_list, strict=True):\r\n                item.set_text(text)\r\n            self.status = data_list\r\n            return data_list\r\n        except Exception as e:\r\n            self.log(f\"Error in parse_data_as_list: {str(e)}\")\r\n            return []","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"sep":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"sep","value":"\n","display_name":"Separator","advanced":true,"dynamic":false,"info":"","title_case":false,"type":"str","_input_type":"StrInput"},"template":{"tool_mode":false,"trace_as_input":true,"multiline":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"template","value":"{conversation}","display_name":"Template","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The template to use for formatting the data. It can contain the keys {text}, {data} or any other key in the Data.","title_case":false,"type":"str","_input_type":"MultilineInput"}},"description":"Convert Data into plain text following a specified template.","icon":"braces","base_classes":["Data","Message"],"display_name":"Parse Data","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"text","display_name":"Text","method":"parse_data","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"data_list","display_name":"Data List","method":"parse_data_as_list","value":"__UNDEFINED__","cache":true}],"field_order":["data","template","sep"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14"},"type":"ParseData","id":"ParseData-S0SHi"},"selected":false,"measured":{"width":320,"height":349},"dragging":false},{"id":"ChatOutput-TnmL1","type":"genericNode","position":{"x":-2064.9313240194433,"y":-479.11472152969435},"data":{"node":{"template":{"_type":"Component","background_color":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"background_color","value":"","display_name":"Background Color","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The background color of the icon.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"chat_icon":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"chat_icon","value":"","display_name":"Icon","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The icon of the message.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.io import DropdownInput, MessageInput, MessageTextInput, Output\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_NAME_AI, MESSAGE_SENDER_USER\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n\n    inputs = [\n        MessageInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Message to be passed as output.\",\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            source_dict[\"source\"] = source\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n        background_color = self.background_color\n        text_color = self.text_color\n        if self.chat_icon:\n            icon = self.chat_icon\n        message = self.input_value if isinstance(self.input_value, Message) else Message(text=self.input_value)\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n        message.properties.icon = icon\n        message.properties.background_color = background_color\n        message.properties.text_color = text_color\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = await self.send_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"data_template":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"data_template","value":"{text}","display_name":"Data Template","advanced":true,"input_types":["Message"],"dynamic":false,"info":"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"input_value":{"trace_as_input":true,"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"input_value","value":"","display_name":"Text","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Message to be passed as output.","title_case":false,"type":"str","_input_type":"MessageInput"},"sender":{"tool_mode":false,"trace_as_metadata":true,"options":["Machine","User"],"combobox":false,"required":false,"placeholder":"","show":true,"name":"sender","value":"Machine","display_name":"Sender Type","advanced":true,"dynamic":false,"info":"Type of sender.","title_case":false,"type":"str","_input_type":"DropdownInput"},"sender_name":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"sender_name","value":"AI","display_name":"Sender Name","advanced":true,"input_types":["Message"],"dynamic":false,"info":"Name of the sender.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"session_id":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"session_id","value":"","display_name":"Session ID","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The session ID of the chat. If empty, the current session ID parameter will be used.","title_case":false,"type":"str","_input_type":"MessageTextInput"},"should_store_message":{"tool_mode":false,"trace_as_metadata":true,"list":false,"required":false,"placeholder":"","show":true,"name":"should_store_message","value":true,"display_name":"Store Messages","advanced":true,"dynamic":false,"info":"Store the message in the history.","title_case":false,"type":"bool","_input_type":"BoolInput"},"text_color":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"text_color","value":"","display_name":"Text Color","advanced":true,"input_types":["Message"],"dynamic":false,"info":"The text color of the name","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Display a chat message in the Playground.","icon":"MessagesSquare","base_classes":["Message"],"display_name":"Chat Output","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"message","display_name":"Message","method":"message_response","value":"__UNDEFINED__","cache":true}],"field_order":["input_value","should_store_message","sender","sender_name","session_id","data_template","background_color","chat_icon","text_color"],"beta":false,"legacy":false,"edited":false,"metadata":{},"tool_mode":false,"category":"outputs","key":"ChatOutput","score":0.003169567463043492,"lf_version":"1.1.1.dev14"},"type":"ChatOutput","id":"ChatOutput-TnmL1"},"selected":false,"measured":{"width":320,"height":233},"dragging":false},{"id":"Webhook-mfvc0","type":"genericNode","position":{"x":-4464.25631728436,"y":-716.4178130009489},"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"import json\n\nfrom langflow.custom import Component\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema import Data\n\n\nclass WebhookComponent(Component):\n    display_name = \"Webhook\"\n    description = \"Defines a webhook input for the flow.\"\n    name = \"Webhook\"\n    icon = \"webhook\"\n\n    inputs = [\n        MultilineInput(\n            name=\"data\",\n            display_name=\"Payload\",\n            info=\"Receives a payload from external systems via HTTP POST.\",\n        )\n    ]\n    outputs = [\n        Output(display_name=\"Data\", name=\"output_data\", method=\"build_data\"),\n    ]\n\n    def build_data(self) -> Data:\n        message: str | Data = \"\"\n        if not self.data:\n            self.status = \"No data provided.\"\n            return Data(data={})\n        try:\n            body = json.loads(self.data or \"{}\")\n        except json.JSONDecodeError:\n            body = {\"payload\": self.data}\n            message = f\"Invalid JSON payload. Please check the format.\\n\\n{self.data}\"\n        data = Data(data=body)\n        if not message:\n            message = data\n        self.status = message\n        return data\n","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"data":{"tool_mode":false,"trace_as_input":true,"multiline":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"data","value":"","display_name":"Payload","advanced":false,"input_types":["Message"],"dynamic":false,"info":"Receives a payload from external systems via HTTP POST.","title_case":false,"type":"str","_input_type":"MultilineInput"}},"description":"Defines a webhook input for the flow.","icon":"webhook","base_classes":["Data"],"display_name":"Webhook","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Data"],"selected":"Data","name":"output_data","display_name":"Data","method":"build_data","value":"__UNDEFINED__","cache":true}],"field_order":["data"],"beta":false,"legacy":false,"edited":false,"metadata":{},"tool_mode":false,"category":"data","key":"Webhook","score":0.0004187935651179184,"lf_version":"1.1.1.dev14"},"type":"Webhook","id":"Webhook-mfvc0"},"selected":false,"measured":{"width":320,"height":233},"dragging":false}],"edges":[{"source":"CustomComponent-OZWNs","sourceHandle":"{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-OZWNsœ,œnameœ:œdoneœ,œoutput_typesœ:[œDataœ]}","target":"ParseData-S0SHi","targetHandle":"{œfieldNameœ:œdataœ,œidœ:œParseData-S0SHiœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","data":{"targetHandle":{"fieldName":"data","id":"ParseData-S0SHi","inputTypes":["Data"],"type":"other"},"sourceHandle":{"dataType":"CustomComponent","id":"CustomComponent-OZWNs","name":"done","output_types":["Data"]}},"id":"reactflow__edge-CustomComponent-OZWNs{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-OZWNsœ,œnameœ:œdoneœ,œoutput_typesœ:[œDataœ]}-ParseData-S0SHi{œfieldNameœ:œdataœ,œidœ:œParseData-S0SHiœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","animated":false,"className":"","selected":false},{"source":"CustomComponent-OZWNs","sourceHandle":"{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-OZWNsœ,œnameœ:œitemœ,œoutput_typesœ:[œDataœ]}","target":"CustomComponent-n4VUY","targetHandle":"{œfieldNameœ:œinput_dataœ,œidœ:œCustomComponent-n4VUYœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","data":{"targetHandle":{"fieldName":"input_data","id":"CustomComponent-n4VUY","inputTypes":["Data"],"type":"other"},"sourceHandle":{"dataType":"CustomComponent","id":"CustomComponent-OZWNs","name":"item","output_types":["Data"]}},"id":"reactflow__edge-CustomComponent-OZWNs{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-OZWNsœ,œnameœ:œitemœ,œoutput_typesœ:[œDataœ]}-CustomComponent-n4VUY{œfieldNameœ:œinput_dataœ,œidœ:œCustomComponent-n4VUYœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","animated":false,"className":"","selected":false},{"source":"CurrentDate-Uth48","sourceHandle":"{œdataTypeœ:œCurrentDateœ,œidœ:œCurrentDate-Uth48œ,œnameœ:œstart_timeœ,œoutput_typesœ:[œMessageœ]}","target":"CustomComponent-P72R8","targetHandle":"{œfieldNameœ:œstart_timeœ,œidœ:œCustomComponent-P72R8œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"start_time","id":"CustomComponent-P72R8","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"CurrentDate","id":"CurrentDate-Uth48","name":"start_time","output_types":["Message"]}},"id":"reactflow__edge-CurrentDate-Uth48{œdataTypeœ:œCurrentDateœ,œidœ:œCurrentDate-Uth48œ,œnameœ:œstart_timeœ,œoutput_typesœ:[œMessageœ]}-CustomComponent-P72R8{œfieldNameœ:œstart_timeœ,œidœ:œCustomComponent-P72R8œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","animated":false,"className":"","selected":false},{"source":"CurrentDate-Uth48","sourceHandle":"{œdataTypeœ:œCurrentDateœ,œidœ:œCurrentDate-Uth48œ,œnameœ:œend_timeœ,œoutput_typesœ:[œMessageœ]}","target":"CustomComponent-P72R8","targetHandle":"{œfieldNameœ:œend_timeœ,œidœ:œCustomComponent-P72R8œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"end_time","id":"CustomComponent-P72R8","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"CurrentDate","id":"CurrentDate-Uth48","name":"end_time","output_types":["Message"]}},"id":"reactflow__edge-CurrentDate-Uth48{œdataTypeœ:œCurrentDateœ,œidœ:œCurrentDate-Uth48œ,œnameœ:œend_timeœ,œoutput_typesœ:[œMessageœ]}-CustomComponent-P72R8{œfieldNameœ:œend_timeœ,œidœ:œCustomComponent-P72R8œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","animated":false,"className":"","selected":false},{"source":"ParseData-S0SHi","sourceHandle":"{œdataTypeœ:œParseDataœ,œidœ:œParseData-S0SHiœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}","target":"ChatOutput-TnmL1","targetHandle":"{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-TnmL1œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","data":{"targetHandle":{"fieldName":"input_value","id":"ChatOutput-TnmL1","inputTypes":["Message"],"type":"str"},"sourceHandle":{"dataType":"ParseData","id":"ParseData-S0SHi","name":"text","output_types":["Message"]}},"id":"reactflow__edge-ParseData-S0SHi{œdataTypeœ:œParseDataœ,œidœ:œParseData-S0SHiœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-TnmL1{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-TnmL1œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}","animated":false,"className":"","selected":false},{"source":"CustomComponent-P72R8","sourceHandle":"{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-P72R8œ,œnameœ:œmessagesœ,œoutput_typesœ:[œDataœ]}","target":"CustomComponent-OZWNs","targetHandle":"{œfieldNameœ:œdataœ,œidœ:œCustomComponent-OZWNsœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","data":{"targetHandle":{"fieldName":"data","id":"CustomComponent-OZWNs","inputTypes":["Data"],"type":"other"},"sourceHandle":{"dataType":"CustomComponent","id":"CustomComponent-P72R8","name":"messages","output_types":["Data"]}},"id":"reactflow__edge-CustomComponent-P72R8{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-P72R8œ,œnameœ:œmessagesœ,œoutput_typesœ:[œDataœ]}-CustomComponent-OZWNs{œfieldNameœ:œdataœ,œidœ:œCustomComponent-OZWNsœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","animated":false,"className":"","selected":false},{"source":"CustomComponent-n4VUY","sourceHandle":"{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-n4VUYœ,œnameœ:œtranscriptionœ,œoutput_typesœ:[œDataœ]}","target":"CustomComponent-OZWNs","targetHandle":"{œfieldNameœ:œloopœ,œidœ:œCustomComponent-OZWNsœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","data":{"targetHandle":{"fieldName":"loop","id":"CustomComponent-OZWNs","inputTypes":["Data"],"type":"other"},"sourceHandle":{"dataType":"CustomComponent","id":"CustomComponent-n4VUY","name":"transcription","output_types":["Data"]}},"id":"reactflow__edge-CustomComponent-n4VUY{œdataTypeœ:œCustomComponentœ,œidœ:œCustomComponent-n4VUYœ,œnameœ:œtranscriptionœ,œoutput_typesœ:[œDataœ]}-CustomComponent-OZWNs{œfieldNameœ:œloopœ,œidœ:œCustomComponent-OZWNsœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","animated":false,"className":"","selected":false},{"source":"Webhook-mfvc0","sourceHandle":"{œdataTypeœ:œWebhookœ,œidœ:œWebhook-mfvc0œ,œnameœ:œoutput_dataœ,œoutput_typesœ:[œDataœ]}","target":"CurrentDate-Uth48","targetHandle":"{œfieldNameœ:œwebhookœ,œidœ:œCurrentDate-Uth48œ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","data":{"targetHandle":{"fieldName":"webhook","id":"CurrentDate-Uth48","inputTypes":["Data"],"type":"other"},"sourceHandle":{"dataType":"Webhook","id":"Webhook-mfvc0","name":"output_data","output_types":["Data"]}},"id":"reactflow__edge-Webhook-mfvc0{œdataTypeœ:œWebhookœ,œidœ:œWebhook-mfvc0œ,œnameœ:œoutput_dataœ,œoutput_typesœ:[œDataœ]}-CurrentDate-Uth48{œfieldNameœ:œwebhookœ,œidœ:œCurrentDate-Uth48œ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}","className":"","selected":false}],"viewport":{"x":2486.1382741136686,"y":759.9833449613245,"zoom":0.5482644018650574}},"is_component":false,"updated_at":"2025-01-06T18:12:46+00:00","webhook":true,"endpoint_name":"auto_transcription","tags":null,"locked":null,"id":"9088bc2b-450a-4f27-aadf-8bc11c9ca8d2","user_id":"556fed76-1562-4baf-8a2e-ef9be2d194e4","folder_id":"22c5349e-60ef-45a2-a8ec-0debcd24f6dd"},{"name":"Clean SQL","description":"Convert Data into plain text following a specified template.","icon":null,"icon_bg_color":null,"gradient":null,"data":{"edges":[],"nodes":[{"data":{"node":{"template":{"_type":"Component","data":{"tool_mode":false,"trace_as_metadata":true,"list":true,"trace_as_input":true,"required":false,"placeholder":"","show":true,"name":"data","value":"","display_name":"Data","advanced":false,"input_types":["Data"],"dynamic":false,"info":"The data to convert to text.","title_case":false,"type":"other","_input_type":"DataInput"},"code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"from typing import Optional, Tuple, List\r\nfrom langflow.custom import Component\r\nfrom langflow.helpers.data import data_to_text, data_to_text_list\r\nfrom langflow.io import DataInput, MultilineInput, Output, StrInput\r\nfrom langflow.schema import Data\r\nfrom langflow.schema.message import Message\r\n\r\nclass ParseDataComponent(Component):\r\n    display_name = \"Parse Data\"\r\n    description = \"Convert Data into plain text following a specified template.\"\r\n    icon = \"braces\"\r\n    name = \"ParseData\"\r\n\r\n    inputs = [\r\n        DataInput(\r\n            name=\"data\",\r\n            display_name=\"Data\",\r\n            info=\"The data to convert to text.\",\r\n            is_list=True,\r\n            required=False,\r\n        ),\r\n        MultilineInput(\r\n            name=\"template\",\r\n            display_name=\"Template\",\r\n            info=\"The template to use for formatting the data. \"\r\n            \"It can contain the keys {text}, {data} or any other key in the Data.\",\r\n            value=\"{text}\",\r\n            required=False,\r\n        ),\r\n        StrInput(\r\n            name=\"sep\",\r\n            display_name=\"Separator\",\r\n            advanced=True,\r\n            value=\"\\n\",\r\n            required=False,\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            display_name=\"Text\",\r\n            name=\"text\",\r\n            info=\"Data as a single Message, with each input Data separated by Separator\",\r\n            method=\"parse_data\",\r\n        ),\r\n        Output(\r\n            display_name=\"Data List\",\r\n            name=\"data_list\",\r\n            info=\"Data as a list of new Data, each having `text` formatted by Template\",\r\n            method=\"parse_data_as_list\",\r\n        ),\r\n    ]\r\n\r\n    def _clean_args(self) -> Tuple[List[Data], str, str]:\r\n        \"\"\"Clean and validate input arguments with safe defaults.\"\"\"\r\n        try:\r\n            # Handle data input\r\n            data = getattr(self, 'data', None)\r\n            if data is None:\r\n                data = []\r\n            elif not isinstance(data, list):\r\n                data = [data]\r\n\r\n            # Handle template input\r\n            template = getattr(self, 'template', '{text}') or '{text}'\r\n\r\n            # Handle separator input\r\n            sep = getattr(self, 'sep', '\\n') or '\\n'\r\n\r\n            return data, template, sep\r\n        except Exception as e:\r\n            self.log(f\"Error in _clean_args: {str(e)}\")\r\n            return [], '{text}', '\\n'\r\n\r\n    def parse_data(self) -> Message:\r\n        \"\"\"Parse data into a single message.\"\"\"\r\n        try:\r\n            data, template, sep = self._clean_args()\r\n            if not data:\r\n                result_string = \"\"\r\n            else:\r\n                result_string = data_to_text(template, data, sep)\r\n            self.status = result_string\r\n            return Message(text=result_string)\r\n        except Exception as e:\r\n            self.log(f\"Error in parse_data: {str(e)}\")\r\n            return Message(text=\"\")\r\n\r\n    def parse_data_as_list(self) -> List[Data]:\r\n        \"\"\"Parse data into a list of Data objects.\"\"\"\r\n        try:\r\n            data, template, _ = self._clean_args()\r\n            if not data:\r\n                return []\r\n            \r\n            text_list, data_list = data_to_text_list(template, data)\r\n            for item, text in zip(data_list, text_list, strict=True):\r\n                item.set_text(text)\r\n            self.status = data_list\r\n            return data_list\r\n        except Exception as e:\r\n            self.log(f\"Error in parse_data_as_list: {str(e)}\")\r\n            return []","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"sep":{"tool_mode":false,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"sep","value":"\n","display_name":"Separator","advanced":true,"dynamic":false,"info":"","title_case":false,"type":"str","_input_type":"StrInput"},"template":{"tool_mode":false,"trace_as_input":true,"multiline":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"required":false,"placeholder":"","show":true,"name":"template","value":"SELECT pg_terminate_backend(pid) FROM pg_stat_activity  WHERE datname = 'evolution_db'   AND state = 'idle'   AND pid <> pg_backend_pid();","display_name":"Template","advanced":false,"input_types":["Message"],"dynamic":false,"info":"The template to use for formatting the data. It can contain the keys {text}, {data} or any other key in the Data.","title_case":false,"type":"str","_input_type":"MultilineInput"}},"description":"Convert Data into plain text following a specified template.","icon":"braces","base_classes":["Data","Message"],"display_name":"Clean SQL","documentation":"","custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["Message"],"selected":"Message","name":"text","display_name":"Text","method":"parse_data","value":"__UNDEFINED__","cache":true},{"types":["Data"],"selected":"Data","name":"data_list","display_name":"Data List","method":"parse_data_as_list","value":"__UNDEFINED__","cache":true}],"field_order":["data","template","sep"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"lf_version":"1.1.1.dev14","official":false},"type":"ParseData","id":"ParseData-uAkSG"},"id":"ParseData-uAkSG","position":{"x":0,"y":0},"type":"genericNode"}],"viewport":{"x":1,"y":1,"zoom":1}},"is_component":true,"updated_at":"2025-01-06T17:56:25+00:00","webhook":false,"endpoint_name":null,"tags":null,"locked":false,"id":"0a1299bc-0ef7-497a-b436-6340e0c2203d","user_id":"556fed76-1562-4baf-8a2e-ef9be2d194e4","folder_id":"22c5349e-60ef-45a2-a8ec-0debcd24f6dd"}]